###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        13/Jul/2017  14:23:12
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\demo\SUBDEV_SWITCH\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_dma.c
#    Command line =  
#        F:\demo\SUBDEV_SWITCH\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_dma.c
#        -D STM32L053xx -D USE_HAL_DRIVER -lc
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\List\ -o
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\Obj\ --debug
#        --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\..\Drivers\STM32L0xx_HAL_Driver\Inc\
#        -I F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\Inc\ -I
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\..\Drivers\CMSIS\Device\ST\STM32L0xx\Include\
#        -I F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\..\Drivers\CMSIS\Include\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\List\stm32l0xx_hal_dma.lst
#    Object file  =  
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\Obj\stm32l0xx_hal_dma.o
#
###############################################################################

F:\demo\SUBDEV_SWITCH\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_dma.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l0xx_hal_dma.c
      4            * @author  MCD Application Team
      5            * @version V1.1.0
      6            * @date    18-June-2014
      7            * @brief   DMA HAL module driver.
      8            *    
      9            *         This file provides firmware functions to manage the following 
     10            *         functionalities of the Direct Memory Access (DMA) peripheral:
     11            *           + Initialization/de-initialization functions
     12            *           + I/O operation functions
     13            *           + Peripheral State functions
     14            *  
     15            *           
     16            @verbatim     
     17            ==============================================================================      
     18                                  ##### How to use this driver #####
     19            ============================================================================== 
     20            [..]
     21             (#) Enable and configure the peripheral to be connected to the DMA Channel
     22                 (except for internal SRAM / FLASH memories: no initialization is 
     23                 necessary). 
     24                    
     25             (#) For a given Channel, program the required configuration through the following parameters:   
     26                 Channel request, Transfer Direction, Source and Destination data formats, 
     27                 Circular, Normal or peripheral flow control mode, Channel Priority level, 
     28                 Source and Destination Increment mode using HAL_DMA_Init() function.
     29             
     30               *** Polling mode IO operation ***
     31               =================================   
     32              [..] 
     33                    (+) Use HAL_DMA_Start() to start DMA transfer after the configuration of Source 
     34                        address and destination address and the Length of data to be transferred
     35                    (+) Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this  
     36                        case a fixed Timeout can be configured by User depending from his application.
     37                         
     38               *** Interrupt mode IO operation ***    
     39               =================================== 
     40              [..]     
     41                    (+) Configure the DMA interrupt priority using HAL_NVIC_SetPriority()
     42                    (+) Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ() 
     43                    (+) Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of  
     44                        Source address and destination address and the Length of data to be transferred. In this 
     45                        case the DMA interrupt is configured 
     46                    (+) Use HAL_DMA_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine
     47                    (+) At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can 
     48                        add his own function by customization of function pointer XferCpltCallback and 
     49                        XferErrorCallback (i.e a member of DMA handle structure). 
     50                          
     51               (#) Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error 
     52                   detection.
     53                   
     54               (#) Use HAL_DMA_Abort() function to abort the current transfer              
     55                             
     56               -@-   In Memory-to-Memory transfer mode, Circular mode is not allowed.          
     57            
     58            @endverbatim
     59            ******************************************************************************
     60            * @attention
     61            *
     62            * <h2><center>&copy; COPYRIGHT(c) 2014 STMicroelectronics</center></h2>
     63            *
     64            * Redistribution and use in source and binary forms, with or without modification,
     65            * are permitted provided that the following conditions are met:
     66            *   1. Redistributions of source code must retain the above copyright notice,
     67            *      this list of conditions and the following disclaimer.
     68            *   2. Redistributions in binary form must reproduce the above copyright notice,
     69            *      this list of conditions and the following disclaimer in the documentation
     70            *      and/or other materials provided with the distribution.
     71            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     72            *      may be used to endorse or promote products derived from this software
     73            *      without specific prior written permission.
     74            *
     75            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     76            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     77            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     78            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     79            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     80            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     81            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     82            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     83            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     84            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     85            *
     86            ******************************************************************************
     87            */ 
     88          
     89          /* Includes ------------------------------------------------------------------*/
     90          #include "stm32l0xx_hal.h"
     91          #include "stm32l0xx_hal_msp.h"
     92          
     93          /** @addtogroup STM32L0xx_HAL_Driver
     94            * @{
     95            */
     96          
     97          /** @defgroup DMA 
     98            * @brief DMA HAL module driver
     99            * @{
    100            */
    101          
    102          #ifdef HAL_DMA_MODULE_ENABLED
    103          
    104          /* Private typedef -----------------------------------------------------------*/
    105          /* Private define ------------------------------------------------------------*/
    106          #define HAL_TIMEOUT_DMA_ABORT    ((uint32_t)1000)  /* 1s  */
    107          /* Private macro -------------------------------------------------------------*/
    108          /* Private variables ---------------------------------------------------------*/
    109          /* Private function prototypes -----------------------------------------------*/
    110          static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
    111          
    112          /* Private functions ---------------------------------------------------------*/
    113          
    114          /** @defgroup DMA_Private_Functions
    115            * @{
    116            */
    117          
    118          /** @defgroup DMA_Group1 Initialization/de-initialization functions 
    119           *  @brief   Initialization/de-initialization functions 
    120           *
    121          @verbatim   
    122           ===============================================================================
    123                       ##### Initialization and de-initialization functions  #####
    124           ===============================================================================  
    125              [..]  This section provides functions allowing to:
    126                (+) Initialize and configure the DMA
    127                (+) De-Initialize the DMA 
    128          
    129          @endverbatim
    130            * @{
    131            */
    132            
    133          /**
    134            * @brief  Initializes the DMA according to the specified
    135            *         parameters in the DMA_InitTypeDef and create the associated handle.
    136            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
    137            *               the configuration information for the specified DMA Channel.  
    138            * @retval HAL status
    139            */
    140          HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
    141          { 
    142            uint32_t tmp = 0;
    143            
    144            /* Check the DMA peripheral state */
    145            if(hdma == NULL)
    146            {
    147              return HAL_ERROR;
    148            }
    149          
    150            /* Check the parameters */
    151            assert_param(IS_DMA_ALL_PERIPH(hdma->Instance));
    152            assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));
    153            assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
    154            assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
    155            assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
    156            assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
    157            assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
    158            assert_param(IS_DMA_MODE(hdma->Init.Mode));
    159            assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
    160            
    161            /* Change DMA peripheral state */
    162            hdma->State = HAL_DMA_STATE_BUSY;
    163          
    164            /* Get the CR register value */
    165            tmp = hdma->Instance->CCR;
    166            
    167            /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR bits */
    168            tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
    169                                DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
    170                                DMA_CCR_DIR));
    171            
    172            /* Prepare the DMA Channel configuration */
    173            tmp |=  hdma->Init.Direction        |
    174                    hdma->Init.PeriphInc           | hdma->Init.MemInc           |
    175                    hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    176                    hdma->Init.Mode                | hdma->Init.Priority;
    177          
    178            /* Write to DMA Channel CR register */
    179            hdma->Instance->CCR = tmp;  
    180            
    181            /* Write to DMA channel selection register */
    182            if (hdma->Instance == DMA1_Channel1)
    183            {
    184              /*Reset request selection for DMA1 Channel1*/
    185              DMA1_CSELR->CSELR &= ~DMA_CSELR_C1S;
    186              
    187              /* Configure request selection for DMA1 Channel1 */
    188              DMA1_CSELR->CSELR |= hdma->Init.Request;
    189            }
    190            else if (hdma->Instance == DMA1_Channel2)
    191            {
    192              /*Reset request selection for DMA1 Channel2*/
    193              DMA1_CSELR->CSELR &= ~DMA_CSELR_C2S;
    194              
    195              /* Configure request selection for DMA1 Channel2 */
    196              DMA1_CSELR->CSELR |= (uint32_t)(hdma->Init.Request << 4);
    197            }
    198            else if (hdma->Instance == DMA1_Channel3)
    199            {
    200              /*Reset request selection for DMA1 Channel3*/
    201              DMA1_CSELR->CSELR &= ~DMA_CSELR_C3S;
    202              
    203              /* Configure request selection for DMA1 Channel3 */
    204              DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 8);
    205            }
    206            else if (hdma->Instance == DMA1_Channel4)
    207            {
    208              /*Reset request selection for DMA1 Channel4*/
    209              DMA1_CSELR->CSELR &= ~DMA_CSELR_C4S;
    210              
    211              /* Configure request selection for DMA1 Channel4 */
    212              DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 12);
    213            }
    214            else if (hdma->Instance == DMA1_Channel5)
    215            {
    216              /*Reset request selection for DMA1 Channel5*/
    217              DMA1_CSELR->CSELR &= ~DMA_CSELR_C5S;
    218              
    219              /* Configure request selection for DMA1 Channel5 */
    220              DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 16);
    221            }
    222            else if (hdma->Instance == DMA1_Channel6)
    223            {
    224              /*Reset request selection for DMA1 Channel6*/
    225              DMA1_CSELR->CSELR &= ~DMA_CSELR_C6S;
    226              
    227              /* Configure request selection for DMA1 Channel6 */
    228              DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 20);
    229            }
    230            else if (hdma->Instance == DMA1_Channel7)
    231            {
    232              /*Reset request selection for DMA1 Channel7*/
    233              DMA1_CSELR->CSELR &= ~DMA_CSELR_C7S;
    234              
    235              /* Configure request selection for DMA1 Channel7 */
    236              DMA1_CSELR->CSELR |= (uint32_t) (hdma->Init.Request << 24);
    237            }
    238             
    239            /* Initialize the DMA state*/
    240            hdma->State  = HAL_DMA_STATE_READY;
    241            
    242            return HAL_OK;
    243          }  
    244            
    245          /**
    246            * @brief  DeInitializes the DMA peripheral 
    247            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    248            *               the configuration information for the specified DMA Channel.  
    249            * @retval HAL status
    250            */
    251          HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
    252          {
    253            /* Check the DMA peripheral state */
    254            if(hdma == NULL)
    255            {
    256              return HAL_ERROR;
    257            }
    258            
    259            /* Check the DMA peripheral state */
    260            if(hdma->State == HAL_DMA_STATE_BUSY)
    261            {
    262              return HAL_ERROR;
    263            }
    264          
    265            /* Disable the selected DMA Channelx */
    266            __HAL_DMA_DISABLE(hdma);
    267            
    268            /* Reset DMA Channel control register */
    269            hdma->Instance->CCR  = 0;
    270            
    271            /* Reset DMA Channel Number of Data to Transfer register */
    272            hdma->Instance->CNDTR = 0;
    273            
    274            /* Reset DMA Channel peripheral address register */
    275            hdma->Instance->CPAR  = 0;
    276            
    277            /* Reset DMA Channel memory address register */
    278            hdma->Instance->CMAR = 0;
    279          
    280            /* Clear all flags */
    281            __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
    282            __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
    283            __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
    284            __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
    285            
    286            /* Reset DMA channel selection register */
    287            if (hdma->Instance == DMA1_Channel1)
    288            {
    289              /*Reset DMA request*/
    290              DMA1_CSELR->CSELR &= ~DMA_CSELR_C1S;
    291            }
    292            else if (hdma->Instance == DMA1_Channel2)
    293            {
    294              /*Reset DMA request*/
    295              DMA1_CSELR->CSELR &= ~DMA_CSELR_C2S;
    296            }
    297            else if (hdma->Instance == DMA1_Channel3)
    298            {
    299              /*Reset DMA request*/
    300              DMA1_CSELR->CSELR &= ~DMA_CSELR_C3S;
    301            }
    302            else if (hdma->Instance == DMA1_Channel4)
    303            {
    304              /*Reset DMA request*/
    305              DMA1_CSELR->CSELR &= ~DMA_CSELR_C4S;
    306            }
    307            else if (hdma->Instance == DMA1_Channel5)
    308            {
    309              /*Reset DMA request*/
    310              DMA1_CSELR->CSELR &= ~DMA_CSELR_C5S;
    311            }
    312            else if (hdma->Instance == DMA1_Channel6)
    313            {
    314              /*Reset DMA request*/
    315              DMA1_CSELR->CSELR &= ~DMA_CSELR_C6S;
    316            }
    317            else if (hdma->Instance == DMA1_Channel7)
    318            {
    319              /*Reset DMA request*/
    320              DMA1_CSELR->CSELR &= ~DMA_CSELR_C7S;
    321            }
    322            
    323            /* Initialise the error code */
    324            hdma->ErrorCode = HAL_DMA_ERROR_NONE;
    325          
    326            /* Initialize the DMA state */
    327            hdma->State = HAL_DMA_STATE_RESET;
    328            
    329            /* Release Lock */
    330            __HAL_UNLOCK(hdma);
    331          
    332            return HAL_OK;
    333          }
    334          
    335          /**
    336            * @}
    337            */
    338          
    339          /** @defgroup DMA_Group2 I/O operation functions 
    340           *  @brief   I/O operation functions  
    341           *
    342          @verbatim   
    343           ===============================================================================
    344                                #####  IO operation functions  #####
    345           ===============================================================================  
    346              [..]  This section provides functions allowing to:
    347                (+) Configure the source, destination address and data length and Start DMA transfer
    348                (+) Configure the source, destination address and data length and 
    349                    Start DMA transfer with interrupt
    350                (+) Abort DMA transfer
    351                (+) Poll for transfer complete
    352                (+) Handle DMA interrupt request  
    353          
    354          @endverbatim
    355            * @{
    356            */
    357          
    358          /**
    359            * @brief  Starts the DMA Transfer.
    360            * @param  hdma      : pointer to a DMA_HandleTypeDef structure that contains
    361            *                     the configuration information for the specified DMA Channel.  
    362            * @param  SrcAddress: The source memory Buffer address
    363            * @param  DstAddress: The destination memory Buffer address
    364            * @param  DataLength: The length of data to be transferred from source to destination
    365            * @retval HAL status
    366            */
    367          HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    368          { 
    369            /* Process locked */
    370            __HAL_LOCK(hdma);  
    371          
    372            /* Change DMA peripheral state */  
    373            hdma->State = HAL_DMA_STATE_BUSY;  
    374          
    375             /* Check the parameters */
    376            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    377            
    378            /* Disable the peripheral */
    379            __HAL_DMA_DISABLE(hdma);  
    380            
    381            /* Configure the source, destination address and the data length */
    382            DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
    383          
    384            /* Enable the Peripheral */
    385            __HAL_DMA_ENABLE(hdma);  
    386          
    387            return HAL_OK; 
    388          } 
    389          
    390          /**
    391            * @brief  Start the DMA Transfer with interrupt enabled.
    392            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
    393            *                     the configuration information for the specified DMA Channel.  
    394            * @param  SrcAddress: The source memory Buffer address
    395            * @param  DstAddress: The destination memory Buffer address
    396            * @param  DataLength: The length of data to be transferred from source to destination
    397            * @retval HAL status
    398            */
    399          HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    400          {
    401            /* Process locked */
    402            __HAL_LOCK(hdma);
    403          
    404            /* Change DMA peripheral state */  
    405            hdma->State = HAL_DMA_STATE_BUSY;  
    406          
    407            /* Check the parameters */
    408            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    409          
    410            /* Disable the peripheral */
    411            __HAL_DMA_DISABLE(hdma);
    412          
    413            /* Configure the source, destination address and the data length */  
    414            DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
    415          
    416            /* Enable the transfer complete interrupt */
    417            __HAL_DMA_ENABLE_IT(hdma, DMA_IT_TC);
    418          
    419            /* Enable the Half transfer complete interrupt */
    420            //__HAL_DMA_ENABLE_IT(hdma, DMA_IT_HT);  
    421            
    422            /* Enable the transfer Error interrupt */
    423            __HAL_DMA_ENABLE_IT(hdma, DMA_IT_TE); 
    424          
    425            /* Enable the Peripheral */
    426            __HAL_DMA_ENABLE(hdma);  
    427            return HAL_OK;  
    428          } 
    429          
    430          /**
    431            * @brief  Aborts the DMA Transfer.
    432            * @param  hdma  : pointer to a DMA_HandleTypeDef structure that contains
    433            *                 the configuration information for the specified DMA Channel.
    434            * @param  Timeout: Timeout duration
    435            * @retval HAL status
    436            */
    437          HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
    438          {
    439            uint32_t tickstart = 0;
    440            
    441            /* Disable the channel */
    442            __HAL_DMA_DISABLE(hdma);
    443            
    444            /* Get timeout */
    445            tickstart = HAL_GetTick();
    446            
    447            /* Check if the DMA Channel is effectively disabled */
    448            while((hdma->Instance->CCR & DMA_CCR_EN) != 0) 
    449            {
    450              /* Check for the Timeout */
    451              if( (HAL_GetTick()  - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
    452              {
    453                /* Update error code */
    454                hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
    455                
    456                /* Process Unlocked */
    457                __HAL_UNLOCK(hdma);
    458                
    459                /* Change the DMA state */
    460                hdma->State = HAL_DMA_STATE_TIMEOUT;
    461                
    462                return HAL_TIMEOUT;
    463              }
    464            }
    465            /* Process Unlocked */
    466            __HAL_UNLOCK(hdma);
    467            
    468            /* Change the DMA state*/
    469            hdma->State = HAL_DMA_STATE_READY; 
    470            
    471            return HAL_OK; 
    472          }
    473          
    474          /**
    475            * @brief  Polling for transfer complete.
    476            * @param  hdma:    pointer to a DMA_HandleTypeDef structure that contains
    477            *                  the configuration information for the specified DMA Channel.
    478            * @param  CompleteLevel: Specifies the DMA level complete.  
    479            * @param  Timeout:       Timeout duration.
    480            * @retval HAL status
    481            */
    482          HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, uint32_t CompleteLevel, uint32_t Timeout)
    483          {
    484            uint32_t temp;
    485            uint32_t tickstart = 0;
    486            
    487            /* Get the level transfer complete flag */
    488            if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
    489            {
    490              /* Transfer Complete flag */
    491              temp = __HAL_DMA_GET_TC_FLAG_INDEX(hdma);
    492            }
    493            else
    494            {
    495              /* Half Transfer Complete flag */
    496              temp = __HAL_DMA_GET_HT_FLAG_INDEX(hdma);
    497            }
    498          
    499            /* Get timeout */
    500            tickstart = HAL_GetTick();
    501          
    502            while(__HAL_DMA_GET_FLAG(hdma, temp) == RESET)
    503            {
    504              if((__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET))
    505              {      
    506                /* Clear the transfer error flags */
    507                __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
    508                
    509                /* Update error code */
    510                SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_TE);
    511                
    512                /* Change the DMA state */
    513                hdma->State= HAL_DMA_STATE_ERROR;       
    514                
    515                /* Process Unlocked */
    516                __HAL_UNLOCK(hdma);
    517                
    518                return HAL_ERROR;      
    519              }      
    520              /* Check for the Timeout */
    521              if(Timeout != HAL_MAX_DELAY)
    522              {
    523                if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
    524                {
    525                  /* Update error code */
    526                  SET_BIT(hdma->ErrorCode, HAL_DMA_ERROR_TIMEOUT);
    527                  
    528                  /* Change the DMA state */
    529                  hdma->State= HAL_DMA_STATE_TIMEOUT;
    530                  
    531                  /* Process Unlocked */
    532                  __HAL_UNLOCK(hdma);
    533                
    534                  return HAL_TIMEOUT;
    535                }
    536              }
    537            }
    538          
    539            if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
    540            {
    541              /* Clear the transfer complete flag */
    542              __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
    543          
    544              /* The selected Channelx EN bit is cleared (DMA is disabled and 
    545              all transfers are complete) */
    546              hdma->State = HAL_DMA_STATE_READY;
    547          
    548              /* Process unlocked */
    549              __HAL_UNLOCK(hdma);  
    550            }
    551            else
    552            { 
    553              /* Clear the half transfer complete flag */
    554              __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
    555          
    556              /* The selected Channelx EN bit is cleared (DMA is disabled and 
    557              all transfers are complete) */
    558              hdma->State = HAL_DMA_STATE_READY_HALF;
    559              
    560              /* Process unlocked */
    561              __HAL_UNLOCK(hdma); 
    562            }
    563            
    564            return HAL_OK;
    565          }
    566          /**
    567            * @brief  Handles DMA interrupt request.
    568            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    569            *               the configuration information for the specified DMA Channel.  
    570            * @retval None
    571            */
    572          void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
    573          {        
    574            /* Transfer Error Interrupt management ***************************************/
    575            if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma)) != RESET)
    576            {
    577              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
    578              {
    579                /* Disable the transfer error interrupt */
    580                __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE);
    581              
    582                /* Clear the transfer error flag */
    583                __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TE_FLAG_INDEX(hdma));
    584              
    585                /* Update error code */
    586                hdma->ErrorCode |= HAL_DMA_ERROR_TE;
    587          
    588                /* Change the DMA state */
    589                hdma->State = HAL_DMA_STATE_ERROR;    
    590              
    591                /* Process Unlocked */
    592                __HAL_UNLOCK(hdma); 
    593              
    594                if (hdma->XferErrorCallback != NULL)
    595                {
    596                  /* Transfer error callback */
    597                  hdma->XferErrorCallback(hdma);
    598                }
    599              }
    600            }
    601          
    602            /* Half Transfer Complete Interrupt management ******************************/
    603            if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma)) != RESET)
    604            {
    605              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
    606              { 
    607                /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
    608                if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
    609                {
    610                  /* Disable the half transfer interrupt */
    611                  __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
    612                }
    613                /* Clear the half transfer complete flag */
    614                __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
    615          
    616                /* Change DMA peripheral state */
    617                hdma->State = HAL_DMA_STATE_READY_HALF;
    618          
    619                if(hdma->XferHalfCpltCallback != NULL)
    620                {
    621                  /* Half transfer callback */
    622                  hdma->XferHalfCpltCallback(hdma);
    623                }
    624              }
    625            }
    626            
    627            /* Transfer Complete Interrupt management ***********************************/
    628            if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma)) != RESET)
    629            {
    630              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
    631              {
    632                if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
    633                {
    634                  /* Disable the transfer complete interrupt */
    635                  __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TC);
    636                }
    637                /* Clear the transfer complete flag */
    638                __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
    639              
    640                /* Update error code */
    641                hdma->ErrorCode |= HAL_DMA_ERROR_NONE;
    642          
    643                /* Change the DMA state */
    644                hdma->State = HAL_DMA_STATE_READY;    
    645              
    646                /* Process Unlocked */
    647                __HAL_UNLOCK(hdma);
    648              
    649                if(hdma->XferCpltCallback != NULL)
    650                {       
    651                  /* Transfer complete callback */
    652                  hdma->XferCpltCallback(hdma);
    653                }
    654              }
    655            }  
    656          }  
    657          
    658          /**
    659            * @}
    660            */
    661          
    662          /** @defgroup DMA_Group3 Peripheral State functions
    663           *  @brief    Peripheral State functions 
    664           *
    665          @verbatim   
    666           ===============================================================================
    667                                  ##### Peripheral State functions #####
    668           ===============================================================================  
    669              [..]
    670              This subsection provides functions allowing to
    671                (+) Check the DMA state
    672                (+) Get error code
    673          
    674          @endverbatim
    675            * @{
    676            */  
    677          
    678          /**
    679            * @brief  Returns the DMA state.
    680            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
    681            *               the configuration information for the specified DMA Channel.  
    682            * @retval HAL state
    683            */
    684          HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
    685          {
    686            return hdma->State;
    687          }
    688          
    689          /**
    690            * @brief  Return the DMA error code
    691            * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
    692            *              the configuration information for the specified DMA Channel.
    693            * @retval DMA Error Code
    694            */
    695          uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
    696          {
    697            return hdma->ErrorCode;
    698          }
    699          
    700          /**
    701            * @}
    702            */
    703          
    704          /**
    705            * @brief  Sets the DMA Transfer parameter.
    706            * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
    707            *                     the configuration information for the specified DMA Channel.  
    708            * @param  SrcAddress: The source memory Buffer address
    709            * @param  DstAddress: The destination memory Buffer address
    710            * @param  DataLength: The length of data to be transferred from source to destination
    711            * @retval HAL status
    712            */
    713          static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    714          {  
    715            /* Configure DMA Channel data length */
    716            hdma->Instance->CNDTR = DataLength;
    717            
    718            /* Peripheral to Memory */
    719            if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
    720            {   
    721              /* Configure DMA Channel destination address */
    722              hdma->Instance->CPAR = DstAddress;
    723              
    724              /* Configure DMA Channel source address */
    725              hdma->Instance->CMAR = SrcAddress;
    726            }
    727            /* Memory to Peripheral */
    728            else
    729            {
    730              /* Configure DMA Channel source address */
    731              hdma->Instance->CPAR = SrcAddress;
    732              
    733              /* Configure DMA Channel destination address */
    734              hdma->Instance->CMAR = DstAddress;
    735            }
    736          }
    737          
    738          /**
    739            * @}
    740            */
    741          
    742          #endif /* HAL_DMA_MODULE_ENABLED */
    743          /**
    744            * @}
    745            */
    746          
    747          /**
    748            * @}
    749            */
    750          
    751          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DMA_SetConfig
      16   HAL_DMA_Abort
        16   -> HAL_GetTick
      20   HAL_DMA_DeInit
       0   HAL_DMA_GetError
       0   HAL_DMA_GetState
      32   HAL_DMA_IRQHandler
        32   -- Indirect call
       0   HAL_DMA_Init
      40   HAL_DMA_PollForTransfer
        40   -> HAL_GetTick
      16   HAL_DMA_Start
        16   -> DMA_SetConfig
      24   HAL_DMA_Start_IT
        24   -> DMA_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
      24  DMA_SetConfig
      74  HAL_DMA_Abort
     430  HAL_DMA_DeInit
       4  HAL_DMA_GetError
       6  HAL_DMA_GetState
     656  HAL_DMA_IRQHandler
     220  HAL_DMA_Init
     514  HAL_DMA_PollForTransfer
      54  HAL_DMA_Start
      74  HAL_DMA_Start_IT

 
 2 144 bytes in section .text
 
 2 144 bytes of CODE memory

Errors: none
Warnings: none

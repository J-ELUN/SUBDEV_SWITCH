###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        13/Jul/2017  14:23:23
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\demo\SUBDEV_SWITCH\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_uart.c
#    Command line =  
#        F:\demo\SUBDEV_SWITCH\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_uart.c
#        -D STM32L053xx -D USE_HAL_DRIVER -lc
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\List\ -o
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\Obj\ --debug
#        --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\..\Drivers\STM32L0xx_HAL_Driver\Inc\
#        -I F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\Inc\ -I
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\..\Drivers\CMSIS\Device\ST\STM32L0xx\Include\
#        -I F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\..\Drivers\CMSIS\Include\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\List\stm32l0xx_hal_uart.lst
#    Object file  =  
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\Obj\stm32l0xx_hal_uart.o
#
###############################################################################

F:\demo\SUBDEV_SWITCH\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_uart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l0xx_hal_uart.c
      4            * @author  MCD Application Team
      5            * @version V1.1.0
      6            * @date    18-June-2014
      7            * @brief   UART HAL module driver.
      8            *
      9            *          This file provides firmware functions to manage the following 
     10            *          functionalities of the Universal Asynchronous Receiver Transmitter Peripheral (UART).
     11            *           + Initialization and de-initialization methods
     12            *           + IO operation methods
     13            *           + Peripheral Control methods
     14            *
     15            @verbatim
     16           ===============================================================================
     17                                  ##### How to use this driver #####
     18           ===============================================================================
     19            [..]
     20              The UART HAL driver can be used as follows:
     21              
     22              (#) Declare a UART_HandleTypeDef handle structure.
     23            
     24              (#) Initialize the UART low level resources by implementing the HAL_UART_MspInit() API:
     25                  (##) Enable the USARTx interface clock.
     26                  (##) UART pins configuration:
     27                      (+++) Enable the clock for the UART GPIOs.
     28                      (+++) Configure these UART pins as alternate function pull-up.
     29                  (##) NVIC configuration if you need to use interrupt process (HAL_UART_Transmit_IT()
     30                       and HAL_UART_Receive_IT() APIs):
     31                      (+++) Configure the USARTx interrupt priority.
     32                      (+++) Enable the NVIC USART IRQ handle.
     33          
     34                  (##) DMA Configuration if you need to use DMA process (HAL_UART_Transmit_DMA()
     35                       and HAL_UART_Receive_DMA() APIs):
     36                      (+++) Declare a DMA handle structure for the Tx/Rx stream.
     37                      (+++) Enable the DMAx interface clock.
     38                      (+++) Configure the declared DMA handle structure with the required 
     39                            Tx/Rx parameters.                
     40                      (+++) Configure the DMA Tx/Rx Stream.
     41                      (+++) Associate the initialized DMA handle to the UART DMA Tx/Rx handle.
     42                      (+++) Configure the priority and enable the NVIC for the transfer complete 
     43                            interrupt on the DMA Tx/Rx Stream.
     44          
     45              (#) Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware 
     46                  flow control and Mode(Receiver/Transmitter) in the Init structure.
     47          
     48              (#) For the UART asynchronous mode, initialize the UART registers by calling
     49                  the HAL_UART_Init() API.
     50          
     51              (#) For the UART Half duplex mode, initialize the UART registers by calling 
     52                  the HAL_HalfDuplex_Init() API.
     53          
     54              (#) For the LIN mode, initialize the UART registers by calling the HAL_LIN_Init() API.
     55          
     56              (#) For the Multi-Processor mode, initialize the UART registers by calling 
     57                  the HAL_MultiProcessor_Init() API.
     58          
     59               [..] 
     60                 (@) The specific UART interrupts (Transmission complete interrupt, 
     61                      RXNE interrupt and Error Interrupts) will be managed using the macros
     62                      __HAL_UART_ENABLE_IT() and __HAL_UART_DISABLE_IT() inside the transmit 
     63                      and receive process.
     64          
     65               [..] 
     66                 (@) These APIs (HAL_UART_Init() and HAL_HalfDuplex_Init()) configure also the 
     67                      low level Hardware GPIO, CLOCK, CORTEX...etc) by calling the customed 
     68                      HAL_UART_MspInit() API.
     69          
     70               [..] 
     71                  Three operation modes are available within this driver :
     72          
     73               *** Polling mode IO operation ***
     74               =================================
     75               [..]    
     76                 (+) Send an amount of data in blocking mode using HAL_UART_Transmit() 
     77                 (+) Receive an amount of data in blocking mode using HAL_UART_Receive()
     78                 
     79               *** Interrupt mode IO operation ***
     80               ===================================
     81               [..]
     82                 (+) Send an amount of data in non blocking mode using HAL_UART_Transmit_IT() 
     83                 (+) At transmission end of half transfer HAL_UART_TxHalfCpltCallback is executed and user can 
     84                      add his own code by customization of function pointer HAL_UART_TxHalfCpltCallback 
     85                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     86                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     87                 (+) Receive an amount of data in non blocking mode using HAL_UART_Receive_IT() 
     88                 (+) At reception end of half transfer HAL_UART_RxHalfCpltCallback is executed and user can 
     89                      add his own code by customization of function pointer HAL_UART_RxHalfCpltCallback 
     90                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
     91                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
     92                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
     93                      add his own code by customization of function pointer HAL_UART_ErrorCallback
     94          
     95               *** DMA mode IO operation ***
     96               ==============================
     97               [..] 
     98                 (+) Send an amount of data in non blocking mode (DMA) using HAL_UART_Transmit_DMA() 
     99                 (+) At transmission end of half transfer HAL_UART_TxHalfCpltCallback is executed and user can 
    100                      add his own code by customization of function pointer HAL_UART_TxHalfCpltCallback 
    101                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
    102                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
    103                 (+) Receive an amount of data in non blocking mode (DMA) using HAL_UART_Receive_DMA() 
    104                 (+) At reception end of half transfer HAL_UART_RxHalfCpltCallback is executed and user can 
    105                      add his own code by customization of function pointer HAL_UART_RxHalfCpltCallback 
    106                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
    107                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
    108                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
    109                      add his own code by customization of function pointer HAL_UART_ErrorCallback
    110                 (+) Pause the DMA Transfer using HAL_UART_DMAPause()
    111                 (+) Resume the DMA Transfer using HAL_UART_DMAResume()
    112                 (+) Stop the DMA Transfer using HAL_UART_DMAStop()
    113          
    114               *** UART HAL driver macros list ***
    115               =============================================
    116               [..]
    117                 Below the list of most used macros in UART HAL driver.
    118          
    119                (+) __HAL_UART_ENABLE: Enable the UART peripheral 
    120                (+) __HAL_UART_DISABLE: Disable the UART peripheral
    121                (+) __HAL_UART_GET_FLAG : Check whether the specified UART flag is set or not
    122                (+) __HAL_UART_CLEAR_FLAG : Clear the specified UART pending flag
    123                (+) __HAL_UART_ENABLE_IT: Enable the specified UART interrupt
    124                (+) __HAL_UART_DISABLE_IT: Disable the specified UART interrupt
    125          
    126               [..]
    127                 (@) You can refer to the UART HAL driver header file for more useful macros 
    128            @endverbatim
    129            ******************************************************************************
    130            * @attention
    131            *
    132            * <h2><center>&copy; COPYRIGHT(c) 2014 STMicroelectronics</center></h2>
    133            *
    134            * Redistribution and use in source and binary forms, with or without modification,
    135            * are permitted provided that the following conditions are met:
    136            *   1. Redistributions of source code must retain the above copyright notice,
    137            *      this list of conditions and the following disclaimer.
    138            *   2. Redistributions in binary form must reproduce the above copyright notice,
    139            *      this list of conditions and the following disclaimer in the documentation
    140            *      and/or other materials provided with the distribution.
    141            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    142            *      may be used to endorse or promote products derived from this software
    143            *      without specific prior written permission.
    144            *
    145            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    146            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    147            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    148            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    149            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    150            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    151            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    152            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    153            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    154            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    155            *
    156            ******************************************************************************  
    157            */
    158          
    159          /* Includes ------------------------------------------------------------------*/
    160          #include "main.h"    
    161          
    162          /** @addtogroup STM32L0xx_HAL_Driver
    163            * @{
    164            */
    165          
    166          /** @defgroup UART 
    167            * @brief UART module driver
    168            * @{
    169            */
    170          #ifdef HAL_UART_MODULE_ENABLED
    171              
    172          /* Private typedef -----------------------------------------------------------*/
    173          /* Private define ------------------------------------------------------------*/
    174          #define UART_TIMEOUT_VALUE       ((uint32_t) 22000)
    175          #define UART_CR1_FIELDS  ((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | \
    176                                               USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8))
    177          /* Private macro -------------------------------------------------------------*/
    178          /* Private variables ---------------------------------------------------------*/
    179          /* Private function prototypes -----------------------------------------------*/
    180          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    181          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    182          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    183          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    184          static void UART_DMAError(DMA_HandleTypeDef *hdma); 
    185          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart);
    186          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart);
    187          
    188          
    189          /* Private functions ---------------------------------------------------------*/
    190          
    191          /** @defgroup UART_Private_Functions
    192            * @{
    193            */
    194          
    195          /** @defgroup UART_Group1 Initialization/de-initialization methods 
    196            *  @brief    Initialization and Configuration functions 
    197            *
    198          @verbatim    
    199          ===============================================================================
    200                      ##### Initialization and Configuration functions #####
    201           ===============================================================================
    202              [..]
    203              This subsection provides a set of functions allowing to initialize the USARTx or the UARTy 
    204              in asynchronous mode.
    205                (+) For the asynchronous mode only these parameters can be configured: 
    206                  (++) Baud Rate
    207                  (++) Word Length 
    208                  (++) Stop Bit
    209                  (++) Parity: If the parity is enabled, then the MSB bit of the data written
    210                       in the data register is transmitted but is changed by the parity bit.
    211                       Depending on the frame length defined by the M bit (8-bits or 9-bits),
    212                       the possible UART frame formats are as listed in the following table:
    213             +-----------------------------------------------------------------------+
    214             |  M1 bit |  M0 bit |  PCE bit  |            USART frame                |
    215             |---------|---------|-----------|---------------------------------------|
    216             |    0    |    0    |    0      |    | SB |    8 bit data   | STB |     |
    217             |---------|---------|-----------|---------------------------------------|
    218             |    0    |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    219             |---------|---------|-----------|---------------------------------------|
    220             |    0    |    1    |    0      |    | SB |    9 bit data   | STB |     |
    221             |---------|---------|-----------|---------------------------------------|
    222             |    0    |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    223             |---------|---------|-----------|---------------------------------------|
    224             |    1    |    0    |    0      |    | SB |    7 bit data   | STB |     |
    225             |---------|---------|-----------|---------------------------------------|
    226             |    1    |    0    |    1      |    | SB | 6 bit data | PB | STB |     |
    227             +-----------------------------------------------------------------------+
    228                  (++) Hardware flow control
    229                  (++) Receiver/transmitter modes
    230                  (++) Over Sampling Method
    231                  (++) One-Bit Sampling Method
    232                (+) For the asynchronous mode, the following advanced features can be configured as well:
    233                  (++) TX and/or RX pin level inversion
    234                  (++) data logical level inversion
    235                  (++) RX and TX pins swap
    236                  (++) RX overrun detection disabling
    237                  (++) DMA disabling on RX error
    238                  (++) MSB first on communication line
    239                  (++) auto Baud rate detection
    240              [..]
    241              The HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init()and HAL_MultiProcessorEx_Init()API 
    242              follow respectively the UART asynchronous, UART Half duplex, UART LIN mode
    243              and UART multiprocessor mode mode configuration procedures (details for the procedures
    244              are available in reference manual).
    245          
    246          @endverbatim
    247            * @{
    248            */
    249          
    250          /**
    251            * @brief Initializes the UART mode according to the specified
    252            *         parameters in the UART_InitTypeDef and creates the associated handle .
    253            * @param huart: uart handle
    254            * @retval HAL status
    255            */
    256          HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
    257          {
    258            /* Check the UART handle allocation */
    259            if(huart == NULL)
    260            {
    261              return HAL_ERROR;
    262            }
    263            
    264            if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
    265            {
    266              /* Check the parameters */
    267              assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
    268            }
    269            else
    270            {
    271              /* Check the parameters */
    272              assert_param(IS_UART_INSTANCE(huart->Instance));
    273            }
    274            
    275            if(huart->State == HAL_UART_STATE_RESET)
    276            {  
    277              /* Init the low level hardware : GPIO, CLOCK, CORTEX */
    278              HAL_UART_MspInit(huart);
    279            }
    280            
    281            huart->State = HAL_UART_STATE_BUSY;  
    282          
    283            /* Disable the Peripheral */
    284            __HAL_UART_DISABLE(huart);
    285            
    286            /* Set the UART Communication parameters */
    287            UART_SetConfig(huart);
    288            
    289            if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
    290            {
    291              UART_AdvFeatureConfig(huart);
    292            }
    293            
    294            /* In asynchronous mode, the following bits must be kept cleared: 
    295            - LINEN and CLKEN bits in the USART_CR2 register,
    296            - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
    297            huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN); 
    298            huart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN); 
    299              
    300            /* Enable the Peripheral */
    301            __HAL_UART_ENABLE(huart);
    302            
    303            /* TEACK and/or REACK to check before moving huart->State to Ready */
    304            return (UART_CheckIdleState(huart));
    305          }
    306          
    307          /**
    308            * @brief Initializes the half-duplex mode according to the specified
    309            *         parameters in the UART_InitTypeDef and creates the associated handle .
    310            * @param huart: uart handle
    311            * @retval HAL status
    312            */
    313          HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
    314          {
    315            /* Check the UART handle allocation */
    316            if(huart == NULL)
    317            {
    318              return HAL_ERROR;
    319            }
    320            
    321            if(huart->State == HAL_UART_STATE_RESET)
    322            {   
    323              /* Init the low level hardware : GPIO, CLOCK, CORTEX */
    324              HAL_UART_MspInit(huart);
    325            }
    326            
    327            /* Disable the Peripheral */
    328            __HAL_UART_DISABLE(huart);
    329            
    330            /* Set the UART Communication parameters */
    331            UART_SetConfig(huart);
    332            
    333            if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
    334            {
    335              UART_AdvFeatureConfig(huart);
    336            }
    337            
    338            /* In half-duplex mode, the following bits must be kept cleared: 
    339            - LINEN and CLKEN bits in the USART_CR2 register,
    340            - SCEN and IREN bits in the USART_CR3 register.*/
    341            huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
    342            huart->Instance->CR3 &= ~(USART_CR3_IREN | USART_CR3_SCEN);
    343            
    344            /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    345            huart->Instance->CR3 |= USART_CR3_HDSEL;
    346            
    347            /* Enable the Peripheral */
    348            __HAL_UART_ENABLE(huart);
    349            
    350            /* TEACK and/or REACK to check before moving huart->State to Ready */
    351            return (UART_CheckIdleState(huart));
    352          }
    353          
    354          /**
    355            * @brief Initializes the LIN mode according to the specified
    356            *         parameters in the UART_InitTypeDef and creates the associated handle .
    357            * @param huart: uart handle
    358            * @param BreakDetectLength: specifies the LIN break detection length.
    359            *        This parameter can be one of the following values:
    360            *          @arg UART_LINBREAKDETECTLENGTH_10B: 10-bit break detection
    361            *          @arg UART_LINBREAKDETECTLENGTH_11B: 11-bit break detection
    362            * @retval HAL status
    363            */
    364          HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
    365          {
    366            /* Check the UART handle allocation */
    367            if(huart == NULL)
    368            {
    369              return HAL_ERROR;
    370            }
    371            /* Check the Break detection length parameter */
    372            assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
    373            
    374            /* LIN mode limited to 16-bit oversampling only */
    375            if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
    376            {
    377              return HAL_ERROR;
    378            }
    379            
    380            if(huart->State == HAL_UART_STATE_RESET)
    381            {   
    382              /* Init the low level hardware : GPIO, CLOCK, CORTEX */
    383              HAL_UART_MspInit(huart);
    384            }
    385            
    386            /* Disable the Peripheral */
    387            __HAL_UART_DISABLE(huart);
    388            
    389            /* Set the UART Communication parameters */
    390            UART_SetConfig(huart);
    391            
    392            if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
    393            {
    394              UART_AdvFeatureConfig(huart);
    395            }
    396            
    397            /* In LIN mode, the following bits must be kept cleared: 
    398            - LINEN and CLKEN bits in the USART_CR2 register,
    399            - SCEN and IREN bits in the USART_CR3 register.*/
    400            huart->Instance->CR2 &= ~(USART_CR2_CLKEN);
    401            huart->Instance->CR3 &= ~(USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN);
    402            
    403            /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    404            huart->Instance->CR2 |= USART_CR2_LINEN;
    405            
    406            /* Set the USART LIN Break detection length. */
    407            MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
    408            
    409              /* Enable the Peripheral */
    410            __HAL_UART_ENABLE(huart);
    411            
    412            /* TEACK and/or REACK to check before moving huart->State to Ready */
    413            return (UART_CheckIdleState(huart));
    414          }
    415          
    416          /**
    417            * @brief Initializes the multiprocessor mode according to the specified
    418            *         parameters in the UART_InitTypeDef and creates the associated handle.
    419            * @param huart: UART handle   
    420            * @param Address: UART node address (4-, 6-, 7- or 8-bit long)
    421            * @param WakeUpMethod: specifies the UART wakeup method.
    422            *        This parameter can be one of the following values:
    423            *          @arg UART_WAKEUPMETHOD_IDLELINE: WakeUp by an idle line detection
    424            *          @arg UART_WAKEUPMETHOD_ADDRESSMARK: WakeUp by an address mark
    425            * @note  If the user resorts to idle line detection wake up, the Address parameter
    426            *        is useless and ignored by the initialization function.               
    427            * @note  If the user resorts to address mark wake up, the address length detection 
    428            *        is configured by default to 4 bits only. For the UART to be able to 
    429            *        manage 6-, 7- or 8-bit long addresses detection, the API
    430            *        HAL_MultiProcessorEx_AddressLength_Set() must be called after 
    431            *        HAL_MultiProcessor_Init().                      
    432            * @retval HAL status
    433            */
    434          HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
    435          {
    436            /* Check the UART handle allocation */
    437            if(huart == NULL)
    438            {
    439              return HAL_ERROR;
    440            }
    441          
    442            /* Check the wake up method parameter */
    443            assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
    444            
    445            if(huart->State == HAL_UART_STATE_RESET)
    446            {   
    447              /* Init the low level hardware : GPIO, CLOCK */
    448              HAL_UART_MspInit(huart);
    449            }
    450            
    451            huart->State = HAL_UART_STATE_BUSY;
    452            
    453            /* Disable the Peripheral */
    454            __HAL_UART_DISABLE(huart);
    455            
    456            /* Set the UART Communication parameters */
    457            UART_SetConfig(huart);
    458            
    459            if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
    460            {
    461              UART_AdvFeatureConfig(huart);
    462            }
    463            
    464            /* In multiprocessor mode, the following bits must be kept cleared: 
    465            - LINEN and CLKEN bits in the USART_CR2 register,
    466            - SCEN, HDSEL and IREN  bits in the USART_CR3 register. */
    467            huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
    468            huart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
    469            
    470            if (WakeUpMethod == UART_WAKEUPMETHOD_ADDRESSMARK)
    471            {
    472              /* If address mark wake up method is chosen, set the USART address node */
    473              MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)Address << UART_CR2_ADDRESS_LSB_POS));
    474            }
    475            
    476            /* Set the wake up method by setting the WAKE bit in the CR1 register */
    477            MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
    478            
    479            /* Enable the Peripheral */
    480            __HAL_UART_ENABLE(huart); 
    481            
    482            /* TEACK and/or REACK to check before moving huart->State to Ready */
    483            return (UART_CheckIdleState(huart));
    484          }
    485          
    486          /**
    487            * @brief DeInitializes the UART peripheral 
    488            * @param huart: uart handle
    489            * @retval HAL status
    490            */
    491          HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
    492          {
    493            /* Check the UART handle allocation */
    494            if(huart == NULL)
    495            {
    496              return HAL_ERROR;
    497            }
    498            
    499            /* Check the parameters */
    500            assert_param(IS_UART_INSTANCE(huart->Instance));
    501          
    502            huart->State = HAL_UART_STATE_BUSY;
    503            
    504            /* Disable the Peripheral */
    505            __HAL_UART_DISABLE(huart);
    506            
    507            huart->Instance->CR1 = 0x0;
    508            huart->Instance->CR2 = 0x0;
    509            huart->Instance->CR3 = 0x0;
    510            
    511            /* DeInit the low level hardware */
    512            HAL_UART_MspDeInit(huart);
    513          
    514            huart->ErrorCode = HAL_UART_ERROR_NONE;
    515            huart->State = HAL_UART_STATE_RESET;
    516            
    517            /* Release Lock */
    518            __HAL_UNLOCK(huart);
    519            
    520            return HAL_OK;
    521          }
    522          
    523          ///**
    524          //  * @brief UART MSP Init
    525          //  * @param huart: uart handle
    526          //  * @retval None
    527          //  */
    528          // __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
    529          //{
    530          //  /* NOTE : This function should not be modified, when the callback is needed,
    531          //            the HAL_UART_MspInit can be implemented in the user file
    532          //   */ 
    533          //}
    534          
    535          
    536          /**
    537            * @brief UART MSP DeInit
    538            * @param huart: uart handle
    539            * @retval None
    540            */
    541           __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
    542          {
    543            /* NOTE : This function should not be modified, when the callback is needed,
    544                      the HAL_UART_MspDeInit can be implemented in the user file
    545             */ 
    546          }
    547          
    548          /**
    549            * @}
    550            */
    551          
    552          /** @defgroup UART_Group2 IO operation functions 
    553            *  @brief UART Transmit/Receive functions 
    554            *
    555          @verbatim   
    556           ===============================================================================
    557                                ##### IO operation functions #####
    558           ===============================================================================
    559              This subsection provides a set of functions allowing to manage the UART asynchronous
    560              and Half duplex data transfers.
    561          
    562              (#) There are two mode of transfer:
    563                 (+) Blocking mode: The communication is performed in polling mode. 
    564                      The HAL status of all data processing is returned by the same function 
    565                      after finishing transfer.  
    566                 (+) No-Blocking mode: The communication is performed using Interrupts 
    567                     or DMA, These API's return the HAL status.
    568                     The end of the data processing will be indicated through the 
    569                     dedicated UART IRQ when using Interrupt mode or the DMA IRQ when 
    570                     using DMA mode.
    571                     The HAL_UART_TxCpltCallback(), HAL_UART_RxCpltCallback() user callbacks 
    572                     will be executed respectivelly at the end of the transmit or Receive process
    573                     The HAL_UART_ErrorCallback()user callback will be executed when a communication error is detected
    574          
    575              (#) Blocking mode API's are :
    576                  (+) HAL_UART_Transmit()
    577                  (+) HAL_UART_Receive() 
    578                  
    579              (#) Non-Blocking mode API's with Interrupt are :
    580                  (+) HAL_UART_Transmit_IT()
    581                  (+) HAL_UART_Receive_IT()
    582                  (+) HAL_UART_IRQHandler()
    583                  (+) UART_Transmit_IT()
    584                  (+) UART_Receive_IT()
    585          
    586              (#) No-Blocking mode API's with DMA are :
    587                  (+) HAL_UART_Transmit_DMA()
    588                  (+) HAL_UART_Receive_DMA()
    589                  (+) HAL_UART_DMAPause()
    590                  (+) HAL_UART_DMAResume()
    591                  (+) HAL_UART_DMAStop()
    592          
    593              (#) A set of Transfer Complete Callbacks are provided in No_Blocking mode:
    594                  (+) HAL_UART_TxHalfCpltCallback()
    595                  (+) HAL_UART_TxCpltCallback()
    596                  (+) HAL_UART_RxHalfCpltCallback()
    597                  (+) HAL_UART_RxCpltCallback()
    598                  (+) HAL_UART_ErrorCallback()
    599          
    600              -@- In the Half duplex communication, it is forbidden to run the transmit 
    601                  and receive process in parallel, the UART state HAL_UART_STATE_BUSY_TX_RX can't be useful.
    602          
    603          @endverbatim
    604            * @{
    605            */
    606          
    607          /**
    608            * @brief Send an amount of data in blocking mode 
    609            * @param huart: uart handle
    610            * @param pData: pointer to data buffer
    611            * @param Size: amount of data to be sent
    612            * @param Timeout : Timeout duration
    613            * @retval HAL status
    614            */
    615          HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    616          {
    617             uint16_t* tmp;
    618          
    619            if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
    620            {
    621              if((pData == NULL ) || (Size == 0))
    622              {
    623                return  HAL_ERROR;
    624              }
    625          
    626              /* Process Locked */
    627              __HAL_LOCK(huart);
    628          
    629              huart->ErrorCode = HAL_UART_ERROR_NONE;
    630              /* Check if a non-blocking receive process is ongoing or not */
    631              if(huart->State == HAL_UART_STATE_BUSY_RX) 
    632              {
    633                huart->State = HAL_UART_STATE_BUSY_TX_RX;
    634              }
    635              else
    636              {
    637                huart->State = HAL_UART_STATE_BUSY_TX;
    638              }
    639          
    640              huart->TxXferSize = Size;
    641              huart->TxXferCount = Size;
    642              while(huart->TxXferCount > 0)
    643              {
    644                huart->TxXferCount--;
    645                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)  
    646                  { 
    647                    return HAL_TIMEOUT;
    648                  }
    649                if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
    650                {
    651                  tmp = (uint16_t*) pData;
    652                  huart->Instance->TDR = (*tmp & (uint16_t)0x01FF);
    653                  pData += 2;
    654                }
    655                else
    656                {
    657                  huart->Instance->TDR = (*pData++ & (uint8_t)0xFF);
    658                }
    659              }
    660              if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, Timeout) != HAL_OK)  
    661              { 
    662                return HAL_TIMEOUT;
    663              }
    664              /* Check if a non-blocking receive Process is ongoing or not */
    665              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
    666              {
    667                huart->State = HAL_UART_STATE_BUSY_RX;
    668              }
    669              else
    670              {
    671                huart->State = HAL_UART_STATE_READY;
    672              }
    673          
    674              /* Process Unlocked */
    675              __HAL_UNLOCK(huart);
    676          
    677              return HAL_OK;
    678            }
    679            else
    680            {
    681              return HAL_BUSY;
    682            }
    683          }
    684          
    685          /**
    686            * @brief Receive an amount of data in blocking mode 
    687            * @param huart: uart handle
    688            * @param pData: pointer to data buffer
    689            * @param Size: amount of data to be received
    690            * @param Timeout : Timeout duration
    691            * @retval HAL status
    692            */
    693          HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    694          {
    695            uint16_t* tmp;
    696            uint16_t uhMask;
    697          
    698            if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
    699            {
    700              if((pData == NULL ) || (Size == 0))
    701              {
    702                return  HAL_ERROR;
    703              }
    704          
    705              /* Process Locked */
    706              __HAL_LOCK(huart);
    707          
    708              huart->ErrorCode = HAL_UART_ERROR_NONE;
    709              /* Check if a non-blocking transmit process is ongoing or not */
    710              if(huart->State == HAL_UART_STATE_BUSY_TX)
    711              {
    712                huart->State = HAL_UART_STATE_BUSY_TX_RX;
    713              }
    714              else
    715              {
    716                huart->State = HAL_UART_STATE_BUSY_RX;
    717              }
    718          
    719              huart->RxXferSize = Size; 
    720              huart->RxXferCount = Size;
    721          
    722              /* Computation of UART mask to apply to RDR register */
    723              __HAL_UART_MASK_COMPUTATION(huart);
    724              uhMask = huart->Mask;
    725          
    726              /* as long as data have to be received */
    727              while(huart->RxXferCount > 0)
    728              {
    729                huart->RxXferCount--;
    730                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)  
    731                  {
    732                    return HAL_TIMEOUT;
    733                  }
    734                if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
    735                {
    736                  tmp = (uint16_t*) pData ;
    737                  *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
    738                  pData +=2; 
    739                }
    740                else
    741                {
    742                  *pData++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask); 
    743                }
    744              }
    745          
    746              /* Check if a non-blocking transmit Process is ongoing or not */
    747              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
    748              {
    749                huart->State = HAL_UART_STATE_BUSY_TX;
    750              }
    751              else
    752              {
    753                huart->State = HAL_UART_STATE_READY;
    754              }
    755              /* Process Unlocked */
    756              __HAL_UNLOCK(huart);
    757          
    758              return HAL_OK;
    759            }
    760            else
    761            {
    762              return HAL_BUSY;
    763            }
    764          }
    765          
    766          /**
    767            * @brief Send an amount of data in interrupt mode 
    768            * @param huart: uart handle
    769            * @param pData: pointer to data buffer
    770            * @param Size: amount of data to be sent
    771            * @retval HAL status
    772            */
    773          HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    774          {  
    775            if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
    776            {
    777              if((pData == NULL ) || (Size == 0)) 
    778              {
    779                return HAL_ERROR;
    780              }
    781              
    782              /* Process Locked */
    783              __HAL_LOCK(huart);
    784              
    785              huart->pTxBuffPtr = pData;
    786              huart->TxXferSize = Size;
    787              huart->TxXferCount = Size;
    788              
    789              huart->ErrorCode = HAL_UART_ERROR_NONE;
    790              /* Check if a receive process is ongoing or not */
    791              if(huart->State == HAL_UART_STATE_BUSY_RX) 
    792              {
    793                huart->State = HAL_UART_STATE_BUSY_TX_RX;
    794              }
    795              else
    796              {
    797                huart->State = HAL_UART_STATE_BUSY_TX;
    798              }
    799              
    800          //    /* Enable the UART Parity Error Interrupt */
    801          //    __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
    802          //    
    803          //    /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    804          //    __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
    805              
    806              /* Process Unlocked */
    807              __HAL_UNLOCK(huart);    
    808          
    809              /* Enable the UART Transmit data register empty Interrupt */
    810              __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
    811              
    812              return HAL_OK;
    813            }
    814            else
    815            {
    816              return HAL_BUSY;   
    817            }
    818          }
    819          
    820          /**
    821            * @brief Receive an amount of data in interrupt mode 
    822            * @param huart: uart handle
    823            * @param pData: pointer to data buffer
    824            * @param Size: amount of data to be received
    825            * @retval HAL status
    826            */
    827          HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    828          {
    829            if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
    830            {
    831              if((pData == NULL ) || (Size == 0)) 
    832              {
    833                return HAL_ERROR;
    834              }
    835          
    836              /* Process Locked */
    837              __HAL_LOCK(huart);
    838          
    839              huart->pRxBuffPtr = pData;
    840              huart->RxXferSize = Size;
    841              huart->RxXferCount = Size;
    842          
    843              /* Computation of UART mask to apply to RDR register */
    844              __HAL_UART_MASK_COMPUTATION(huart);
    845          
    846              huart->ErrorCode = HAL_UART_ERROR_NONE;
    847              /* Check if a transmit process is ongoing or not */
    848              if(huart->State == HAL_UART_STATE_BUSY_TX) 
    849              {
    850                huart->State = HAL_UART_STATE_BUSY_TX_RX;
    851              }
    852              else
    853              {
    854                huart->State = HAL_UART_STATE_BUSY_RX;
    855              }
    856          
    857          //    /* Enable the UART Parity Error Interrupt */
    858          //    __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
    859          //
    860          //    /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    861          //    __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
    862          
    863              /* Process Unlocked */
    864              __HAL_UNLOCK(huart);
    865          
    866              /* Enable the UART Data Register not empty Interrupt */
    867              __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
    868          
    869              return HAL_OK;
    870            }
    871            else
    872            {
    873              return HAL_BUSY; 
    874            }
    875          }
    876          
    877          /**
    878            * @brief Send an amount of data in DMA mode 
    879            * @param huart: uart handle
    880            * @param pData: pointer to data buffer
    881            * @param Size: amount of data to be sent
    882            * @retval HAL status
    883            */
    884          HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    885          {
    886            uint32_t *tmp;
    887            
    888            if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_RX))
    889            {
    890              if((pData == NULL ) || (Size == 0)) 
    891              {
    892                return HAL_ERROR;
    893              }
    894              
    895              /* Process Locked */
    896              __HAL_LOCK(huart);
    897              
    898              huart->pTxBuffPtr = pData;
    899              huart->TxXferSize = Size;
    900              huart->TxXferCount = Size; 
    901              
    902              huart->ErrorCode = HAL_UART_ERROR_NONE;
    903              /* Check if a receive process is ongoing or not */
    904              if(huart->State == HAL_UART_STATE_BUSY_RX) 
    905              {
    906                huart->State = HAL_UART_STATE_BUSY_TX_RX;
    907              }
    908              else
    909              {
    910                huart->State = HAL_UART_STATE_BUSY_TX;
    911              }
    912              
    913              /* Set the UART DMA transfert complete callback */
    914              huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
    915              
    916          //    /* Set the UART DMA Half transfer complete callback */
    917          //    huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
    918              
    919              /* Set the DMA error callback */
    920              huart->hdmatx->XferErrorCallback = UART_DMAError;
    921          
    922              /* Enable the UART transmit DMA Stream */
    923              tmp = (uint32_t*)&pData;
    924              HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->TDR, Size);
    925              
    926              /* Enable the DMA transfer for transmit request by setting the DMAT bit
    927                 in the UART CR3 register */
    928              huart->Instance->CR3 |= USART_CR3_DMAT;
    929              
    930              /* Process Unlocked */
    931              __HAL_UNLOCK(huart);
    932              return HAL_OK;
    933            }
    934            else
    935            {
    936              return HAL_BUSY;   
    937            }
    938          }
    939          
    940          /**
    941            * @brief Receive an amount of data in DMA mode 
    942            * @param huart: uart handle
    943            * @param pData: pointer to data buffer
    944            * @param Size: amount of data to be received
    945            * @note   When the UART parity is enabled (PCE = 1) the data received contain the parity bit.
    946            * @retval HAL status
    947            */
    948          HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    949          {
    950            uint32_t *tmp;
    951            if((huart->State == HAL_UART_STATE_READY) || (huart->State == HAL_UART_STATE_BUSY_TX))
    952            {
    953              if((pData == NULL ) || (Size == 0)) 
    954              {
    955                return HAL_ERROR;
    956              }
    957              
    958              /* Process Locked */
    959              __HAL_LOCK(huart);
    960              
    961              huart->pRxBuffPtr = pData;
    962              huart->RxXferSize = Size;
    963              
    964              huart->ErrorCode = HAL_UART_ERROR_NONE;
    965              /* Check if a transmit process is ongoing or not */
    966              if(huart->State == HAL_UART_STATE_BUSY_TX) 
    967              {
    968                huart->State = HAL_UART_STATE_BUSY_TX_RX;
    969              }
    970              else
    971              {
    972                huart->State = HAL_UART_STATE_BUSY_RX;
    973              }
    974              
    975              
    976              /* Set the UART DMA transfert complete callback */
    977              huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
    978              
    979          //    /* Set the UART DMA Half transfer complete callback */
    980          //    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
    981              
    982              /* Set the DMA error callback */
    983              huart->hdmarx->XferErrorCallback = UART_DMAError;
    984          
    985              /* Enable the DMA Stream */
    986              tmp = (uint32_t*)&pData;
    987              HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, *(uint32_t*)tmp, Size);
    988              
    989                /* Enable the UART DLE Interrupt */   
    990              __HAL_UART_ENABLE_IT(huart, UART_IT_IDLE);    //DMA_debug
    991          
    992              /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
    993                 in the UART CR3 register */
    994               huart->Instance->CR3 |= USART_CR3_DMAR;
    995              
    996               /* Process Unlocked */
    997               __HAL_UNLOCK(huart);
    998               
    999              return HAL_OK;
   1000            }
   1001            else
   1002            {
   1003              return HAL_BUSY; 
   1004            }
   1005          }
   1006          
   1007          /**
   1008            * @brief Pauses the DMA Transfer.
   1009            * @param huart: UART handle
   1010            * @retval None
   1011            */
   1012          HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
   1013          {
   1014            /* Process Locked */
   1015            __HAL_LOCK(huart);
   1016            
   1017            if(huart->State == HAL_UART_STATE_BUSY_TX)
   1018            {
   1019              /* Disable the UART DMA Tx request */
   1020              huart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAT);
   1021            }
   1022            else if(huart->State == HAL_UART_STATE_BUSY_RX)
   1023            {
   1024              /* Disable the UART DMA Rx request */
   1025              huart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAR);
   1026            }
   1027            else if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
   1028            {
   1029              /* Disable the UART DMA Tx request */
   1030              huart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAT);
   1031              /* Disable the UART DMA Rx request */
   1032              huart->Instance->CR3 &= (uint32_t)(~USART_CR3_DMAR);
   1033            }
   1034            /* Process Unlocked */
   1035            __HAL_UNLOCK(huart);
   1036          
   1037            return HAL_OK; 
   1038          }
   1039          
   1040          /**
   1041            * @brief Resumes the DMA Transfer.
   1042            * @param huart: UART handle
   1043            * @retval None
   1044            */
   1045          HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
   1046          {
   1047            /* Process Locked */
   1048            __HAL_LOCK(huart);
   1049          
   1050            if(huart->State == HAL_UART_STATE_BUSY_TX)
   1051            {
   1052              /* Enable the UART DMA Tx request */
   1053              huart->Instance->CR3 |= USART_CR3_DMAT;
   1054            }
   1055            else if(huart->State == HAL_UART_STATE_BUSY_RX)
   1056            {
   1057              /* Clear the Overrun flag before resumming the Rx transfer*/
   1058              __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
   1059              
   1060              /* Enable the UART DMA Rx request */
   1061              huart->Instance->CR3 |= USART_CR3_DMAR;
   1062            }
   1063            else if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
   1064            {
   1065              /* Clear the Overrun flag before resumming the Rx transfer*/
   1066              __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
   1067              
   1068              /* Enable the UART DMA Rx request  before the DMA Tx request */
   1069              huart->Instance->CR3 |= USART_CR3_DMAR;
   1070              
   1071              /* Enable the UART DMA Tx request */
   1072              huart->Instance->CR3 |= USART_CR3_DMAT;
   1073            }
   1074          
   1075            /* Process Unlocked */
   1076            __HAL_UNLOCK(huart);
   1077          
   1078            return HAL_OK;
   1079          }
   1080          
   1081          /**
   1082            * @brief Stops the DMA Transfer.
   1083            * @param huart: UART handle
   1084            * @retval None
   1085            */
   1086          HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
   1087          {
   1088            /* The Lock is not implemented on this API to allow the user application
   1089               to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
   1090               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   1091               and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
   1092               */
   1093            
   1094            /* Disable the UART Tx/Rx DMA requests */
   1095            huart->Instance->CR3 &= ~USART_CR3_DMAT;
   1096            huart->Instance->CR3 &= ~USART_CR3_DMAR;
   1097            
   1098            /* Abort the UART DMA tx channel */
   1099            if(huart->hdmatx != NULL)
   1100            {
   1101              HAL_DMA_Abort(huart->hdmatx);
   1102            }
   1103            /* Abort the UART DMA rx channel */
   1104            if(huart->hdmarx != NULL)
   1105            {
   1106              HAL_DMA_Abort(huart->hdmarx);
   1107            }
   1108            
   1109            huart->State = HAL_UART_STATE_READY;
   1110            
   1111            return HAL_OK;
   1112          }
   1113          
   1114          /**
   1115            * @brief This function handles UART interrupt request.
   1116            * @param huart: uart handle
   1117            * @retval None
   1118            */
   1119          uint16_t overrun_cnt0;
   1120          uint16_t overrun_cnt1;
   1121          uint16_t overrun_cnt2;
   1122          uint16_t overrun_cnt3;
   1123          void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
   1124          {
   1125            /* UART parity error interrupt occurred ------------------------------------*/
   1126            if((__HAL_UART_GET_IT(huart, UART_IT_PE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_PE) != RESET))
   1127            { 
   1128              __HAL_UART_CLEAR_IT(huart, UART_CLEAR_PEF);
   1129              
   1130              huart->ErrorCode |= HAL_UART_ERROR_PE;
   1131              /* Set the UART state ready to be able to start again the process */
   1132              huart->State = HAL_UART_STATE_READY;
   1133            }
   1134            
   1135            /* UART frame error interrupt occured --------------------------------------*/
   1136            if((__HAL_UART_GET_IT(huart, UART_IT_FE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR) != RESET))
   1137            { 
   1138              __HAL_UART_CLEAR_IT(huart, UART_CLEAR_FEF);
   1139              
   1140              huart->ErrorCode |= HAL_UART_ERROR_FE;
   1141              /* Set the UART state ready to be able to start again the process */
   1142              huart->State = HAL_UART_STATE_READY;
   1143            }
   1144            
   1145            /* UART noise error interrupt occured --------------------------------------*/
   1146            if((__HAL_UART_GET_IT(huart, UART_IT_NE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR) != RESET))
   1147            { 
   1148              __HAL_UART_CLEAR_IT(huart, UART_CLEAR_NEF);
   1149              
   1150              huart->ErrorCode |= HAL_UART_ERROR_NE;
   1151              /* Set the UART state ready to be able to start again the process */
   1152              huart->State = HAL_UART_STATE_READY;
   1153            }
   1154            
   1155            /* UART Over-Run interrupt occured -----------------------------------------*/
   1156            if((__HAL_UART_GET_IT(huart, UART_IT_ORE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR) != RESET))
   1157            { 
   1158              __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
   1159                
   1160              huart->ErrorCode |= HAL_UART_ERROR_ORE;
   1161              /* Set the UART state ready to be able to start again the process */
   1162              huart->State = HAL_UART_STATE_READY;
   1163            }
   1164          
   1165             /* Call UART Error Call back function if need be --------------------------*/
   1166            if(huart->ErrorCode != HAL_UART_ERROR_NONE)
   1167            {
   1168              HAL_UART_ErrorCallback(huart);
   1169            }
   1170          
   1171            /* UART Wake Up interrupt occured ------------------------------------------*/
   1172            if((__HAL_UART_GET_IT(huart, UART_IT_WUF) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_WUF) != RESET))
   1173            { 
   1174              __HAL_UART_CLEAR_IT(huart, UART_CLEAR_WUF);
   1175              /* Set the UART state ready to be able to start again the process */
   1176              huart->State = HAL_UART_STATE_READY;
   1177              HAL_UARTEx_WakeupCallback(huart);
   1178            }
   1179            
   1180            /* UART in mode Receiver ---------------------------------------------------*/
   1181            if((__HAL_UART_GET_IT(huart, UART_IT_RXNE) != RESET) && (__HAL_UART_GET_IT_SOURCE(huart, UART_IT_RXNE) != RESET))
   1182            { 
   1183              UART_Receive_IT(huart);
   1184            }
   1185            
   1186            /* UART in mode Transmitter ------------------------------------------------*/
   1187            if((__HAL_UART_GET_IT(huart, UART_IT_TXE) != RESET) &&(__HAL_UART_GET_IT_SOURCE(huart, UART_IT_TXE) != RESET))
   1188            {
   1189              UART_Transmit_IT(huart);
   1190            }
   1191          
   1192          //  if(huart->ErrorCode != HAL_UART_ERROR_NONE)
   1193          //  {
   1194          //    HAL_UART_ErrorCallback(huart);
   1195          //  }
   1196          }
   1197          
   1198          /**
   1199            * @brief Tx Transfer completed callbacks
   1200            * @param huart: uart handle
   1201            * @retval None
   1202            */
   1203           __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
   1204          {
   1205            /* NOTE : This function Should not be modified, when the callback is needed,
   1206                      the HAL_UART_TxCpltCallback could be implemented in the user file
   1207             */ 
   1208          }
   1209          
   1210          /**
   1211            * @brief  Tx Half Transfer completed callbacks.
   1212            * @param  huart: UART handle
   1213            * @retval None
   1214            */
   1215           __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
   1216          {
   1217            /* NOTE: This function Should not be modified, when the callback is needed,
   1218                     the HAL_UART_TxCpltCallback could be implemented in the user file
   1219             */ 
   1220          }
   1221          
   1222          /**
   1223            * @brief Rx Transfer completed callbacks
   1224            * @param huart: uart handle
   1225            * @retval None
   1226            */
   1227          __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
   1228          {
   1229            /* NOTE : This function Should not be modified, when the callback is needed,
   1230                      the HAL_UART_TxCpltCallback could be implemented in the user file
   1231             */
   1232          }
   1233          
   1234          /**
   1235            * @brief  Rx Half Transfer completed callbacks.
   1236            * @param  huart: UART handle
   1237            * @retval None
   1238            */
   1239          __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
   1240          {
   1241            /* NOTE: This function Should not be modified, when the callback is needed,
   1242                     the HAL_UART_TxCpltCallback could be implemented in the user file
   1243             */
   1244          }
   1245          
   1246          /**
   1247            * @brief UART error callbacks
   1248            * @param huart: uart handle
   1249            * @retval None
   1250            */
   1251           __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
   1252          {
   1253            /* NOTE : This function should not be modified, when the callback is needed,
   1254                      the HAL_UART_ErrorCallback can be implemented in the user file
   1255             */ 
   1256          }
   1257          
   1258          
   1259          /**
   1260            * @}
   1261            */
   1262          
   1263          /** @defgroup UART_Group3 Peripheral Control funtions 
   1264            *  @brief   UART control functions 
   1265            *
   1266          @verbatim   
   1267           ===============================================================================
   1268                                ##### Peripheral Control functions #####
   1269           ===============================================================================  
   1270              [..]
   1271              This subsection provides a set of functions allowing to control the UART.
   1272               (+) HAL_MultiProcessor_EnableMuteMode() API enables mute mode
   1273               (+) HAL_MultiProcessor_DisableMuteMode() API disables mute mode
   1274               (+) HAL_MultiProcessor_EnterMuteMode() API enters mute mode
   1275               (+) HAL_HalfDuplex_EnableTransmitter() API enables the transmitter
   1276               (+) HAL_HalfDuplex_EnableReceiver() API enables the receiver
   1277               (+) HAL_UART_GetState() API is helpful to check in run-time the state of the UART peripheral
   1278               (+) HAL_UART_GetError()API is helpful to check in run-time the error state of the UART peripheral
   1279          @endverbatim
   1280            * @{
   1281            */
   1282          
   1283          /**
   1284            * @brief Enable UART in mute mode (doesn't mean UART enters mute mode;
   1285            * to enter mute mode, HAL_MultiProcessor_EnterMuteMode() API must be called)
   1286            * @param huart: uart handle
   1287            * @retval HAL status
   1288            */
   1289          HAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart)
   1290          {  
   1291            /* Process Locked */
   1292            __HAL_LOCK(huart);
   1293            
   1294            huart->State = HAL_UART_STATE_BUSY;
   1295            
   1296            /* Enable USART mute mode by setting the MME bit in the CR1 register */
   1297            huart->Instance->CR1 |= USART_CR1_MME;
   1298            
   1299            huart->State = HAL_UART_STATE_READY;
   1300            
   1301            return (UART_CheckIdleState(huart));
   1302          }
   1303          
   1304          /**
   1305            * @brief Disable UART mute mode (doesn't mean it actually wakes up the software,
   1306            * as it may not have been in mute mode at this very moment).
   1307            * @param huart: uart handle
   1308            * @retval HAL status
   1309            */
   1310          HAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart)
   1311          { 
   1312            /* Process Locked */
   1313            __HAL_LOCK(huart);
   1314            
   1315            huart->State = HAL_UART_STATE_BUSY;
   1316            
   1317             /* Disable USART mute mode by clearing the MME bit in the CR1 register */
   1318            huart->Instance->CR1 &= ~(USART_CR1_MME);
   1319            
   1320            huart->State = HAL_UART_STATE_READY;
   1321            
   1322            return (UART_CheckIdleState(huart));
   1323          }
   1324          
   1325          /**
   1326            * @brief Enter UART mute mode (means UART actually enters mute mode).
   1327            * To exit from mute mode, HAL_MultiProcessor_DisableMuteMode() API must be called. 
   1328            * @param huart: uart handle
   1329            * @retval HAL status
   1330            */
   1331          void HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
   1332          {    
   1333            __HAL_UART_SEND_REQ(huart, UART_MUTE_MODE_REQUEST);
   1334          }
   1335          
   1336          /**
   1337            * @brief  Enables the UART transmitter and disables the UART receiver.
   1338            * @param  huart: UART handle
   1339            * @retval HAL status
   1340            * @retval None
   1341            */
   1342          HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
   1343          {
   1344            /* Process Locked */
   1345            __HAL_LOCK(huart);
   1346            huart->State = HAL_UART_STATE_BUSY;
   1347          
   1348            /* Clear TE and RE bits */
   1349            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
   1350            /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
   1351            SET_BIT(huart->Instance->CR1, USART_CR1_TE);
   1352          
   1353            huart->State = HAL_UART_STATE_READY;
   1354            /* Process Unlocked */
   1355            __HAL_UNLOCK(huart);
   1356          
   1357            return HAL_OK;
   1358          }
   1359          
   1360          /**
   1361            * @brief  Enables the UART receiver and disables the UART transmitter.
   1362            * @param  huart: UART handle
   1363            * @retval HAL status
   1364            */
   1365          HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
   1366          {
   1367            /* Process Locked */
   1368            __HAL_LOCK(huart);
   1369            huart->State = HAL_UART_STATE_BUSY;
   1370          
   1371            /* Clear TE and RE bits */
   1372            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
   1373            /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
   1374            SET_BIT(huart->Instance->CR1, USART_CR1_RE);
   1375          
   1376            huart->State = HAL_UART_STATE_READY;
   1377            /* Process Unlocked */
   1378            __HAL_UNLOCK(huart);
   1379          
   1380            return HAL_OK;
   1381          }
   1382          
   1383          /**
   1384            * @brief  Transmits break characters.
   1385            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1386            *                the configuration information for the specified UART module.
   1387            * @retval HAL status
   1388            */
   1389          HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
   1390          {
   1391            /* Check the parameters */
   1392            assert_param(IS_UART_INSTANCE(huart->Instance));
   1393            
   1394            /* Process Locked */
   1395            __HAL_LOCK(huart);
   1396            
   1397            huart->State = HAL_UART_STATE_BUSY;
   1398            
   1399            /* Send break characters */
   1400            huart->Instance->RQR |= USART_RQR_SBKRQ;
   1401           
   1402            huart->State = HAL_UART_STATE_READY;
   1403            
   1404            /* Process Unlocked */
   1405            __HAL_UNLOCK(huart);
   1406            
   1407            return HAL_OK; 
   1408          }
   1409          
   1410          /**
   1411            * @brief return the UART state
   1412            * @param huart: uart handle
   1413            * @retval HAL state
   1414            */
   1415          HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
   1416          {
   1417            return huart->State;
   1418          }
   1419          
   1420          /**
   1421          * @brief  Return the UART error code
   1422          * @param  huart : pointer to a UART_HandleTypeDef structure that contains
   1423            *              the configuration information for the specified UART.
   1424          * @retval UART Error Code
   1425          */
   1426          uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
   1427          {
   1428            return huart->ErrorCode;
   1429          }
   1430          
   1431          /**
   1432            * @}
   1433            */
   1434          
   1435          /**
   1436            * @brief DMA UART transmit process complete callback 
   1437            * @param hdma: DMA handle
   1438            * @retval None
   1439            */
   1440          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)     
   1441          {
   1442            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   1443            
   1444            /* DMA Normal mode*/  
   1445            if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
   1446            {
   1447              huart->TxXferCount = 0;
   1448              
   1449              /* Disable the DMA transfer for transmit request by setting the DMAT bit
   1450              in the UART CR3 register */
   1451              huart->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAT);
   1452              
   1453              /* Wait for UART TC Flag */
   1454              if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, UART_TIMEOUT_VALUE) != HAL_OK)
   1455              {
   1456                /* Timeout Occured */ 
   1457                huart->State = HAL_UART_STATE_TIMEOUT;
   1458                HAL_UART_ErrorCallback(huart);
   1459              }
   1460              else
   1461              {
   1462                /* No Timeout */
   1463                /* Check if a receive process is ongoing or not */
   1464                if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
   1465                {
   1466                  huart->State = HAL_UART_STATE_BUSY_RX;
   1467                }
   1468                else
   1469                {
   1470                  huart->State = HAL_UART_STATE_READY;
   1471                }
   1472                HAL_UART_TxCpltCallback(huart);
   1473              }
   1474            }
   1475            /* DMA Circular mode */
   1476            else
   1477            {
   1478              HAL_UART_TxCpltCallback(huart);
   1479            }
   1480          }
   1481          
   1482          /**
   1483            * @brief DMA UART transmit process half complete callback 
   1484            * @param hdma : DMA handle
   1485            * @retval None
   1486            */
   1487          
   1488          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
                             ^
Warning[Pe177]: function "UART_DMATxHalfCplt" was declared but never referenced
   1489          {
   1490            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   1491          
   1492            HAL_UART_TxHalfCpltCallback(huart);
   1493          }
   1494          
   1495          /**
   1496            * @brief DMA UART receive process complete callback 
   1497            * @param hdma: DMA handle
   1498            * @retval None
   1499            */
   1500          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
   1501          {
   1502            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   1503            
   1504            /* DMA Normal mode*/
   1505            if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
   1506            {
   1507              huart->RxXferCount = 0;
   1508              
   1509              /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
   1510              in the UART CR3 register */
   1511              huart->Instance->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DMAR);
   1512              
   1513              /* Check if a transmit Process is ongoing or not */
   1514              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   1515              {
   1516                huart->State = HAL_UART_STATE_BUSY_TX;
   1517              }
   1518              else
   1519              {
   1520                huart->State = HAL_UART_STATE_READY;
   1521              }
   1522            }
   1523            HAL_UART_RxCpltCallback(huart);
   1524          }
   1525          
   1526          /**
   1527            * @brief DMA UART receive process half complete callback 
   1528            * @param hdma : DMA handle
   1529            * @retval None
   1530            */
   1531          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
                             ^
Warning[Pe177]: function "UART_DMARxHalfCplt" was declared but never referenced
   1532          {
   1533            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   1534          
   1535            HAL_UART_RxHalfCpltCallback(huart); 
   1536          }
   1537          
   1538          /**
   1539            * @brief DMA UART communication error callback 
   1540            * @param hdma: DMA handle
   1541            * @retval None
   1542            */
   1543          static void UART_DMAError(DMA_HandleTypeDef *hdma)   
   1544          {
   1545            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   1546            huart->RxXferCount = 0;
   1547            huart->TxXferCount = 0;
   1548            huart->State= HAL_UART_STATE_READY;
   1549            huart->ErrorCode |= HAL_UART_ERROR_DMA;
   1550            HAL_UART_ErrorCallback(huart);
   1551          }
   1552          
   1553          /**
   1554            * @brief Send an amount of data in interrupt mode 
   1555            *         Function called under interruption only, once
   1556            *         interruptions have been enabled by HAL_UART_Transmit_IT()
   1557            * @param  huart: UART handle
   1558            * @retval HAL status
   1559            */
   1560          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
   1561          {
   1562            uint16_t* tmp;
   1563          
   1564            if ((huart->State == HAL_UART_STATE_BUSY_TX) || (huart->State == HAL_UART_STATE_BUSY_TX_RX))
   1565            {
   1566              if(huart->TxXferCount == 0)
   1567              {
   1568                /* Disable the UART TXE Interrupt */
   1569                __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   1570          
   1571                /* Check if a receive Process is ongoing or not */
   1572                if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   1573                {
   1574                  huart->State = HAL_UART_STATE_BUSY_RX;
   1575                }
   1576                else
   1577                {
   1578                  /* Disable the UART Parity Error Interrupt */
   1579                  __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   1580                  
   1581                  /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   1582                  __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   1583                  
   1584                  huart->State = HAL_UART_STATE_READY;
   1585                }
   1586                
   1587                /* Wait on TC flag to be able to start a second transfer */
   1588                if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, UART_TIMEOUT_VALUE) != HAL_OK)
   1589                { 
   1590                  return HAL_TIMEOUT;
   1591                }
   1592          
   1593                HAL_UART_TxCpltCallback(huart);
   1594          
   1595                return HAL_OK;
   1596              }
   1597              else
   1598              {
   1599                if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
   1600                {
   1601                  tmp = (uint16_t*) huart->pTxBuffPtr;
   1602                  huart->Instance->TDR = (*tmp & (uint16_t)0x01FF);
   1603                  huart->pTxBuffPtr += 2;
   1604                } 
   1605                else
   1606                {
   1607                  huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0xFF);
   1608                }
   1609          
   1610                huart->TxXferCount--;
   1611            
   1612                return HAL_OK;
   1613              }
   1614            }
   1615            else
   1616            {
   1617              return HAL_BUSY;   
   1618            }
   1619          }
   1620          
   1621          /**
   1622            * @brief Receive an amount of data in interrupt mode 
   1623            *         Function called under interruption only, once
   1624            *         interruptions have been enabled by HAL_UART_Receive_IT()
   1625            * @param  huart: UART handle
   1626            * @retval HAL status
   1627            */
   1628          
   1629          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
   1630          {
   1631            uint16_t* tmp;
   1632            uint16_t uhMask = huart->Mask;
   1633          
   1634            if((huart->State == HAL_UART_STATE_BUSY_RX) || (huart->State == HAL_UART_STATE_BUSY_TX_RX))
   1635            {
   1636              if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
   1637              {
   1638                tmp = (uint16_t*) huart->pRxBuffPtr ;
   1639                *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
   1640                huart->pRxBuffPtr +=2;
   1641              }
   1642              else
   1643              {
   1644                *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask); 
   1645              }
   1646          
   1647              if(--huart->RxXferCount == 0)
   1648              {
   1649                while(HAL_IS_BIT_SET(huart->Instance->ISR, UART_FLAG_RXNE))
   1650                {
   1651                }
   1652                __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   1653          
   1654                /* Check if a transmit Process is ongoing or not */
   1655                if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   1656                {
   1657                  huart->State = HAL_UART_STATE_BUSY_TX;
   1658                }
   1659                else
   1660                {
   1661                  /* Disable the UART Parity Error Interrupt */
   1662                  __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   1663          
   1664                  /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   1665                  __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   1666          
   1667                  huart->State = HAL_UART_STATE_READY;
   1668                }
   1669                HAL_UART_RxCpltCallback(huart);
   1670                return HAL_OK;
   1671              }
   1672              return HAL_OK;
   1673            }
   1674            else
   1675            {
   1676              return HAL_BUSY; 
   1677            }
   1678          }
   1679          
   1680          /**
   1681            * @brief Configure the UART peripheral 
   1682            * @param huart: uart handle
   1683            * @retval None
   1684            */
   1685          void UART_SetConfig(UART_HandleTypeDef *huart)
   1686          {
   1687            uint32_t tmpreg = 0x00000000;
   1688            uint32_t clocksource = 0x00000000;
   1689            uint16_t brrtemp = 0x0000;
   1690            uint16_t usartdiv = 0x0000;
   1691            
   1692            /* Check the parameters */ 
   1693            assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));  
   1694            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
   1695            assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
   1696            assert_param(IS_UART_PARITY(huart->Init.Parity));
   1697            assert_param(IS_UART_MODE(huart->Init.Mode));
   1698            assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
   1699            assert_param(IS_UART_ONEBIT_SAMPLING(huart->Init.OneBitSampling)); 
   1700          
   1701            /*-------------------------- USART CR1 Configuration -----------------------*/
   1702            /* Clear M, PCE, PS, TE, RE and OVER8 bits and configure       
   1703             *  the UART Word Length, Parity, Mode and oversampling: 
   1704             *  set the M bits according to huart->Init.WordLength value 
   1705             *  set PCE and PS bits according to huart->Init.Parity value
   1706             *  set TE and RE bits according to huart->Init.Mode value
   1707             *  set OVER8 bit according to huart->Init.OverSampling value */
   1708            tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
   1709            MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
   1710          
   1711            /*-------------------------- USART CR2 Configuration -----------------------*/
   1712            /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
   1713             * to huart->Init.StopBits value */
   1714            MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
   1715            
   1716            /*-------------------------- USART CR3 Configuration -----------------------*/
   1717            /* Configure 
   1718             * - UART HardWare Flow Control: set CTSE and RTSE bits according 
   1719             *   to huart->Init.HwFlowCtl value 
   1720             * - one-bit sampling method versus three samples' majority rule according
   1721             *   to huart->Init.OneBitSampling */
   1722            tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
   1723            MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
   1724            
   1725            /*-------------------------- USART BRR Configuration -----------------------*/
   1726            __HAL_UART_GETCLOCKSOURCE(huart, clocksource);
   1727            
   1728            /* Check LPUART instace */
   1729            if(huart->Instance == LPUART1)
   1730            {
   1731              switch (clocksource)
   1732              {
   1733              case UART_CLOCKSOURCE_PCLK1: 
   1734                huart->Instance->BRR = (uint32_t)(__DIV_LPUART(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
   1735                break;
   1736              case UART_CLOCKSOURCE_HSI: 
   1737                huart->Instance->BRR = (uint32_t)(__DIV_LPUART(HSI_VALUE, huart->Init.BaudRate)); 
   1738                break; 
   1739              case UART_CLOCKSOURCE_SYSCLK:  
   1740                huart->Instance->BRR = (uint32_t)(__DIV_LPUART(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
   1741                break;  
   1742              case UART_CLOCKSOURCE_LSE:
   1743                huart->Instance->BRR = (uint32_t)(__DIV_LPUART(LSE_VALUE, huart->Init.BaudRate)); 
   1744                break;
   1745              default:
   1746                break;
   1747              }
   1748            }
   1749            /* Check the UART Over Sampling 8 to set Baud Rate Register */
   1750            else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
   1751            { 
   1752              switch (clocksource)
   1753              {
   1754              case UART_CLOCKSOURCE_PCLK1:
   1755                usartdiv = (uint32_t)(__DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
   1756                break;
   1757              case UART_CLOCKSOURCE_PCLK2:
   1758                usartdiv = (uint32_t)(__DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
   1759                break;
   1760              case UART_CLOCKSOURCE_HSI:
   1761                usartdiv = (uint32_t)(__DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate)); 
   1762                break;
   1763              case UART_CLOCKSOURCE_SYSCLK:
   1764                huart->Instance->BRR = (uint32_t)(__DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
   1765                break;
   1766              case UART_CLOCKSOURCE_LSE:
   1767                usartdiv = (uint32_t)(__DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate)); 
   1768                break;
   1769              default:
   1770                break;
   1771              }
   1772              
   1773              brrtemp = usartdiv & 0xFFF0;
   1774              brrtemp |= (uint16_t)((uint16_t)(usartdiv & (uint16_t)0x000F) >> (uint16_t)1);
   1775              huart->Instance->BRR = brrtemp;
   1776            }
   1777            else
   1778            {
   1779              switch (clocksource)
   1780              {
   1781              case UART_CLOCKSOURCE_PCLK1: 
   1782                huart->Instance->BRR = (uint32_t)(__DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
   1783                break;
   1784              case UART_CLOCKSOURCE_PCLK2: 
   1785                huart->Instance->BRR = (uint32_t)(__DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
   1786                break;
   1787              case UART_CLOCKSOURCE_HSI: 
   1788                huart->Instance->BRR = (uint32_t)(__DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate)); 
   1789                break; 
   1790              case UART_CLOCKSOURCE_SYSCLK:  
   1791                huart->Instance->BRR = (uint32_t)(__DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
   1792                break;  
   1793              case UART_CLOCKSOURCE_LSE:
   1794                huart->Instance->BRR = (uint32_t)(__DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate)); 
   1795                break;
   1796              default:
   1797                break;
   1798              }
   1799            }
   1800          }
   1801          
   1802          /**
   1803            * @brief Check the UART Idle State
   1804            * @param huart: uart handle
   1805            * @retval HAL status
   1806            */
   1807          HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
   1808          {
   1809            /* Check if the Transmitter is enabled */
   1810            if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
   1811            {
   1812              /* Wait until TEACK flag is set */
   1813              if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, UART_TIMEOUT_VALUE) != HAL_OK)
   1814              {
   1815                return HAL_TIMEOUT;
   1816              }
   1817            }
   1818            /* Check if the Receiver is enabled */
   1819            if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
   1820            {
   1821              /* Wait until REACK flag is set */
   1822              if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, UART_TIMEOUT_VALUE) != HAL_OK)
   1823              { 
   1824                return HAL_TIMEOUT;
   1825              }
   1826            }
   1827            
   1828            /* Process Unlocked */
   1829            __HAL_UNLOCK(huart);
   1830            
   1831            /* Initialize the UART state*/
   1832            huart->ErrorCode = HAL_UART_ERROR_NONE;
   1833            huart->State= HAL_UART_STATE_READY;
   1834            
   1835            return HAL_OK;
   1836          }
   1837          
   1838          /**
   1839            * @brief Configure the UART peripheral advanced feautures 
   1840            * @param huart: uart handle  
   1841            * @retval None
   1842            */
   1843          void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
   1844          {
   1845            /* Check whether the set of advanced features to configure is properly set */ 
   1846            assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
   1847            
   1848            /* if required, configure TX pin active level inversion */
   1849            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
   1850            {
   1851              assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
   1852              MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
   1853            }
   1854            
   1855            /* if required, configure RX pin active level inversion */
   1856            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
   1857            {
   1858              assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
   1859              MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
   1860            }
   1861            
   1862            /* if required, configure data inversion */
   1863            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
   1864            {
   1865              assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
   1866              MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
   1867            }
   1868            
   1869            /* if required, configure RX/TX pins swap */
   1870            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
   1871            {
   1872              assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
   1873              MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
   1874            }
   1875            
   1876            /* if required, configure RX overrun detection disabling */
   1877            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
   1878            {
   1879              assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));  
   1880              MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
   1881            }
   1882            
   1883            /* if required, configure DMA disabling on reception error */
   1884            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
   1885            {
   1886              assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));   
   1887              MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
   1888            }
   1889            
   1890            /* if required, configure auto Baud rate detection scheme */              
   1891            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
   1892            {
   1893              assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
   1894              MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
   1895              /* set auto Baudrate detection parameters if detection is enabled */
   1896              if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
   1897              {
   1898                assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
   1899                MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
   1900              }
   1901            }
   1902            
   1903            /* if required, configure MSB first on communication line */  
   1904            if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
   1905            {
   1906              assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));   
   1907              MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
   1908            }
   1909          }
   1910          
   1911          /**
   1912            * @brief  This function handles UART Communication Timeout.
   1913            * @param  huart: UART handle
   1914            * @param  Flag: specifies the UART flag to check.
   1915            * @param  Status: The new Flag status (SET or RESET).
   1916            * @param  Timeout: Timeout duration
   1917            * @retval HAL status
   1918            */
   1919          HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
   1920          {
   1921            uint32_t tickstart = 0x00;
   1922            tickstart = HAL_GetTick();
   1923            
   1924            /* Wait until flag is set */
   1925            if(Status == RESET)
   1926            {    
   1927              while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
   1928              {
   1929                /* Check for the Timeout */
   1930                if(Timeout != HAL_MAX_DELAY)
   1931                {
   1932                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   1933                  {
   1934                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1935                    __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   1936                    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   1937                    __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   1938                    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   1939                    
   1940                    huart->State= HAL_UART_STATE_TIMEOUT;
   1941                    
   1942                    /* Process Unlocked */
   1943                    __HAL_UNLOCK(huart);
   1944                    
   1945                    return HAL_TIMEOUT;
   1946                  }
   1947                }
   1948              }
   1949            }
   1950            else
   1951            {
   1952              while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
   1953              {
   1954                /* Check for the Timeout */
   1955                if(Timeout != HAL_MAX_DELAY)
   1956                {
   1957                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   1958                  {
   1959                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1960                    __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   1961                    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   1962                    __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   1963                    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   1964                    
   1965                    huart->State= HAL_UART_STATE_TIMEOUT;
   1966                    
   1967                    /* Process Unlocked */
   1968                    __HAL_UNLOCK(huart);
   1969                    
   1970                    return HAL_TIMEOUT;
   1971                  }
   1972                }
   1973              }
   1974            }
   1975            return HAL_OK;      
   1976          }
   1977          
   1978          /**
   1979            * @}
   1980            */
   1981          
   1982          #endif /* HAL_UART_MODULE_ENABLED */
   1983          /**
   1984            * @}
   1985            */
   1986          
   1987          /**
   1988            * @}
   1989            */
   1990          
   1991          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_HalfDuplex_EnableReceiver
       8   HAL_HalfDuplex_EnableTransmitter
       8   HAL_HalfDuplex_Init
         8   -> HAL_UART_MspInit
         8   -> UART_AdvFeatureConfig
         8   -> UART_CheckIdleState
         8   -> UART_SetConfig
      16   HAL_LIN_Init
        16   -> HAL_UART_MspInit
        16   -> UART_AdvFeatureConfig
        16   -> UART_CheckIdleState
        16   -> UART_SetConfig
       8   HAL_LIN_SendBreak
       8   HAL_MultiProcessor_DisableMuteMode
         8   -> UART_CheckIdleState
       8   HAL_MultiProcessor_EnableMuteMode
         8   -> UART_CheckIdleState
       0   HAL_MultiProcessor_EnterMuteMode
      16   HAL_MultiProcessor_Init
        16   -> HAL_UART_MspInit
        16   -> UART_AdvFeatureConfig
        16   -> UART_CheckIdleState
        16   -> UART_SetConfig
       8   HAL_UART_DMAPause
       8   HAL_UART_DMAResume
       8   HAL_UART_DMAStop
         8   -> HAL_DMA_Abort
      16   HAL_UART_DeInit
        16   -> HAL_UART_MspDeInit
       0   HAL_UART_ErrorCallback
       0   HAL_UART_GetError
       0   HAL_UART_GetState
      16   HAL_UART_IRQHandler
        16   -> HAL_UARTEx_WakeupCallback
        16   -> HAL_UART_ErrorCallback
        16   -> UART_Receive_IT
        16   -> UART_Transmit_IT
       8   HAL_UART_Init
         8   -> HAL_UART_MspInit
         8   -> UART_AdvFeatureConfig
         8   -> UART_CheckIdleState
         8   -> UART_SetConfig
       0   HAL_UART_MspDeInit
      32   HAL_UART_Receive
        32   -> UART_WaitOnFlagUntilTimeout
      16   HAL_UART_Receive_DMA
        16   -> HAL_DMA_Start_IT
       8   HAL_UART_Receive_IT
       0   HAL_UART_RxCpltCallback
       0   HAL_UART_RxHalfCpltCallback
      24   HAL_UART_Transmit
        24   -> UART_WaitOnFlagUntilTimeout
      16   HAL_UART_Transmit_DMA
        16   -> HAL_DMA_Start_IT
       8   HAL_UART_Transmit_IT
       0   HAL_UART_TxCpltCallback
       0   HAL_UART_TxHalfCpltCallback
       0   UART_AdvFeatureConfig
      16   UART_CheckIdleState
        16   -> UART_WaitOnFlagUntilTimeout
       8   UART_DMAError
         8   -> HAL_UART_ErrorCallback
       8   UART_DMAReceiveCplt
         8   -> HAL_UART_RxCpltCallback
       8   UART_DMATransmitCplt
         8   -> HAL_UART_ErrorCallback
         8   -> HAL_UART_TxCpltCallback
         8   -> UART_WaitOnFlagUntilTimeout
       8   UART_Receive_IT
         8   -> HAL_UART_RxCpltCallback
      16   UART_SetConfig
        16   -> HAL_RCC_GetPCLK1Freq
        16   -> HAL_RCC_GetPCLK2Freq
        16   -> HAL_RCC_GetSysClockFreq
        16 __aeabi_uidiv
       8   UART_Transmit_IT
         8   -> HAL_UART_TxCpltCallback
         8   -> UART_WaitOnFlagUntilTimeout
      40   UART_WaitOnFlagUntilTimeout
        40   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_15
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
       4  ??DataTable2
       4  ??DataTable3
       4  ??DataTable6
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       6  ??Subroutine4_0
      10  ??Subroutine5_0
       8  ?Subroutine0
      12  ?Subroutine1
       8  ?Subroutine2
      12  ?Subroutine3
      42  HAL_HalfDuplex_EnableReceiver
      44  HAL_HalfDuplex_EnableTransmitter
      82  HAL_HalfDuplex_Init
     128  HAL_LIN_Init
      36  HAL_LIN_SendBreak
      42  HAL_MultiProcessor_DisableMuteMode
      42  HAL_MultiProcessor_EnableMuteMode
      12  HAL_MultiProcessor_EnterMuteMode
     136  HAL_MultiProcessor_Init
      90  HAL_UART_DMAPause
      86  HAL_UART_DMAResume
      54  HAL_UART_DMAStop
      62  HAL_UART_DeInit
       2  HAL_UART_ErrorCallback
       6  HAL_UART_GetError
       6  HAL_UART_GetState
     224  HAL_UART_IRQHandler
      80  HAL_UART_Init
       2  HAL_UART_MspDeInit
     260  HAL_UART_Receive
     124  HAL_UART_Receive_DMA
     154  HAL_UART_Receive_IT
       2  HAL_UART_RxCpltCallback
       2  HAL_UART_RxHalfCpltCallback
     200  HAL_UART_Transmit
     116  HAL_UART_Transmit_DMA
      92  HAL_UART_Transmit_IT
       2  HAL_UART_TxCpltCallback
       2  HAL_UART_TxHalfCpltCallback
     200  UART_AdvFeatureConfig
      82  UART_CheckIdleState
      32  UART_DMAError
      54  UART_DMAReceiveCplt
      84  UART_DMATransmitCplt
     152  UART_Receive_IT
     374  UART_SetConfig
     172  UART_Transmit_IT
     168  UART_WaitOnFlagUntilTimeout
       2  overrun_cnt0
       2  overrun_cnt1
       2  overrun_cnt2
       2  overrun_cnt3

 
     8 bytes in section .bss
 3 632 bytes in section .text
 
 3 632 bytes of CODE memory
     8 bytes of DATA memory

Errors: none
Warnings: 2

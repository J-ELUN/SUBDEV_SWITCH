###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        13/Jul/2017  14:23:17
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\demo\SUBDEV_SWITCH\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_rcc.c
#    Command line =  
#        F:\demo\SUBDEV_SWITCH\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_rcc.c
#        -D STM32L053xx -D USE_HAL_DRIVER -lc
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\List\ -o
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\Obj\ --debug
#        --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\..\Drivers\STM32L0xx_HAL_Driver\Inc\
#        -I F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\Inc\ -I
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\..\Drivers\CMSIS\Device\ST\STM32L0xx\Include\
#        -I F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\..\Drivers\CMSIS\Include\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\List\stm32l0xx_hal_rcc.lst
#    Object file  =  
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\Obj\stm32l0xx_hal_rcc.o
#
###############################################################################

F:\demo\SUBDEV_SWITCH\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l0xx_hal_rcc.c
      4            * @author  MCD Application Team
      5            * @version V1.1.0
      6            * @date    18-June-2014
      7            * @brief   RCC HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Reset and Clock Control (RCC) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + Peripheral Control functions
     12            *       
     13            @verbatim                
     14            ==============================================================================
     15                                ##### RCC specific features #####
     16            ==============================================================================
     17              [..] After reset the device is running from MSI (2 MHz) with Flash 0 WS, 
     18                   all peripherals are off except internal SRAM, Flash and SW-DP.
     19                   (+) There is no prescaler on High speed (AHB) and Low speed (APB) busses;
     20                       all peripherals mapped on these busses are running at MSI speed.
     21                   (+) The clock for all peripherals is switched off, except the SRAM and 
     22                       FLASH.
     23                   (+) All GPIOs are in input floating state, except the SW-DP pins which
     24                       are assigned to be used for debug purpose.
     25              [..] Once the device started from reset, the user application has to:
     26                   (+) Configure the clock source to be used to drive the System clock
     27                       (if the application needs higher frequency/performance)
     28                   (+) Configure the System clock frequency and Flash settings
     29                   (+) Configure the AHB and APB busses prescalers
     30                   (+) Enable the clock for the peripheral(s) to be used
     31                   (+) Configure the clock source(s) for peripherals whose clocks are not
     32                       derived from the System clock (ADC, RTC/LCD, RNG and IWDG)
     33            @endverbatim
     34            ******************************************************************************
     35            * @attention
     36            *
     37            * <h2><center>&copy; COPYRIGHT(c) 2014 STMicroelectronics</center></h2>
     38            *
     39            * Redistribution and use in source and binary forms, with or without modification,
     40            * are permitted provided that the following conditions are met:
     41            *   1. Redistributions of source code must retain the above copyright notice,
     42            *      this list of conditions and the following disclaimer.
     43            *   2. Redistributions in binary form must reproduce the above copyright notice,
     44            *      this list of conditions and the following disclaimer in the documentation
     45            *      and/or other materials provided with the distribution.
     46            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     47            *      may be used to endorse or promote products derived from this software
     48            *      without specific prior written permission.
     49            *
     50            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     51            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     52            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     53            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     54            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     55            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     56            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     57            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     58            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     59            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     60            *
     61            ******************************************************************************  
     62            */ 
     63          
     64          /* Includes ------------------------------------------------------------------*/
     65          #include "stm32l0xx_hal.h"
     66          
     67          /** @addtogroup STM32L0xx_HAL_Driver
     68            * @{
     69            */
     70          
     71          /** @defgroup RCC 
     72            * @brief RCC HAL module driver
     73            * @{
     74            */
     75          
     76          #ifdef HAL_RCC_MODULE_ENABLED
     77          
     78          /* Private typedef -----------------------------------------------------------*/
     79          /* Private define ------------------------------------------------------------*/
     80          #define HSE_TIMEOUT_VALUE          HSE_STARTUP_TIMEOUT
     81          #define HSI_TIMEOUT_VALUE          ((uint32_t)100)  /* 100 ms */
     82          #define LSI_TIMEOUT_VALUE          ((uint32_t)100)  /* 100 ms */
     83          #define PLL_TIMEOUT_VALUE          ((uint32_t)100)  /* 100 ms */
     84          #define HSI48_TIMEOUT_VALUE        ((uint32_t)100)  /* 100 ms */
     85          #define MSI_TIMEOUT_VALUE          ((uint32_t)100)  /* 100 ms */    
     86          #define CLOCKSWITCH_TIMEOUT_VALUE  ((uint32_t)5000) /* 5 s    */
     87          
     88          /* Private macro -------------------------------------------------------------*/
     89          #define __MCO1_CLK_ENABLE()   __GPIOA_CLK_ENABLE()
     90          #define MCO1_GPIO_PORT        GPIOA
     91          #define MCO1_PIN              GPIO_PIN_8
     92          #define MCO2_PIN              GPIO_PIN_9
     93          
     94          /* Private variables ---------------------------------------------------------*/
     95          static __IO const uint8_t PLLMulTable[9] = {3, 4, 6, 8, 12, 16, 24, 32, 48};
     96          static __IO const uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
     97          const uint32_t MSIRangeTable[7] = {64000, 128000, 256000, 512000, 1000000, 2000000, 4000000};
     98          
     99          /* Private function prototypes -----------------------------------------------*/
    100          /* Private functions ---------------------------------------------------------*/
    101          
    102          /** @defgroup RCC_Private_Functions
    103            * @{
    104            */
    105          
    106          /** @defgroup RCC_Group1 Initialization and de-initialization functions 
    107           *  @brief    Initialization and Configuration functions 
    108           *
    109          @verbatim    
    110           ===============================================================================
    111                     ##### Initialization and de-initialization functions #####
    112           ===============================================================================
    113             [..] 
    114                This section provide functions allowing to configure the internal/external 
    115                   clocks, PLL, CSS and MCO.
    116             [..] Internal/external clock and PLL configuration
    117                   (#) HSI (high-speed internal), 16 MHz factory-trimmed RC used directly 
    118                       or through the PLL as System clock source.
    119                   (#) MSI (multi-speed internal), multispeed low power RC 
    120                       (65.536 KHz to 4.194 MHz) MHz used as System clock source.
    121                   (#) LSI (low-speed internal), 37 KHz low consumption RC used as IWDG 
    122                       and/or RTC clock source.
    123                   (#) HSE (high-speed external), 1 to 24 MHz crystal oscillator used 
    124                       directly or through the PLL as System clock source. Can be used 
    125                       also as RTC clock source.
    126                   (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.
    127                   (#) PLL (clocked by HSI or HSE), for System clock and USB (48 MHz).
    128                   (#) CSS (Clock security system), once enable and if a HSE clock failure 
    129                       occurs (HSE used directly or through PLL as System clock source), 
    130                       the System clock is automatically switched to MSI and an interrupt 
    131                       is generated if enabled. 
    132                       The interrupt is linked to the Cortex-M3 NMI (Non-Maskable Interrupt) 
    133                       exception vector.
    134                   (#) MCO (microcontroller clock output), used to output SYSCLK, HSI, MSI, 
    135                       HSE, PLL, LSI or LSE clock (through a configurable prescaler) on 
    136                       PA8 pin.
    137           [..] System, AHB and APB busses clocks configuration  
    138                   (#) Several clock sources can be used to drive the System clock (SYSCLK): MSI, HSI,
    139                       HSE and PLL.
    140                       The AHB clock (HCLK) is derived from System clock through configurable 
    141                       prescaler and used to clock the CPU, memory and peripherals mapped 
    142                       on IOPORT, AHB bus (DMA,Flash...). APB1 (PCLK1) and APB2 (PCLK2) clocks are derived 
    143                       from AHB clock through configurable prescalers and used to clock 
    144                       the peripherals mapped on these busses. You can use 
    145                       "HAL_RCC_GetSysClockFreq()" function to retrieve the frequencies of these clocks.  
    146          
    147                   -@- All the peripheral clocks are derived from the System clock (SYSCLK) except:
    148                     (+@) I2S: the I2S clock can be derived from an external clock mapped on the I2S_CKIN pin. 
    149                        
    150                     (+@) RTC: the RTC clock can be derived either from the LSI, LSE or HSE clock
    151                          divided by 2 to 16. You have to use __HAL_RCC_RTC_CONFIG() and __HAL_RCC_RTC_ENABLE()
    152                          macros to configure this clock. 
    153                     (+@) USB FS,and RNG  require a frequency equal to 48 MHz to work correctly
    154                          This clock is derived from the main PLL or HSI48 RC oscillator.
    155                     (+@) IWDG clock which is always the LSI clock.
    156                 
    157                   (#) For the STM32L0xx devices, the maximum
    158                       frequency of the SYSCLK ,HCLK, APB1 and APB2 is 32 MHz. 
    159                       Depending on the device voltage range, the maximum frequency should
    160                       be adapted accordingly:
    161           ----------------------------------------------------------------
    162           |  Wait states  |                HCLK clock frequency (MHz)      |
    163           |               |------------------------------------------------|
    164           |   (Latency)   |            voltage range       | voltage range |
    165           |               |            1.65 V - 3.6 V      | 2.0 V - 3.6 V |
    166           |               |----------------|---------------|---------------|
    167           |               |  VCORE = 1.2 V | VCORE = 1.5 V | VCORE = 1.8 V |
    168           |-------------- |----------------|---------------|---------------|
    169           |0WS(1CPU cycle)|0 < HCLK <= 2   |0 < HCLK <= 8  |0 < HCLK <= 16 |
    170           |---------------|----------------|---------------|---------------|
    171           |1WS(2CPU cycle)|2 < HCLK <= 4   |8 < HCLK <= 16 |16 < HCLK <= 32|
    172            ----------------------------------------------------------------
    173          @endverbatim
    174            * @{
    175            */
    176          
    177          /**
    178            * @brief  Resets the RCC clock configuration to the default reset state.
    179            * @note   The default reset state of the clock configuration is given below:
    180            *           - MSI ON and used as system clock source (MSI range is not modified
    181            *           - by this function, it keep the value configured by user application)
    182            *           - HSI, HSE and PLL OFF
    183            *           - AHB, APB1 and APB2 prescaler set to 1.
    184            *           - CSS and MCO OFF
    185            *           - All interrupts disabled
    186            * @note   This function doesn't modify the configuration of the
    187            * @note      -Peripheral clocks
    188            * @note      -HSI48, LSI, LSE and RTC clocks                  
    189            * @param  None
    190            * @retval None
    191            */
    192          void HAL_RCC_DeInit(void)
    193          {
    194            /* Set MSION bit */
    195            SET_BIT(RCC->CR, RCC_CR_MSION); 
    196            
    197            /* Reset HSION, HSEON, CSSON, PLLON */
    198            CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSION| RCC_CR_HSIKERON| RCC_CR_CSSHSEON | RCC_CR_PLLON); 
    199            
    200            /* Reset CFGR register */
    201            CLEAR_REG(RCC->CFGR);
    202            
    203            /* Reset HSEBYP bit */
    204            CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
    205            
    206            /* Disable all interrupts */
    207            CLEAR_REG(RCC->CIER); 
    208          }
    209          
    210          /**
    211            * @brief  Initializes the RCC Oscillators according to the specified parameters in the
    212            *         RCC_OscInitTypeDef.
    213            * @param  RCC_OscInitStruct: pointer to an RCC_OscInitTypeDef structure that
    214            *         contains the configuration information for the RCC Oscillators.
    215            * @note   The PLL is not disabled when used as system clock.
    216            * @retval HAL status
    217            */
    218          HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
    219          {
    220          
    221             uint32_t tickstart = 0;   
    222           
    223            /* Check the parameters */
    224            assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
    225            /*------------------------------- HSE Configuration ------------------------*/ 
    226            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
    227            {
    228              /* Check the parameters */
    229              assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    230              /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    231              if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->CFGR & RCC_CFGR_PLLSRC) == RCC_CFGR_PLLSRC_HSE)))
    232              {
    233                if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState != RCC_HSE_ON))
    234                {
    235                  return HAL_ERROR;
    236                }
    237              }
    238              else
    239              {
    240                /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
    241                __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
    242                
    243                /* Get timeout */
    244                tickstart = HAL_GetTick();
    245              
    246                /* Wait till HSE is disabled */  
    247                while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
    248                {
    249                  if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
    250                  {
    251                    return HAL_TIMEOUT;
    252                  }      
    253                }
    254                
    255                /* Set the new HSE configuration ---------------------------------------*/
    256                __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
    257                
    258                /* Check the HSE State */
    259                if((RCC_OscInitStruct->HSEState) == RCC_HSE_ON)
    260                {
    261                  /* Get timeout */
    262                  tickstart = HAL_GetTick();
    263                
    264                  /* Wait till HSE is ready */  
    265                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
    266                  {
    267                    if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
    268                    {
    269                      return HAL_TIMEOUT;
    270                    }      
    271                  }      
    272                }
    273                else
    274                {
    275                  /* Get timeout */
    276                  tickstart = HAL_GetTick();
    277                
    278                  /* Wait till HSE is  bypassed or disabled */  
    279                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
    280                  {
    281                     if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
    282                    {
    283                      return HAL_TIMEOUT;
    284                    }      
    285                  }
    286                }
    287              }
    288            }
    289            /*----------------------------- HSI Configuration --------------------------*/ 
    290            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
    291            {
    292              /* Check the parameters */
    293              assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    294              assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    295              
    296              /* When the HSI is used as system clock it will not disabled */
    297              if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->CFGR & RCC_CFGR_PLLSRC) == RCC_CFGR_PLLSRC_HSI)))
    298              {
    299                /* When HSI is used as system clock it will not disabled */
    300                if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
    301                {
    302                  return HAL_ERROR;
    303                }
    304                /* Otherwise, just the calibration is allowed */
    305                else
    306                {
    307                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
    308                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
    309                }
    310              }
    311              else
    312              {
    313                /* Check the HSI State */
    314                if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
    315                {
    316                  /* Enable the Internal High Speed oscillator (HSI or HSIdiv4 */
    317                  __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
    318                  
    319                  /* Get Start Tick*/
    320                  tickstart = HAL_GetTick();
    321                
    322                  /* Wait till HSI is ready */  
    323                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
    324                  {
    325                    if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
    326                    {
    327                      return HAL_TIMEOUT;
    328                    }      
    329                  } 
    330                          
    331                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
    332                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
    333                }
    334                else
    335                {
    336                  /* Disable the Internal High Speed oscillator (HSI). */
    337                  __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
    338                 
    339                  /* Get Start Tick*/
    340                  tickstart = HAL_GetTick();
    341                
    342                  /* Wait till HSI is ready */  
    343                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
    344                  {
    345                    if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
    346                    {
    347                      return HAL_TIMEOUT;
    348                    }      
    349                  } 
    350                }
    351              }
    352            }
    353             /*----------------------------- MSI Configuration --------------------------*/ 
    354            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
    355            {
    356              /* Check the parameters */
    357              assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    358              assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    359              
    360                  
    361              /* When the MSI is used as system clock it will not disabled */
    362              if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
    363              {
    364                if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState != RCC_MSI_ON))
    365                {
    366                  return HAL_ERROR;
    367                }
    368                
    369                 /* Otherwise, just the calibration and MSI range change are allowed */
    370                else
    371                {
    372                 /* Selects the Multiple Speed oscillator (MSI) clock range .*/
    373                  __HAL_RCC_MSI_RANGE_CONFIG (RCC_OscInitStruct->MSIClockRange);   
    374                  /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
    375                  __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
    376                }
    377              }
    378              else
    379              {
    380                /* Check the MSI State */
    381                if((RCC_OscInitStruct->MSIState)!= RCC_MSI_OFF)
    382                {
    383                  /* Enable the Internal High Speed oscillator (MSI). */
    384                  __HAL_RCC_MSI_ENABLE();
    385                  
    386                  /* Get timeout */
    387                  tickstart = HAL_GetTick();
    388                
    389                  /* Wait till MSI is ready */  
    390                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
    391                  {
    392                    if((HAL_GetTick() - tickstart ) > MSI_TIMEOUT_VALUE)
    393                    {
    394                      return HAL_TIMEOUT;
    395                    }      
    396                  } 
    397                   /* Selects the Multiple Speed oscillator (MSI) clock range .*/
    398                  __HAL_RCC_MSI_RANGE_CONFIG (RCC_OscInitStruct->MSIClockRange);   
    399                   /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
    400                  __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
    401                  
    402                }
    403                else
    404                {
    405                  /* Disable the Internal High Speed oscillator (MSI). */
    406                  __HAL_RCC_MSI_DISABLE();
    407                  
    408                  /* Get timeout */
    409                  tickstart = HAL_GetTick();
    410                
    411                  /* Wait till MSI is ready */  
    412                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != RESET)
    413                  {
    414                    if((HAL_GetTick() - tickstart ) > MSI_TIMEOUT_VALUE)
    415                    {
    416                      return HAL_TIMEOUT;
    417                    }      
    418                  } 
    419                }
    420              }
    421            }
    422            /*------------------------------ LSI Configuration -------------------------*/ 
    423            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
    424            {
    425              /* Check the parameters */
    426              assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    427              
    428              /* Check the LSI State */
    429              if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
    430              {
    431                /* Enable the Internal Low Speed oscillator (LSI). */
    432                __HAL_RCC_LSI_ENABLE();
    433                
    434                /* Get timeout */
    435                tickstart = HAL_GetTick();
    436                
    437                /* Wait till LSI is ready */  
    438                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
    439                {
    440                  if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
    441                  {
    442                    return HAL_TIMEOUT;
    443                  }      
    444                } 
    445              }
    446              else
    447              {
    448                /* Disable the Internal Low Speed oscillator (LSI). */
    449                __HAL_RCC_LSI_DISABLE();
    450                
    451                /* Get timeout */
    452                tickstart = HAL_GetTick();
    453                
    454                /* Wait till LSI is ready */  
    455                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
    456                {
    457                  if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
    458                  {
    459                    return HAL_TIMEOUT;
    460                  }      
    461                } 
    462              }
    463            }
    464            
    465            
    466             /*------------------------------ HSI48 Configuration -------------------------*/ 
    467            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
    468            {
    469              /* Check the parameters */
    470              assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
    471              
    472              /* Check the HSI48 State */
    473              if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
    474              {
    475                /* Enable the Internal Low Speed oscillator (HSI48). */
    476                __HAL_RCC_HSI48_ENABLE();
    477                
    478                /* Get timeout */
    479                tickstart = HAL_GetTick();
    480                
    481                /* Wait till HSI48 is ready */  
    482                while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == RESET)
    483                {
    484                  if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
    485                  {
    486                    return HAL_TIMEOUT;
    487                  }      
    488                } 
    489              }
    490              else
    491              {
    492                /* Disable the Internal Low Speed oscillator (HSI48). */
    493                __HAL_RCC_HSI48_DISABLE();
    494                
    495                /* Get timeout */
    496                tickstart = HAL_GetTick();
    497                
    498                /* Wait till HSI48 is ready */  
    499                while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET)
    500                {
    501                  if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
    502                  {
    503                    return HAL_TIMEOUT;
    504                  }      
    505                } 
    506              }
    507            }
    508            /*------------------------------ LSE Configuration -------------------------*/ 
    509            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
    510            {
    511              /* Check the parameters */
    512              assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    513          
    514              /* Enable Power Clock*/
    515              __PWR_CLK_ENABLE();
    516          
    517              /* Enable write access to Backup domain */
    518              PWR->CR |= PWR_CR_DBP;
    519          
    520              /* Wait for Backup domain Write protection disable */
    521              tickstart = HAL_GetTick();
    522           
    523              while((PWR->CR & PWR_CR_DBP) == RESET)
    524              {
    525                if((HAL_GetTick() - tickstart ) > DBP_TIMEOUT_VALUE)
    526                {
    527                  return HAL_TIMEOUT;
    528                }
    529              }
    530          
    531              /* Reset LSEON and LSEBYP bits before configuring the LSE ----------------*/
    532              __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
    533              
    534              /* Get timeout */
    535              tickstart = HAL_GetTick();
    536                
    537              /* Wait till LSE is ready */  
    538              while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
    539              {
    540                if((HAL_GetTick() - tickstart ) > LSE_TIMEOUT_VALUE)
    541                {
    542                  return HAL_TIMEOUT;
    543                }      
    544              } 
    545              
    546              /* Set the new LSE configuration -----------------------------------------*/
    547              __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    548              /* Check the LSE State */
    549              if((RCC_OscInitStruct->LSEState) == RCC_LSE_ON)
    550              {     
    551                /* Get timeout */
    552                tickstart = HAL_GetTick();
    553                
    554                /* Wait till LSE is ready */  
    555                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
    556                {
    557                  if((HAL_GetTick() - tickstart ) > LSE_TIMEOUT_VALUE)
    558                  {
    559                    return HAL_TIMEOUT;
    560                  }      
    561                }
    562              }
    563              else
    564              {
    565                /* Get timeout */
    566                tickstart = HAL_GetTick();
    567                
    568                /* Wait till LSE is ready */  
    569                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
    570                {
    571                  if((HAL_GetTick() - tickstart ) > LSE_TIMEOUT_VALUE)
    572                  {
    573                    return HAL_TIMEOUT;
    574                  }      
    575                }
    576              }
    577            }
    578            /*-------------------------------- PLL Configuration -----------------------*/
    579            /* Check the parameters */
    580            assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
    581            if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
    582            {
    583              /* Check if the PLL is used as system clock or not */
    584              if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    585              { 
    586                if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
    587                {
    588                  /* Check the parameters */
    589                  assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
    590                  assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
    591                  assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));
    592                  
    593                  
    594                  /* Disable the main PLL. */
    595                  __HAL_RCC_PLL_DISABLE();
    596                  
    597                  /* Get timeout */
    598                  tickstart = HAL_GetTick();
    599                
    600                  /* Wait till PLL is ready */  
    601                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
    602                  {
    603                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
    604                    {
    605                      return HAL_TIMEOUT;
    606                    }      
    607                  }        
    608          
    609                  /* Configure the main PLL clock source, multiplication and division factors. */
    610                  __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
    611                                       RCC_OscInitStruct->PLL.PLLMUL,
    612                                       RCC_OscInitStruct->PLL.PLLDIV);
    613                  /* Enable the main PLL. */
    614                  __HAL_RCC_PLL_ENABLE();
    615          
    616                  /* Get timeout */
    617                  tickstart = HAL_GetTick();
    618                
    619                  /* Wait till PLL is ready */  
    620                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
    621                  {
    622                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
    623                    {
    624                      return HAL_TIMEOUT;
    625                    }      
    626                  }
    627                }
    628                else
    629                {
    630                  /* Disable the main PLL. */
    631                  __HAL_RCC_PLL_DISABLE();       
    632                  /* Get timeout */
    633                  tickstart = HAL_GetTick();
    634                
    635                  /* Wait till PLL is ready */  
    636                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
    637                  {
    638                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
    639                    {
    640                      return HAL_TIMEOUT;
    641                    }      
    642                  }
    643                }
    644              }
    645              else
    646              {
    647                return HAL_ERROR;
    648              }
    649            }
    650            return HAL_OK;
    651          }
    652           
    653          /**
    654            * @brief  Initializes the CPU, AHB and APB busses clocks according to the specified 
    655            *         parameters in the RCC_ClkInitStruct.
    656            * @param  RCC_ClkInitStruct: pointer to an RCC_OscInitTypeDef structure that
    657            *         contains the configuration information for the RCC peripheral.
    658            * @param  FLatency: FLASH Latency, this parameter depends on System Clock Frequency
    659            * 
    660            * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
    661            *         and updated by HAL_RCC_GetHCLKFreq() function called within this function
    662            *                 
    663            * @note   The MSI is used (enabled by hardware) as system clock source after
    664            *         startup from Reset, wake-up from STOP and STANDBY mode, or in case
    665            *         of failure of the HSE used directly or indirectly as system clock
    666            *         (if the Clock Security System CSS is enabled).
    667            *           
    668            * @note   A switch from one clock source to another occurs only if the target
    669            *         clock source is ready (clock stable after startup delay or PLL locked). 
    670            *         If a clock source which is not yet ready is selected, the switch will
    671            *         occur when the clock source will be ready. 
    672            * @retval None
    673            */
    674          HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
    675          {
    676          
    677            uint32_t tickstart = 0;
    678           
    679            /* Check the parameters */
    680            assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
    681            assert_param(IS_FLASH_LATENCY(FLatency));
    682           
    683            /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    684              must be correctly programmed according to the frequency of the CPU clock 
    685              (HCLK) and the supply voltage of the device. */
    686            
    687            /* Increasing the CPU frequency */
    688            if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
    689            {    
    690              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    691              __HAL_FLASH_SET_LATENCY(FLatency);
    692              
    693              /* Check that the new number of wait states is taken into account to access the Flash
    694              memory by reading the FLASH_ACR register */
    695              if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
    696              {
    697                return HAL_ERROR;
    698              }
    699          
    700              /*-------------------------- HCLK Configuration --------------------------*/
    701              if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
    702              {
    703                assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    704                MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
    705              }
    706          
    707              /*------------------------- SYSCLK Configuration ---------------------------*/ 
    708              if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
    709              {    
    710                assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    711                
    712                /* HSE is selected as System Clock Source */
    713                if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    714                {
    715                  /* Check the HSE ready flag */  
    716                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
    717                  {
    718                    return HAL_ERROR;
    719                  }
    720                }
    721                
    722                    /* MSI is selected as System Clock Source */
    723                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
    724                {
    725                  /* Check the MSI ready flag */  
    726                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
    727                  {
    728                    return HAL_ERROR;
    729                  }
    730                }
    731                /* PLL is selected as System Clock Source */
    732                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
    733                {
    734                  /* Check the PLL ready flag */  
    735                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
    736                  {
    737                    return HAL_ERROR;
    738                  }
    739                }
    740                /* HSI is selected as System Clock Source */
    741                else
    742                {
    743                  /* Check the HSI ready flag */  
    744                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
    745                  {
    746                    return HAL_ERROR;
    747                  }
    748                }
    749                MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
    750           
    751                /* Get timeout */
    752                tickstart = HAL_GetTick();
    753                
    754                if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    755                {
    756                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
    757                  {
    758                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
    759                    {
    760                      return HAL_TIMEOUT;
    761                    } 
    762                  }
    763                }
    764                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
    765                {
    766                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    767                  {
    768                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
    769                    {
    770                      return HAL_TIMEOUT;
    771                    } 
    772                  }
    773                }
    774                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
    775                {
    776                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
    777                  {
    778                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
    779                    {
    780                      return HAL_TIMEOUT;
    781                    } 
    782                  }
    783                }
    784                else
    785                {
    786                  while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
    787                  {
    788                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
    789                    {
    790                      return HAL_TIMEOUT;
    791                    }
    792                  }
    793                }
    794              }    
    795            }
    796            /* Decreasing the CPU frequency */
    797            else
    798            {
    799              /*-------------------------- HCLK Configuration --------------------------*/
    800              if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
    801              {
    802                assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    803                MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
    804              }
    805          
    806              /*------------------------- SYSCLK Configuration -------------------------*/
    807              if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
    808              {    
    809                assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    810                
    811                /* HSE is selected as System Clock Source */
    812                if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    813                {
    814                  /* Check the HSE ready flag */  
    815                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
    816                  {
    817                    return HAL_ERROR;
    818                  }
    819                }
    820          
    821                /* MSI is selected as System Clock Source */
    822                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
    823                {
    824                  /* Check the MSI ready flag */  
    825                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == RESET)
    826                  {
    827                    return HAL_ERROR;
    828                  }
    829                }
    830                /* PLL is selected as System Clock Source */
    831                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
    832                {
    833                  /* Check the PLL ready flag */  
    834                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
    835                  {
    836                    return HAL_ERROR;
    837                  }
    838                }
    839                /* HSI is selected as System Clock Source */
    840                else
    841                {
    842                  /* Check the HSI ready flag */  
    843                  if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
    844                  {
    845                    return HAL_ERROR;
    846                  }
    847                }
    848                MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
    849                
    850                /* Get timeout */
    851                tickstart = HAL_GetTick();
    852                
    853                if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    854                {
    855                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSE)
    856                  {
    857                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
    858                    {
    859                      return HAL_TIMEOUT;
    860                    } 
    861                  }
    862                }
    863                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
    864                {
    865                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    866                  {
    867                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
    868                    {
    869                      return HAL_TIMEOUT;
    870                    } 
    871                  }
    872                }
    873                else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
    874                {
    875                  while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_MSI)
    876                  {
    877                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
    878                    {
    879                      return HAL_TIMEOUT;
    880                    } 
    881                  }
    882                }
    883                else
    884                {
    885                  while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_HSI)
    886                  {
    887                    if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
    888                    {
    889                      return HAL_TIMEOUT;
    890                    }  
    891                  }
    892                }
    893              }
    894              
    895              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    896              __HAL_FLASH_SET_LATENCY(FLatency);
    897              
    898              /* Check that the new number of wait states is taken into account to access the Flash
    899              memory by reading the FLASH_ACR register */
    900              if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
    901              {
    902                return HAL_ERROR;
    903              }
    904           }
    905          
    906            /*-------------------------- PCLK1 Configuration ---------------------------*/ 
    907            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
    908            {
    909              assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    910              MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
    911            }
    912            
    913            /*-------------------------- PCLK2 Configuration ---------------------------*/ 
    914            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
    915            {
    916              assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    917              MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
    918            }
    919          
    920            /* Configure the source of time base considering new system clocks settings*/
    921            HAL_InitTick (TICK_INT_PRIORITY);
    922            
    923            return HAL_OK;
    924          }
    925          
    926          /**
    927            * @}
    928            */
    929          
    930          /** @defgroup RCC_Group2 Peripheral Control functions 
    931           *  @brief   RCC clocks control functions 
    932           *
    933          @verbatim   
    934           ===============================================================================
    935                                ##### Peripheral Control functions #####
    936           ===============================================================================  
    937              [..]
    938              This subsection provides a set of functions allowing to control the RCC Clocks 
    939              frequencies.
    940                
    941          @endverbatim
    942            * @{
    943            */
    944          
    945          /**
    946            * @brief  Selects the clock source to output on MCO pin.
    947            * @note   MCO pin should be configured in alternate function mode.
    948            * @param  RCC_MCOx: specifies the output direction for the clock source.
    949            *           For STM32L0xx family this parameter can have only one value:
    950            *            @arg RCC_MCO1: Clock source to output on MCO pin(PA8).
    951            *            @arg RCC_MCO2: Clock source to output on MCO pin(PA9).
    952            * @param  RCC_MCOSource: specifies the clock source to output.
    953            *          This parameter can be one of the following values:
    954            *     @arg RCC_MCO1SOURCE_NOCLOCK: No clock selected
    955            *     @arg RCC_MCO1SOURCE_SYSCLK: System clock selected
    956            *     @arg RCC_MCO1SOURCE_HSI: HSI oscillator clock selected
    957            *     @arg RCC_MCO1SOURCE_MSI: MSI oscillator clock selected  
    958            *     @arg RCC_MCO1SOURCE_HSE: HSE oscillator clock selected
    959            *     @arg RCC_MCO1SOURCE_PLLCLK: PLL clock selected
    960            *     @arg RCC_MCO1SOURCE_LSI: LSI clock selected
    961            *     @arg RCC_MCO1SOURCE_LSE: LSE clock selected    
    962            *     @arg RCC_MCO1SOURCE_HSI48: HSI48 clock selected
    963            * @param  RCC_MCODIV: specifies the MCO DIV.
    964            *     This parameter can be one of the following values: 
    965            *     @arg RCC_MCODIV_1: no division applied to MCO clock 
    966            *     @arg RCC_MCODIV_2: division by 2 applied to MCO clock
    967            *     @arg RCC_MCODIV_4: division by 4 applied to MCO clock
    968            *     @arg RCC_MCODIV_8: division by 8 applied to MCO clock
    969            *     @arg RCC_MCODIV_16: division by 16 applied to MCO clock        
    970            * @retval None
    971            */
    972          void HAL_RCC_MCOConfig( uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
    973          {
    974            GPIO_InitTypeDef GPIO_InitStruct;
    975            /* Check the parameters */
    976            assert_param(IS_RCC_MCO(RCC_MCOx));
    977            assert_param(IS_RCC_MCODIV(RCC_MCODiv));
    978            assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
    979              
    980              /* MCO Clock Enable */
    981              __MCO1_CLK_ENABLE();
    982              
    983              /* Configure the MCO1 pin in alternate function mode */    
    984            if(RCC_MCOx == RCC_MCO1)
    985            {    
    986              GPIO_InitStruct.Pin = MCO1_PIN;
    987            }
    988              else
    989            {    
    990              GPIO_InitStruct.Pin = MCO2_PIN;
    991            }    
    992              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    993              GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
    994              GPIO_InitStruct.Pull = GPIO_NOPULL;
    995              GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
    996              HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
    997              
    998              /* Mask MCO1 and MCO1PRE[2:0] bits then Select MCO1 clock source and prescaler */
    999              MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCOSEL | RCC_CFGR_MCO_PRE), ((RCC_MCOSource << 24 | RCC_MCODiv )));
   1000          }
   1001          
   1002          /**
   1003            * @brief  Enables the Clock Security System.
   1004            * @note   If a failure is detected on the HSE oscillator clock, this oscillator
   1005            *         is automatically disabled and an interrupt is generated to inform the
   1006            *         software about the failure (Clock Security System Interrupt, CSSI),
   1007            *         allowing the MCU to perform rescue operations. The CSSI is linked to 
   1008            *         the Cortex-M0+ NMI (Non-Maskable Interrupt) exception vector.  
   1009            * @param  None
   1010            * @retval None
   1011            */
   1012          void HAL_RCC_EnableCSS(void)
   1013          {
   1014             SET_BIT(RCC->CR, RCC_CR_CSSHSEON) ;
   1015          }
   1016          
   1017          
   1018          /**
   1019            * @brief  Returns the SYSCLK frequency
   1020            *        
   1021            * @note   The system frequency computed by this function is not the real 
   1022            *         frequency in the chip. It is calculated based on the predefined 
   1023            *         constant and the selected clock source:
   1024            * @note     If SYSCLK source is MSI, function returns values based on MSI
   1025            *             Value as defined by the MSI range.
   1026            * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)
   1027            * @note     If SYSCLK source is HSE, function returns values based on HSE_VALUE(**)
   1028            * @note     If SYSCLK source is PLL, function returns values based on HSE_VALUE(**) 
   1029            *           or HSI_VALUE(*) multiplied/divided by the PLL factors.         
   1030            * @note     (*) HSI_VALUE is a constant defined in stm32l0xx_hal_conf.h file (default value
   1031            *               16 MHz) but the real value may vary depending on the variations
   1032            *               in voltage and temperature.
   1033            * @note     (**) HSE_VALUE is a constant defined in stm32l0xx_hal_conf.h file (default value
   1034            *                8 MHz), user has to ensure that HSE_VALUE is same as the real
   1035            *                frequency of the crystal used. Otherwise, this function may
   1036            *                have wrong result.
   1037            *                  
   1038            * @note   The result of this function could be not correct when using fractional
   1039            *         value for HSE crystal.
   1040            *           
   1041            * @note   This function can be used by the user application to compute the 
   1042            *         baudrate for the communication peripherals or configure other parameters.
   1043            *           
   1044            * @note   Each time SYSCLK changes, this function must be called to update the
   1045            *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
   1046            *         
   1047            *               
   1048            * @param  None
   1049            * @retval SYSCLK frequency
   1050            */
   1051          uint32_t HAL_RCC_GetSysClockFreq(void)
   1052          {
   1053            uint32_t pllmul = 0, plldiv = 0, pllsource = 0,  msirange = 0;
   1054            uint32_t sysclockfreq = 0;
   1055              
   1056            /* Get SYSCLK source -------------------------------------------------------*/
   1057           
   1058            /*MSI frequency range in HZ*/
   1059            msirange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE) >> 13;
   1060            msirange = MSIRangeTable[msirange];
   1061            
   1062            switch (RCC->CFGR & RCC_CFGR_SWS)
   1063            {
   1064              case RCC_CFGR_SWS_MSI: /* MSI used as system clock */ 
   1065              {  
   1066                sysclockfreq = msirange;
   1067                break;
   1068              }
   1069              case RCC_CFGR_SWS_HSI:  /* HSI used as system clock */
   1070              {
   1071                if ((RCC->CR & RCC_CR_HSIDIVF) != 0)
   1072                {
   1073                  sysclockfreq =  (HSI_VALUE >> 2);
   1074                }
   1075                else 
   1076                {
   1077                  sysclockfreq =  HSI_VALUE;
   1078                }
   1079                break;
   1080              }
   1081              case RCC_CFGR_SWS_HSE:  /* HSE used as system clock */
   1082              {
   1083                sysclockfreq = HSE_VALUE;
   1084                break;
   1085              }
   1086              case RCC_CFGR_SWS_PLL:  /* PLL used as system clock */
   1087              {
   1088                /* Get PLL clock source and multiplication factor ----------------------*/
   1089                pllmul = RCC->CFGR & RCC_CFGR_PLLMUL;
   1090                plldiv = RCC->CFGR & RCC_CFGR_PLLDIV;
   1091                pllmul = PLLMulTable[(pllmul >> 18)];
   1092                plldiv = (plldiv >> 22) + 1;
   1093                
   1094                pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
   1095          
   1096                if (pllsource == RCC_CFGR_PLLSRC_HSI)
   1097                {
   1098                  /* HSI oscillator clock selected as PLL clock source */
   1099                  sysclockfreq =(((HSI_VALUE) * pllmul) / plldiv);
   1100                }
   1101                else
   1102                {
   1103                  /* HSE selected as PLL clock source */
   1104                 sysclockfreq = (((HSE_VALUE) * pllmul) / plldiv);
   1105                }
   1106                break;
   1107              }
   1108              default: /* MSI used as system clock */
   1109              {
   1110                sysclockfreq =  msirange;
   1111                break;
   1112              }
   1113            }
   1114            return sysclockfreq;
   1115          }
   1116          
   1117          /**
   1118            * @brief  Returns the HCLK frequency     
   1119            * @note   Each time HCLK changes, this function must be called to update the
   1120            *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
   1121            *
   1122            * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
   1123            *         and updated within this function                   
   1124            * @param  None
   1125            * @retval HCLK frequency
   1126            */
   1127          uint32_t HAL_RCC_GetHCLKFreq(void)
   1128          {
   1129            SystemCoreClock =  HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
   1130            
   1131            return (SystemCoreClock);
   1132          
   1133          }
   1134          
   1135          /**
   1136            * @brief  Returns the PCLK1 frequency     
   1137            * @note   Each time PCLK1 changes, this function must be called to update the
   1138            *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
   1139            * @param  None
   1140            * @retval PCLK1 frequency
   1141            */
   1142          uint32_t HAL_RCC_GetPCLK1Freq(void)
   1143          {
   1144            
   1145           return ( HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[((RCC->CFGR & RCC_CFGR_PPRE1) >> 8)]);
   1146            
   1147          }    
   1148          
   1149          /**
   1150            * @brief  Returns the PCLK2 frequency     
   1151            * @note   Each time PCLK2 changes, this function must be called to update the
   1152            *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
   1153            * @param  None
   1154            * @retval PCLK2 frequency
   1155            */
   1156          uint32_t HAL_RCC_GetPCLK2Freq(void)
   1157          {
   1158            
   1159            return ( HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[((RCC->CFGR & RCC_CFGR_PPRE2) >> 11)]);
   1160            
   1161          } 
   1162          
   1163          /**
   1164            * @brief  Configures the RCC_OscInitStruct according to the internal 
   1165            * RCC configuration registers.
   1166            * @param  RCC_OscInitStruct: pointer to an RCC_OscInitTypeDef structure that 
   1167            * will be configured.
   1168            * @retval None
   1169            */
   1170          void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
   1171          {
   1172            /* Set all possible values for the Oscillator type parameter ---------------*/
   1173            RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_MSI | RCC_OSCILLATORTYPE_HSI | \
   1174                                                RCC_OSCILLATORTYPE_HSI48 | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
   1175            
   1176            /* Get the HSE configuration -----------------------------------------------*/
   1177            if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
   1178            {
   1179              RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
   1180            }
   1181            else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
   1182            {
   1183              RCC_OscInitStruct->HSEState = RCC_HSE_ON;
   1184            }
   1185            else
   1186            {
   1187              RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
   1188            }
   1189            
   1190            /* Get the MSI configuration -----------------------------------------------*/
   1191            if((RCC->CR &RCC_CR_MSION) == RCC_CR_MSION)
   1192            {
   1193              RCC_OscInitStruct->MSIState = RCC_MSI_ON;
   1194            }
   1195            else
   1196            {
   1197              RCC_OscInitStruct->MSIState = RCC_MSI_OFF;
   1198            }
   1199            
   1200            RCC_OscInitStruct->MSICalibrationValue = (uint32_t)((RCC->CR &RCC_ICSCR_MSITRIM) >> 24); 
   1201            RCC_OscInitStruct->MSIClockRange = (uint32_t)((RCC->ICSCR &RCC_ICSCR_MSIRANGE) >> 13); 
   1202            
   1203            /* Get the HSI48 configuration -----------------------------------------------*/
   1204            if((RCC->CRRCR &RCC_CRRCR_HSI48ON) == RCC_CRRCR_HSI48ON)
   1205            {
   1206              RCC_OscInitStruct->HSI48State = RCC_HSI48_ON;
   1207            }
   1208            else
   1209            {
   1210              RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;
   1211            }
   1212            
   1213            /* Get the HSI configuration -----------------------------------------------*/
   1214            if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
   1215            {
   1216              RCC_OscInitStruct->HSIState = RCC_HSI_ON;
   1217            }
   1218            else
   1219            {
   1220              RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
   1221            }
   1222            
   1223            RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->ICSCR &RCC_ICSCR_HSITRIM) >> 8);
   1224            
   1225            /* Get the LSE configuration -----------------------------------------------*/
   1226            if((RCC->CSR &RCC_CSR_LSEBYP) == RCC_CSR_LSEBYP)
   1227            {
   1228              RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
   1229            }
   1230            else if((RCC->CSR &RCC_CSR_LSEON) == RCC_CSR_LSEON)
   1231            {
   1232              RCC_OscInitStruct->LSEState = RCC_LSE_ON;
   1233            }
   1234            else
   1235            {
   1236              RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
   1237            }
   1238            
   1239            /* Get the LSI configuration -----------------------------------------------*/
   1240            if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
   1241            {
   1242              RCC_OscInitStruct->LSIState = RCC_LSI_ON;
   1243            }
   1244            else
   1245            {
   1246              RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
   1247            }
   1248            
   1249            /* Get the PLL configuration -----------------------------------------------*/
   1250            if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
   1251            {
   1252              RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
   1253            }
   1254            else
   1255            {
   1256              RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
   1257            }
   1258            RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLSRC);
   1259            RCC_OscInitStruct->PLL.PLLMUL = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLMUL) >> 18;
   1260            RCC_OscInitStruct->PLL.PLLDIV = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLDIV) >> 22;
   1261          
   1262          }
   1263          
   1264          /**
   1265            * @brief  Configures the RCC_ClkInitStruct according to the internal 
   1266            * RCC configuration registers.
   1267            * @param  RCC_OscInitStruct: pointer to an RCC_ClkInitTypeDef structure that 
   1268            * will be configured.
   1269            * @param  pFLatency: Pointer on the Flash Latency.
   1270            * @retval None
   1271            */
   1272          void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
   1273          {
   1274            /* Set all possible values for the Clock type parameter --------------------*/
   1275            RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
   1276             
   1277            /* Get the SYSCLK configuration --------------------------------------------*/ 
   1278            RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
   1279            
   1280            /* Get the HCLK configuration ----------------------------------------------*/ 
   1281            RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
   1282            
   1283            /* Get the APB1 configuration ----------------------------------------------*/ 
   1284            RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);   
   1285            
   1286            /* Get the APB2 configuration ----------------------------------------------*/ 
   1287            RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
   1288            
   1289            /* Get the Flash Wait State (Latency) configuration ------------------------*/   
   1290            *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
   1291          }
   1292          
   1293          /**
   1294            * @brief This function handles the RCC CSS interrupt request.
   1295            * @note This API should be called under the NMI_Handler().
   1296            * @param None
   1297            * @retval None
   1298            */
   1299          void HAL_RCC_NMI_IRQHandler(void)
   1300          {
   1301            /* Check RCC CSSF flag  */
   1302            if(__HAL_RCC_GET_IT(RCC_IT_CSS))
   1303            {
   1304              /* RCC Clock Security System interrupt user callback */
   1305              HAL_RCC_CCSCallback();
   1306          
   1307              /* Clear RCC CSS pending bit */
   1308              __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
   1309            }
   1310          }
   1311          
   1312          /**
   1313            * @brief  RCC Clock Security System interrupt callback
   1314            * @param  none 
   1315            * @retval none
   1316            */
   1317          __weak void HAL_RCC_CCSCallback(void)
   1318          {
   1319            /* NOTE : This function Should not be modified, when the callback is needed,
   1320                      the HAL_RCC_CCSCallback could be implemented in the user file
   1321             */ 
   1322          }
   1323          
   1324          /**
   1325            * @}
   1326            */
   1327          
   1328          /**
   1329            * @}
   1330            */
   1331          
   1332          #endif /* HAL_RCC_MODULE_ENABLED */
   1333          /**
   1334            * @}
   1335            */
   1336          
   1337          /**
   1338            * @}
   1339            */
   1340          
   1341          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RCC_CCSCallback
      24   HAL_RCC_ClockConfig
        24   -> HAL_GetTick
        24   -> HAL_InitTick
       0   HAL_RCC_DeInit
       0   HAL_RCC_EnableCSS
       8   HAL_RCC_GetClockConfig
       8   HAL_RCC_GetHCLKFreq
         8   -> HAL_RCC_GetSysClockFreq
      16   HAL_RCC_GetOscConfig
       8   HAL_RCC_GetPCLK1Freq
         8   -> HAL_RCC_GetHCLKFreq
       8   HAL_RCC_GetPCLK2Freq
         8   -> HAL_RCC_GetHCLKFreq
      12   HAL_RCC_GetSysClockFreq
        12 __aeabi_uidiv
      40   HAL_RCC_MCOConfig
        40   -> HAL_GPIO_Init
      16   HAL_RCC_NMI_IRQHandler
        16   -> HAL_RCC_CCSCallback
      24   HAL_RCC_OscConfig
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable3
       4  ??DataTable5
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       8  ?Subroutine0
      16  APBAHBPrescTable
       2  HAL_RCC_CCSCallback
     492  HAL_RCC_ClockConfig
      34  HAL_RCC_DeInit
      14  HAL_RCC_EnableCSS
      54  HAL_RCC_GetClockConfig
      26  HAL_RCC_GetHCLKFreq
     158  HAL_RCC_GetOscConfig
      16  HAL_RCC_GetPCLK1Freq
      14  HAL_RCC_GetPCLK2Freq
      96  HAL_RCC_GetSysClockFreq
      72  HAL_RCC_MCOConfig
      22  HAL_RCC_NMI_IRQHandler
     922  HAL_RCC_OscConfig
      28  MSIRangeTable
      12  PLLMulTable

 
    28 bytes in section .data
 2 066 bytes in section .text
 
 2 066 bytes of CODE memory
    28 bytes of DATA memory

Errors: none
Warnings: none

###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        13/Jul/2017  14:23:22
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\demo\SUBDEV_SWITCH\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_tim.c
#    Command line =  
#        F:\demo\SUBDEV_SWITCH\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_tim.c
#        -D STM32L053xx -D USE_HAL_DRIVER -lc
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\List\ -o
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\Obj\ --debug
#        --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\..\Drivers\STM32L0xx_HAL_Driver\Inc\
#        -I F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\Inc\ -I
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\..\Drivers\CMSIS\Device\ST\STM32L0xx\Include\
#        -I F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\..\Drivers\CMSIS\Include\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\List\stm32l0xx_hal_tim.lst
#    Object file  =  
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\Obj\stm32l0xx_hal_tim.o
#
###############################################################################

F:\demo\SUBDEV_SWITCH\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l0xx_hal_tim.c
      4            * @author  MCD Application Team
      5            * @version V1.1.0
      6            * @date    18-June-2014
      7            * @brief   TIM HAL module driver.
      8            * @brief   This file provides firmware functions to manage the following 
      9            *          functionalities of the Timer (TIM) peripheral:
     10            *           + Time Base Initialization
     11            *           + Time Base Start
     12            *           + Time Base Start Interruption
     13            *           + Time Base Start DMA
     14            *           + Time Output Compare/PWM Initialization
     15            *           + Time Output Compare/PWM Channel Configuration
     16            *           + Time Output Compare/PWM  Start
     17            *           + Time Output Compare/PWM  Start Interruption
     18            *           + Time Output Compare/PWM Start DMA
     19            *           + Time Input Capture Initialization
     20            *           + Time Input Capture Channel Configuration
     21            *           + Time Input Capture Start
     22            *           + Time Input Capture Start Interruption 
     23            *           + Time Input Capture Start DMA
     24            *           + Time One Pulse Initialization
     25            *           + Time One Pulse Channel Configuration
     26            *           + Time One Pulse Start 
     27            *           + Time Encoder Interface Initialization
     28            *           + Time Encoder Interface Start
     29            *           + Time Encoder Interface Start Interruption
     30            *           + Time Encoder Interface Start DMA
     31            *           + Time OCRef clear configuration
     32            *           + Time External Clock configuration
     33            *           + Time Complementary signal bread and dead time configuration
     34            *           + Time Master and Slave synchronization configuration
     35            @verbatim
     36            ==============================================================================
     37                                ##### TIMER Generic features #####
     38            ==============================================================================
     39              [..] The Timer features include: 
     40                   (#) 16-bit up, down, up/down auto-reload counter.
     41                   (#) 16-bit programmable prescaler allowing dividing (also on the fly) the counter clock
     42                       frequency either by any factor between 1 and 65536.
     43                   (#) Up to 4 independent channels for:
     44                     (++) Input Capture
     45                     (++) Output Compare
     46                     (++) PWM generation (Edge and Center-aligned Mode)
     47                     (++) One-pulse mode output
     48                   (#) Synchronization circuit to control the timer with external signals and to interconnect
     49                      several timers together.
     50                   (#) Supports incremental (quadrature) encoder and hall-sensor circuitry for positioning
     51                     purposes                
     52             
     53                      ##### How to use this driver #####
     54          ================================================================================
     55              [..]
     56               (#) Enable the TIM interface clock using 
     57                   __TIMx_CLK_ENABLE(); 
     58                 
     59               (#) TIM pins configuration
     60                    (++) Enable the clock for the TIM GPIOs using the following function:
     61                        __GPIOx_CLK_ENABLE();   
     62                    (++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();  
     63          
     64               (#) The external Clock can be configured, if needed (the default clock is the internal clock from the APBx), 
     65                   using the following function:
     66                   HAL_TIM_ConfigClockSource, the clock configuration should be done before any start function.
     67            
     68               (#) Configure the TIM in the desired functioning mode using one of the 
     69                   initialization function of this driver:
     70                   (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
     71                   (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an 
     72                        Output Compare signal.
     73                   (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a 
     74                        PWM signal.
     75                   (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an 
     76                        external signal.
     77                   (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer in One Pulse Mode.
     78                   (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.
     79          
     80               (#) Activate the TIM peripheral using one of the start functions: 
     81                   HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT(),
     82                   HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT(),
     83                   HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT(),
     84                   HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT(),
     85                   HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT(),
     86                   HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA() or HAL_TIM_Encoder_Start_IT()
     87          
     88               (#) The DMA Burst is managed with the two following functions:
     89                   HAL_TIM_DMABurst_WriteStart
     90                   HAL_TIM_DMABurst_ReadStart
     91            
     92            @endverbatim
     93            ******************************************************************************
     94            * @attention
     95            *
     96            * <h2><center>&copy; COPYRIGHT(c) 2014 STMicroelectronics</center></h2>
     97            *
     98            * Redistribution and use in source and binary forms, with or without modification,
     99            * are permitted provided that the following conditions are met:
    100            *   1. Redistributions of source code must retain the above copyright notice,
    101            *      this list of conditions and the following disclaimer.
    102            *   2. Redistributions in binary form must reproduce the above copyright notice,
    103            *      this list of conditions and the following disclaimer in the documentation
    104            *      and/or other materials provided with the distribution.
    105            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    106            *      may be used to endorse or promote products derived from this software
    107            *      without specific prior written permission.
    108            *
    109            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    110            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    111            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    112            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    113            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    114            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    115            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    116            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    117            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    118            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    119            *
    120            ******************************************************************************
    121            */ 
    122          
    123          /* Includes ------------------------------------------------------------------*/
    124          #include "stm32l0xx_hal.h"
    125          
    126          /** @addtogroup STM32L0xx_HAL_Driver
    127            * @{
    128            */
    129          
    130          /** @defgroup TIM 
    131            * @brief TIM HAL module driver
    132            * @{
    133            */
    134          
    135          #ifdef HAL_TIM_MODULE_ENABLED
    136          
    137          /* Private typedef -----------------------------------------------------------*/
    138          /* Private define ------------------------------------------------------------*/
    139          /* Private macro -------------------------------------------------------------*/
    140          /* Private variables ---------------------------------------------------------*/
    141          /* Private function prototypes -----------------------------------------------*/
    142          static void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure);
    143          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    144          static void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    145          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    146          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    147          static void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection, uint32_t TIM_ICFilter);
    148          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    149          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection, uint32_t TIM_ICFilter);
    150          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    151          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection, uint32_t TIM_ICFilter);
    152          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection, uint32_t TIM_ICFilter);
    153          static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler, uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter);
    154          static void TIM_ITRx_SetConfig(TIM_TypeDef* TIMx, uint16_t TIM_ITRx);
    155          static void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState);
    156          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);
    157          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);
    158          
    159          /* Private functions ---------------------------------------------------------*/
    160          
    161          /** @defgroup TIM_Private_Functions
    162            * @{
    163            */
    164          
    165          /** @defgroup TIM_Group1 Initialization/de-initialization functions 
    166           *  @brief    Initialization and Configuration functions 
    167           *
    168          @verbatim
    169           ===============================================================================
    170                        ##### Initialization and de-initialization functions #####
    171           ===============================================================================
    172              [..]  This section provides functions allowing to:
    173                (+) Initialize and configure the TIM. 
    174                (+) De-initialize the TIM.
    175           
    176          @endverbatim
    177            * @{
    178            */
    179          /**
    180            * @brief  Initializes the TIM Time base Unit according to the specified
    181            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    182            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    183            *                the configuration information for TIM module.
    184            * @retval HAL status
    185            */
    186          HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
    187          { 
    188            /* Check the TIM handle allocation */
    189            if(htim == NULL)
    190            {
    191              return HAL_ERROR;
    192            }
    193            
    194            /* Check the parameters */
    195            assert_param(IS_TIM_INSTANCE(htim->Instance)); 
    196            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    197            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    198            
    199            if(htim->State == HAL_TIM_STATE_RESET)
    200            {  
    201              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    202              HAL_TIM_Base_MspInit(htim);
    203            }
    204              
    205            /* Set the TIM state */
    206            htim->State= HAL_TIM_STATE_BUSY;
    207            
    208            /* Set the Time Base configuration */
    209            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
    210            
    211            /* Initialize the TIM state*/
    212            htim->State= HAL_TIM_STATE_READY;
    213            
    214            return HAL_OK;
    215          }
    216          
    217          /**
    218            * @brief  Initializes the TIM Output Compare according to the specified
    219            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    220            * @param  htim: TIM Output Compare handle
    221            * @retval HAL status
    222            */
    223          HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
    224          {
    225            /* Check the TIM handle allocation */
    226            if(htim == NULL)
    227            {
    228              return HAL_ERROR;
    229            }
    230          
    231            /* Check the parameters */
    232            assert_param(IS_TIM_INSTANCE(htim->Instance));
    233            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    234            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    235           
    236            if(htim->State == HAL_TIM_STATE_RESET)
    237            {  
    238              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    239              HAL_TIM_OC_MspInit(htim);
    240            }
    241            /* Set the TIM state */
    242            htim->State= HAL_TIM_STATE_BUSY;
    243          
    244            /* Init the base time for the Output Compare */  
    245            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
    246            
    247            /* Initialize the TIM state*/
    248            htim->State= HAL_TIM_STATE_READY;
    249            
    250            return HAL_OK;
    251          }
    252          
    253          /**
    254            * @brief  Initializes the TIM PWM Time Base according to the specified
    255            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    256            * @param  htim: TIM handle
    257            * @retval HAL status
    258            */
    259          HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
    260          {
    261            /* Check the TIM handle allocation */
    262            if(htim == NULL)
    263            {
    264              return HAL_ERROR;
    265            }
    266          
    267            /* Check the parameters */
    268            assert_param(IS_TIM_INSTANCE(htim->Instance));
    269            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    270            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    271          
    272            if(htim->State == HAL_TIM_STATE_RESET)
    273            {  
    274              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    275              HAL_TIM_PWM_MspInit(htim);
    276            }
    277            
    278            /* Set the TIM state */
    279            htim->State= HAL_TIM_STATE_BUSY;
    280            
    281            /* Init the base time for the PWM */  
    282            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
    283             
    284            /* Initialize the TIM state*/
    285            htim->State= HAL_TIM_STATE_READY;
    286            
    287            return HAL_OK;
    288          }
    289          
    290          /**
    291            * @brief  Initializes the TIM Input Capture Time base according to the specified
    292            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    293            * @param  htim: TIM Input Capture handle
    294            * @retval HAL status
    295            */
    296          HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
    297          {
    298            /* Check the TIM handle allocation */
    299            if(htim == NULL)
    300            {
    301              return HAL_ERROR;
    302            }
    303          
    304            /* Check the parameters */
    305            assert_param(IS_TIM_INSTANCE(htim->Instance));
    306            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    307            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)); 
    308            
    309            if(htim->State == HAL_TIM_STATE_RESET)
    310            {  
    311              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    312              HAL_TIM_IC_MspInit(htim);
    313            }
    314            
    315            /* Set the TIM state */
    316            htim->State= HAL_TIM_STATE_BUSY;
    317            
    318            /* Init the base time for the input capture */  
    319            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
    320             
    321            /* Initialize the TIM state*/
    322            htim->State= HAL_TIM_STATE_READY;
    323            
    324            return HAL_OK;
    325          }
    326          
    327          /**
    328            * @brief  Initializes the TIM One Pulse Time Base according to the specified
    329            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    330            * @param  htim: TIM OnePulse handle
    331            * @param  OnePulseMode: Select the One pulse mode.
    332            *         This parameter can be one of the following values:
    333            *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
    334            *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses wil be generated.
    335            * @retval HAL status
    336            */
    337          HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
    338          {
    339            /* Check the TIM handle allocation */
    340            if(htim == NULL)
    341            {
    342              return HAL_ERROR;
    343            }
    344          
    345            /* Check the parameters */
    346            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
    347            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    348            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    349            assert_param(IS_TIM_OPM_MODE(OnePulseMode));
    350            
    351            if(htim->State == HAL_TIM_STATE_RESET)
    352            {  
    353              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    354              HAL_TIM_OnePulse_MspInit(htim);
    355            }
    356            
    357            /* Set the TIM state */
    358            htim->State= HAL_TIM_STATE_BUSY;
    359            
    360            /* Configure the Time base in the One Pulse Mode */
    361            TIM_Base_SetConfig(htim->Instance, &htim->Init);
    362            
    363            /* Reset the OPM Bit */
    364            htim->Instance->CR1 &= ~TIM_CR1_OPM;
    365          
    366            /* Configure the OPM Mode */
    367            htim->Instance->CR1 |= OnePulseMode;
    368             
    369            /* Initialize the TIM state*/
    370            htim->State= HAL_TIM_STATE_READY;
    371            
    372            return HAL_OK;
    373          }
    374          
    375          /**
    376            * @brief  Initializes the TIM Encoder Interface and create the associated handle.
    377            * @param  htim: TIM Encoder Interface handle
    378            * @param  sConfig: TIM Encoder Interface configuration structure
    379            * @retval HAL status
    380            */
    381          HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
    382          {
    383            uint32_t tmpsmcr = 0;
    384            uint32_t tmpccmr1 = 0;
    385            uint32_t tmpccer = 0;
    386            
    387            /* Check the TIM handle allocation */
    388            if(htim == NULL)
    389            {
    390              return HAL_ERROR;
    391            }
    392             
    393            /* Check the parameters */
    394            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
    395            assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
    396            assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
    397            assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
    398            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
    399            assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
    400            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
    401            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
    402            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
    403            assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
    404          
    405            if(htim->State == HAL_TIM_STATE_RESET)
    406            {  
    407              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    408              HAL_TIM_Encoder_MspInit(htim);
    409            }
    410            
    411            /* Set the TIM state */
    412            htim->State= HAL_TIM_STATE_BUSY;
    413            
    414            /* Reset the SMS bits */
    415            htim->Instance->SMCR &= ~TIM_SMCR_SMS;
    416            
    417            /* Configure the Time base in the Encoder Mode */
    418            TIM_Base_SetConfig(htim->Instance, &htim->Init);  
    419            
    420            /* Get the TIMx SMCR register value */
    421            tmpsmcr = htim->Instance->SMCR;
    422          
    423            /* Get the TIMx CCMR1 register value */
    424            tmpccmr1 = htim->Instance->CCMR1;
    425          
    426            /* Get the TIMx CCER register value */
    427            tmpccer = htim->Instance->CCER;
    428          
    429            /* Set the encoder Mode */
    430            tmpsmcr |= sConfig->EncoderMode;
    431          
    432            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
    433            tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
    434            tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
    435            
    436            /* Set the the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
    437            tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
    438            tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
    439            tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
    440            tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
    441          
    442            /* Set the TI1 and the TI2 Polarities */
    443            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
    444            tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
    445            tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
    446            
    447            /* Write to TIMx SMCR */
    448            htim->Instance->SMCR = tmpsmcr;
    449          
    450            /* Write to TIMx CCMR1 */
    451            htim->Instance->CCMR1 = tmpccmr1;
    452          
    453            /* Write to TIMx CCER */
    454            htim->Instance->CCER = tmpccer;
    455            
    456            /* Initialize the TIM state*/
    457            htim->State= HAL_TIM_STATE_READY;
    458            
    459            return HAL_OK;
    460          }
    461          
    462          /**
    463            * @brief  DeInitializes the TIM Base peripheral 
    464            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    465            *                the configuration information for TIM module.
    466            * @retval HAL status
    467            */
    468          HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
    469          {  
    470            /* Check the parameters */
    471            assert_param(IS_TIM_INSTANCE(htim->Instance));
    472          
    473            htim->State = HAL_TIM_STATE_BUSY;
    474             
    475            /* Disable the TIM Peripheral Clock */
    476            __HAL_TIM_DISABLE(htim);
    477              
    478            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    479            HAL_TIM_Base_MspDeInit(htim);
    480            
    481            /* Change TIM state */  
    482            htim->State = HAL_TIM_STATE_RESET;
    483            
    484            /* Release Lock */
    485            __HAL_UNLOCK(htim);
    486                                      
    487            return HAL_OK;
    488          }
    489          
    490          /**
    491            * @brief  DeInitializes the TIM peripheral 
    492            * @param  htim: TIM Output Compare handle
    493            * @retval HAL status
    494            */
    495          HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
    496          {
    497            /* Check the parameters */
    498            assert_param(IS_TIM_INSTANCE(htim->Instance));
    499            
    500             htim->State = HAL_TIM_STATE_BUSY;
    501             
    502            /* Disable the TIM Peripheral Clock */
    503            __HAL_TIM_DISABLE(htim);
    504            
    505            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    506            HAL_TIM_OC_MspDeInit(htim);
    507              
    508            /* Change TIM state */  
    509            htim->State = HAL_TIM_STATE_RESET;
    510            
    511            /* Release Lock */
    512            __HAL_UNLOCK(htim); 
    513            
    514            return HAL_OK;
    515          }
    516          
    517          /**
    518            * @brief  DeInitializes the TIM peripheral 
    519            * @param  htim: TIM handle
    520            * @retval HAL status
    521            */
    522          HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
    523          {
    524            /* Check the parameters */
    525            assert_param(IS_TIM_INSTANCE(htim->Instance));
    526            
    527            htim->State = HAL_TIM_STATE_BUSY;
    528            
    529            /* Disable the TIM Peripheral Clock */
    530            __HAL_TIM_DISABLE(htim);
    531              
    532            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    533            HAL_TIM_PWM_MspDeInit(htim);
    534              
    535            /* Change TIM state */  
    536            htim->State = HAL_TIM_STATE_RESET;
    537            
    538            /* Release Lock */
    539            __HAL_UNLOCK(htim); 
    540            
    541            return HAL_OK;
    542          }
    543          
    544          /**
    545            * @brief  DeInitializes the TIM peripheral 
    546            * @param  htim: TIM Input Capture handle
    547            * @retval HAL status
    548            */
    549          HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
    550          {
    551            /* Check the parameters */
    552            assert_param(IS_TIM_INSTANCE(htim->Instance));
    553          
    554            htim->State = HAL_TIM_STATE_BUSY;
    555            
    556            /* Disable the TIM Peripheral Clock */
    557            __HAL_TIM_DISABLE(htim);
    558              
    559            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    560            HAL_TIM_IC_MspDeInit(htim);
    561              
    562            /* Change TIM state */  
    563            htim->State = HAL_TIM_STATE_RESET;
    564            
    565            /* Release Lock */
    566            __HAL_UNLOCK(htim);
    567             
    568            return HAL_OK;
    569          }
    570          
    571          /**
    572            * @brief  DeInitializes the TIM One Pulse  
    573            * @param  htim: TIM One Pulse handle
    574            * @retval HAL status
    575            */
    576          HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
    577          {
    578            /* Check the parameters */
    579            assert_param(IS_TIM_INSTANCE(htim->Instance));
    580            
    581            htim->State = HAL_TIM_STATE_BUSY;
    582            
    583            /* Disable the TIM Peripheral Clock */
    584            __HAL_TIM_DISABLE(htim);
    585            
    586            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    587            HAL_TIM_OnePulse_MspDeInit(htim);
    588              
    589            /* Change TIM state */  
    590            htim->State = HAL_TIM_STATE_RESET;
    591            
    592            /* Release Lock */
    593            __HAL_UNLOCK(htim); 
    594            
    595            return HAL_OK;
    596          }
    597          
    598          /**
    599            * @brief  DeInitializes the TIM Encoder interface  
    600            * @param  htim: TIM Encoder handle
    601            * @retval HAL status
    602            */
    603          HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
    604          {
    605            /* Check the parameters */
    606            assert_param(IS_TIM_INSTANCE(htim->Instance));
    607            
    608            htim->State = HAL_TIM_STATE_BUSY;
    609            
    610            /* Disable the TIM Peripheral Clock */
    611            __HAL_TIM_DISABLE(htim);
    612            
    613            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    614            HAL_TIM_Encoder_MspDeInit(htim);
    615              
    616            /* Change TIM state */  
    617            htim->State = HAL_TIM_STATE_RESET;
    618            
    619            /* Release Lock */
    620            __HAL_UNLOCK(htim); 
    621            
    622            return HAL_OK;
    623          }
    624          
    625          /**
    626            * @brief  Initializes the TIM Base MSP.
    627            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    628            *                the configuration information for TIM module.
    629            * @retval None
    630            */
    631          __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
    632          {
    633            /* NOTE : This function Should not be modified, when the callback is needed,
    634                      the HAL_TIM_Base_MspInit could be implemented in the user file
    635             */
    636          }
    637          
    638          /**
    639            * @brief  Initializes the TIM Output Compare MSP.
    640            * @param  htim: TIM handle
    641            * @retval None
    642            */
    643          __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
    644          {
    645            /* NOTE : This function Should not be modified, when the callback is needed,
    646                      the HAL_TIM_OC_MspInit could be implemented in the user file
    647             */
    648          }
    649          
    650          /**
    651            * @brief  Initializes the TIM PWM MSP.
    652            * @param  htim: TIM handle
    653            * @retval None
    654            */
    655          __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
    656          {
    657            /* NOTE : This function Should not be modified, when the callback is needed,
    658                      the HAL_TIM_PWM_MspInit could be implemented in the user file
    659             */
    660          }
    661          
    662          /**
    663            * @brief  Initializes the TIM INput Capture MSP.
    664            * @param  htim: TIM handle
    665            * @retval None
    666            */
    667          __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
    668          {
    669            /* NOTE : This function Should not be modified, when the callback is needed,
    670                      the HAL_TIM_IC_MspInit could be implemented in the user file
    671             */
    672          }
    673          
    674          /**
    675            * @brief  Initializes the TIM One Pulse MSP.
    676            * @param  htim: TIM handle
    677            * @retval None
    678            */
    679          __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
    680          {
    681            /* NOTE : This function Should not be modified, when the callback is needed,
    682                      the HAL_TIM_OnePulse_MspInit could be implemented in the user file
    683             */
    684          }
    685          
    686          /**
    687            * @brief  Initializes the TIM Encoder Interface MSP.
    688            * @param  htim: TIM handle
    689            * @retval None
    690            */
    691          __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
    692          {
    693            /* NOTE : This function Should not be modified, when the callback is needed,
    694                      the HAL_TIM_Encoder_MspInit could be implemented in the user file
    695             */
    696          }
    697          
    698          /**
    699            * @brief  DeInitializes TIM Base MSP.
    700            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    701            *                the configuration information for TIM module.
    702            * @retval None
    703            */
    704          __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
    705          {
    706            /* NOTE : This function Should not be modified, when the callback is needed,
    707                      the HAL_TIM_Base_MspDeInit could be implemented in the user file
    708             */
    709          }
    710          
    711          /**
    712            * @brief  DeInitializes TIM Output Compare MSP.
    713            * @param  htim: TIM handle
    714            * @retval None
    715            */
    716          __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
    717          {
    718            /* NOTE : This function Should not be modified, when the callback is needed,
    719                      the HAL_TIM_OC_MspDeInit could be implemented in the user file
    720             */
    721          }
    722          
    723          /**
    724            * @brief  DeInitializes TIM PWM MSP.
    725            * @param  htim: TIM handle
    726            * @retval None
    727            */
    728          __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
    729          {
    730            /* NOTE : This function Should not be modified, when the callback is needed,
    731                      the HAL_TIM_PWM_MspDeInit could be implemented in the user file
    732             */
    733          }
    734          
    735          /**
    736            * @brief  DeInitializes TIM Input Capture MSP.
    737            * @param  htim: TIM handle
    738            * @retval None
    739            */
    740          __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
    741          {
    742            /* NOTE : This function Should not be modified, when the callback is needed,
    743                      the HAL_TIM_IC_MspDeInit could be implemented in the user file
    744             */
    745          }
    746          
    747          /**
    748            * @brief  DeInitializes TIM One Pulse MSP.
    749            * @param  htim: TIM handle
    750            * @retval None
    751            */
    752          __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
    753          {
    754            /* NOTE : This function Should not be modified, when the callback is needed,
    755                      the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
    756             */
    757          }
    758          
    759          /**
    760            * @brief  DeInitializes TIM Encoder Interface MSP.
    761            * @param  htim: TIM handle
    762            * @retval None
    763            */
    764          __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
    765          {
    766            /* NOTE : This function Should not be modified, when the callback is needed,
    767                      the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
    768             */
    769          }
    770          
    771          /**
    772            * @}
    773            */
    774          
    775          /** @defgroup TIM_Group2 I/O operation functions
    776           *  @brief    I/O operation functions 
    777           *
    778          @verbatim
    779           ===============================================================================
    780                                  ##### IO operation functions #####
    781           ===============================================================================  
    782              [..]  This section provides functions allowing to:
    783                (+) Start the Time Base.
    784                (+) Stop the Time Base.
    785                (+) Start the Time Base and enable interrupt.
    786                (+) Stop the Time Base and disable interrupt.
    787                (+) Start the Time Base and enable DMA transfer.
    788                (+) Stop the Time Base and disable DMA transfer.
    789                (+) Start the Output Compare/PWM.
    790                (+) Stop the Output Compare/PWM.
    791                (+) Start the Output Compare/PWM and enable interrupts.
    792                (+) Stop the Output Compare/PWM and disable interrupts.
    793                (+) Start the Output Compare/PWM and enable DMA transfers.
    794                (+) Stop the Output Compare/PWM and disable DMA transfers.
    795                (+) Start the Input Capture measurement.
    796                (+) Stop the Input Capture.
    797                (+) Start the Input Capture and enable interrupts.
    798                (+) Stop the Input Capture and disable interrupts.
    799                (+) Start the Input Capture and enable DMA transfers.
    800                (+) Stop the Input Capture and disable DMA transfers.
    801                (+) Start the One Pulse generation.
    802                (+) Stop the One Pulse.
    803                (+) Start the One Pulse and enable interrupts.
    804                (+) Stop the One Pulse and disable interrupts.
    805                (+) Start the Encoder Interface.
    806                (+) Stop the Encoder Interface.
    807                (+) Start the Encoder Interface and enable interrupts.
    808                (+) Stop the Encoder Interface and disable interrupts.
    809                (+) Start the Encoder Interface and enable DMA transfers.
    810                (+) Stop the Encoder Interface and disable DMA transfers.
    811                (+) Start the Hall Sensor Interface.
    812                (+) Stop the Hall Sensor Interface.
    813                (+) Start the Hall Sensor Interface and enable interrupts.
    814                (+) Stop the Hall Sensor Interface and disable interrupts.
    815                (+) Start the Hall Sensor Interface and enable DMA transfers.
    816                (+) Stop the Hall Sensor Interface and disable DMA transfers.
    817                (+) Handle TIM interrupt request. 
    818                         
    819          @endverbatim
    820            * @{
    821            */
    822          /**
    823            * @brief  Starts the TIM Base generation.
    824            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    825            *                the configuration information for TIM module.
    826            * @retval HAL status
    827            */
    828          HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
    829          {
    830            /* Check the parameters */
    831            assert_param(IS_TIM_INSTANCE(htim->Instance));
    832            
    833            /* Set the TIM state */
    834            htim->State= HAL_TIM_STATE_BUSY;
    835            
    836            /* Enable the Peripheral */
    837            __HAL_TIM_ENABLE(htim);
    838            
    839            /* Change the TIM state*/
    840            htim->State= HAL_TIM_STATE_READY;
    841            
    842            /* Return function status */
    843            return HAL_OK;
    844          }
    845          
    846          /**
    847            * @brief  Stops the TIM Base generation.
    848            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    849            *                the configuration information for TIM module.
    850            * @retval HAL status
    851            */
    852          HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
    853          {
    854            /* Check the parameters */
    855            assert_param(IS_TIM_INSTANCE(htim->Instance));
    856            
    857            /* Set the TIM state */
    858            htim->State= HAL_TIM_STATE_BUSY;
    859            
    860            /* Disable the Peripheral */
    861            __HAL_TIM_DISABLE(htim);
    862            
    863            /* Change the TIM state*/
    864            htim->State= HAL_TIM_STATE_READY;
    865            
    866            /* Return function status */
    867            return HAL_OK;
    868          }
    869          
    870          /**
    871            * @brief  Starts the TIM Base generation in interrupt mode.
    872            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    873            *                the configuration information for TIM module.
    874            * @retval HAL status
    875            */
    876          HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
    877          {
    878            /* Check the parameters */
    879            assert_param(IS_TIM_INSTANCE(htim->Instance));
    880            
    881            /* Enable the TIM Update interrupt */
    882            __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
    883                
    884            /* Enable the Peripheral */
    885            __HAL_TIM_ENABLE(htim);
    886                
    887            /* Return function status */
    888            return HAL_OK;
    889          }
    890          
    891          /**
    892            * @brief  Stops the TIM Base generation in interrupt mode.
    893            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    894            *                the configuration information for TIM module.
    895            * @retval HAL status
    896            */
    897          HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
    898          {
    899            /* Check the parameters */
    900            assert_param(IS_TIM_INSTANCE(htim->Instance));
    901            /* Disable the TIM Update interrupt */
    902            __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);//放到HAL_TIM_Base_MspInit函数中
    903                
    904            /* Disable the Peripheral */
    905            __HAL_TIM_DISABLE(htim);
    906              
    907            /* Return function status */
    908            return HAL_OK;
    909          }
    910          
    911          /**
    912            * @brief  Starts the TIM Base generation in DMA mode.
    913            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    914            *                the configuration information for TIM module.
    915            * @param  pData: The source Buffer address.
    916            * @param  Length: The length of data to be transferred from memory to peripheral.
    917            * @retval HAL status
    918            */
    919          HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    920          {
    921            /* Check the parameters */
    922            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance)); 
    923            
    924            if((htim->State == HAL_TIM_STATE_BUSY))
    925            {
    926               return HAL_BUSY;
    927            }
    928            else if((htim->State == HAL_TIM_STATE_READY))
    929            {
    930              if((pData == 0 ) && (Length > 0)) 
    931              {
    932                return HAL_ERROR;                                    
    933              }
    934              else
    935              {
    936                htim->State = HAL_TIM_STATE_BUSY;
    937              }
    938            }  
    939            /* Set the DMA Period elapsed callback */
    940            htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
    941               
    942            /* Set the DMA error callback */
    943            htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
    944            
    945            /* Enable the DMA Stream */
    946            HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
    947            
    948            /* Enable the TIM Update DMA request */
    949            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
    950          
    951            /* Enable the Peripheral */
    952            __HAL_TIM_ENABLE(htim);  
    953            
    954            /* Return function status */
    955            return HAL_OK;
    956          }
    957          
    958          /**
    959            * @brief  Stops the TIM Base generation in DMA mode.
    960            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    961            *                the configuration information for TIM module.
    962            * @retval HAL status
    963            */
    964          HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
    965          {
    966            /* Check the parameters */
    967            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    968            
    969            /* Disable the TIM Update DMA request */
    970            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
    971                
    972            /* Disable the Peripheral */
    973            __HAL_TIM_DISABLE(htim);
    974              
    975            /* Change the htim state */
    976            htim->State = HAL_TIM_STATE_READY;
    977                
    978            /* Return function status */
    979            return HAL_OK;
    980          }
    981          
    982          /**
    983            * @brief  Starts the TIM Output Compare signal generation.
    984            * @param  htim : pointer to a TIM_HandleTypeDef structure that contains
    985            *                the configuration information for TIM module.   
    986            * @param  Channel: TIM Channel to be enabled.
    987            *          This parameter can be one of the following values:
    988            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    989            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    990            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    991            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected   
    992            * @retval HAL status
    993            */
    994          HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    995          {
    996            /* Check the parameters */
    997            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    998            
    999            /* Enable the Output compare channel */
   1000            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1001            
   1002            /* Enable the Peripheral */
   1003            __HAL_TIM_ENABLE(htim); 
   1004            
   1005            /* Return function status */
   1006            return HAL_OK;
   1007          }
   1008          
   1009          /**
   1010            * @brief  Stops the TIM Output Compare signal generation.
   1011            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1012            *                the configuration information for TIM module.
   1013            * @param  Channel: TIM Channel to be disabled.
   1014            *          This parameter can be one of the following values:
   1015            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1016            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1017            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1018            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1019            * @retval HAL status
   1020            */
   1021          HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1022          {
   1023            /* Check the parameters */
   1024            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1025            
   1026            /* Disable the Output compare channel */
   1027            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1028            
   1029            /* Disable the Peripheral */
   1030            __HAL_TIM_DISABLE(htim);  
   1031            
   1032            /* Return function status */
   1033            return HAL_OK;
   1034          }  
   1035          
   1036          /**
   1037            * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
   1038            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1039            *                the configuration information for TIM module.
   1040            * @param  Channel: TIM Channel to be enabled.
   1041            *          This parameter can be one of the following values:
   1042            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1043            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1044            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1045            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1046            * @retval HAL status
   1047            */
   1048          HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1049          {
   1050            /* Check the parameters */
   1051            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1052            
   1053            switch (Channel)
   1054            {
   1055              case TIM_CHANNEL_1:
   1056              {       
   1057                /* Enable the TIM Capture/Compare 1 interrupt */
   1058                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   1059              }
   1060              break;
   1061              
   1062              case TIM_CHANNEL_2:
   1063              {
   1064                /* Enable the TIM Capture/Compare 2 interrupt */
   1065                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   1066              }
   1067              break;
   1068              
   1069              case TIM_CHANNEL_3:
   1070              {
   1071                /* Enable the TIM Capture/Compare 3 interrupt */
   1072                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   1073              }
   1074              break;
   1075              
   1076              case TIM_CHANNEL_4:
   1077              {
   1078                /* Enable the TIM Capture/Compare 4 interrupt */
   1079                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   1080              }
   1081              break;
   1082              
   1083              default:
   1084              break;
   1085            } 
   1086          
   1087            /* Enable the Output compare channel */
   1088            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1089          
   1090            /* Enable the Peripheral */
   1091            __HAL_TIM_ENABLE(htim);
   1092            
   1093            /* Return function status */
   1094            return HAL_OK;
   1095          }
   1096          
   1097          /**
   1098            * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
   1099            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1100            *                the configuration information for TIM module.
   1101            * @param  Channel: TIM Channel to be disabled.
   1102            *          This parameter can be one of the following values:
   1103            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1104            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1105            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1106            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1107            * @retval HAL status
   1108            */
   1109          HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1110          {
   1111            /* Check the parameters */
   1112            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1113            
   1114            switch (Channel)
   1115            {
   1116              case TIM_CHANNEL_1:
   1117              {       
   1118                /* Disable the TIM Capture/Compare 1 interrupt */
   1119                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   1120              }
   1121              break;
   1122              
   1123              case TIM_CHANNEL_2:
   1124              {
   1125                /* Disable the TIM Capture/Compare 2 interrupt */
   1126                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   1127              }
   1128              break;
   1129              
   1130              case TIM_CHANNEL_3:
   1131              {
   1132                /* Disable the TIM Capture/Compare 3 interrupt */
   1133                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   1134              }
   1135              break;
   1136              
   1137              case TIM_CHANNEL_4:
   1138              {
   1139                /* Disable the TIM Capture/Compare 4 interrupt */
   1140                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   1141              }
   1142              break;
   1143              
   1144              default:
   1145              break; 
   1146            } 
   1147            
   1148            /* Disable the Output compare channel */
   1149            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1150            
   1151            /* Disable the Peripheral */
   1152            __HAL_TIM_DISABLE(htim);  
   1153            
   1154            /* Return function status */
   1155            return HAL_OK;
   1156          }
   1157          
   1158          /**
   1159            * @brief  Starts the TIM Output Compare signal generation in DMA mode.
   1160            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1161            *                the configuration information for TIM module.
   1162            * @param  Channel: TIM Channel to be enabled.
   1163            *          This parameter can be one of the following values:
   1164            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1165            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1166            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1167            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1168            * @param  pData: The source Buffer address.
   1169            * @param  Length: The length of data to be transferred from memory to TIM peripheral
   1170            * @retval HAL status
   1171            */
   1172          HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1173          {
   1174            /* Check the parameters */
   1175            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1176            
   1177            if((htim->State == HAL_TIM_STATE_BUSY))
   1178            {
   1179               return HAL_BUSY;
   1180            }
   1181            else if((htim->State == HAL_TIM_STATE_READY))
   1182            {
   1183              if(((uint32_t)pData == 0 ) && (Length > 0)) 
   1184              {
   1185                return HAL_ERROR;                                    
   1186              }
   1187              else
   1188              {
   1189                htim->State = HAL_TIM_STATE_BUSY;
   1190              }
   1191            }    
   1192            switch (Channel)
   1193            {
   1194              case TIM_CHANNEL_1:
   1195              {      
   1196                /* Set the DMA Period elapsed callback */
   1197                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   1198               
   1199                /* Set the DMA error callback */
   1200                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   1201                
   1202                /* Enable the DMA Stream */
   1203                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   1204                
   1205                /* Enable the TIM Capture/Compare 1 DMA request */
   1206                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   1207              }
   1208              break;
   1209              
   1210              case TIM_CHANNEL_2:
   1211              {
   1212                /* Set the DMA Period elapsed callback */
   1213                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   1214               
   1215                /* Set the DMA error callback */
   1216                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   1217                
   1218                /* Enable the DMA Stream */
   1219                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   1220                
   1221                /* Enable the TIM Capture/Compare 2 DMA request */
   1222                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   1223              }
   1224              break;
   1225              
   1226              case TIM_CHANNEL_3:
   1227              {
   1228                /* Set the DMA Period elapsed callback */
   1229                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   1230               
   1231                /* Set the DMA error callback */
   1232                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   1233                
   1234                /* Enable the DMA Stream */
   1235                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   1236                
   1237                /* Enable the TIM Capture/Compare 3 DMA request */
   1238                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   1239              }
   1240              break;
   1241              
   1242              case TIM_CHANNEL_4:
   1243              {
   1244               /* Set the DMA Period elapsed callback */
   1245                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   1246               
   1247                /* Set the DMA error callback */
   1248                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   1249                
   1250                /* Enable the DMA Stream */
   1251                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   1252                
   1253                /* Enable the TIM Capture/Compare 4 DMA request */
   1254                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   1255              }
   1256              break;
   1257              
   1258              default:
   1259              break;
   1260            }
   1261          
   1262            /* Enable the Output compare channel */
   1263            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);  
   1264            
   1265            /* Enable the Peripheral */
   1266            __HAL_TIM_ENABLE(htim); 
   1267            
   1268            /* Return function status */
   1269            return HAL_OK;
   1270          }
   1271          
   1272          /**
   1273            * @brief  Stops the TIM Output Compare signal generation in DMA mode.
   1274            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1275            *                the configuration information for TIM module.
   1276            * @param  Channel: TIM Channel to be disabled.
   1277            *          This parameter can be one of the following values:
   1278            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1279            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1280            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1281            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1282            * @retval HAL status
   1283            */
   1284          HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1285          {
   1286            /* Check the parameters */
   1287            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1288            
   1289            switch (Channel)
   1290            {
   1291              case TIM_CHANNEL_1:
   1292              {       
   1293                /* Disable the TIM Capture/Compare 1 DMA request */
   1294                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   1295              }
   1296              break;
   1297              
   1298              case TIM_CHANNEL_2:
   1299              {
   1300                /* Disable the TIM Capture/Compare 2 DMA request */
   1301                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   1302              }
   1303              break;
   1304              
   1305              case TIM_CHANNEL_3:
   1306              {
   1307                /* Disable the TIM Capture/Compare 3 DMA request */
   1308                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   1309              }
   1310              break;
   1311              
   1312              case TIM_CHANNEL_4:
   1313              {
   1314                /* Disable the TIM Capture/Compare 4 interrupt */
   1315                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   1316              }
   1317              break;
   1318              
   1319              default:
   1320              break;
   1321            } 
   1322            
   1323            /* Disable the Output compare channel */
   1324            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1325            
   1326            /* Disable the Peripheral */
   1327            __HAL_TIM_DISABLE(htim);
   1328            
   1329            /* Change the htim state */
   1330            htim->State = HAL_TIM_STATE_READY;
   1331            
   1332            /* Return function status */
   1333            return HAL_OK;
   1334          }
   1335          
   1336          /**
   1337            * @brief  Starts the PWM signal generation.
   1338            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1339            *                the configuration information for TIM module.
   1340            * @param  Channel: TIM Channels to be enabled.
   1341            *          This parameter can be one of the following values:
   1342            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1343            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1344            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1345            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1346            * @retval HAL status
   1347            */
   1348          HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1349          {
   1350            /* Check the parameters */
   1351            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1352          
   1353            /* Enable the Capture compare channel */
   1354            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1355              
   1356            /* Enable the Peripheral */
   1357            __HAL_TIM_ENABLE(htim);
   1358            
   1359            /* Return function status */
   1360            return HAL_OK;
   1361          } 
   1362          
   1363          /**
   1364            * @brief  Stops the PWM signal generation.
   1365            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1366            *                the configuration information for TIM module.
   1367            * @param  Channel: TIM Channels to be disabled.
   1368            *          This parameter can be one of the following values:
   1369            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1370            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1371            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1372            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1373            * @retval HAL status
   1374            */
   1375          HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1376          { 
   1377            /* Check the parameters */
   1378            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1379              
   1380            /* Disable the Capture compare channel */
   1381            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1382            
   1383            /* Disable the Peripheral */
   1384            __HAL_TIM_DISABLE(htim);
   1385            
   1386            /* Change the htim state */
   1387            htim->State = HAL_TIM_STATE_READY;
   1388            
   1389            /* Return function status */
   1390            return HAL_OK;
   1391          } 
   1392          
   1393          /**
   1394            * @brief  Starts the PWM signal generation in interrupt mode.
   1395            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1396            *                the configuration information for TIM module.
   1397            * @param  Channel: TIM Channel to be disabled.
   1398            *          This parameter can be one of the following values:
   1399            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1400            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1401            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1402            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1403            * @retval HAL status
   1404            */
   1405          HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1406          {
   1407            /* Check the parameters */
   1408            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1409            
   1410            switch (Channel)
   1411            {
   1412              case TIM_CHANNEL_1:
   1413              {       
   1414                /* Enable the TIM Capture/Compare 1 interrupt */
   1415                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   1416              }
   1417              break;
   1418              
   1419              case TIM_CHANNEL_2:
   1420              {
   1421                /* Enable the TIM Capture/Compare 2 interrupt */
   1422                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   1423              }
   1424              break;
   1425              
   1426              case TIM_CHANNEL_3:
   1427              {
   1428                /* Enable the TIM Capture/Compare 3 interrupt */
   1429                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   1430              }
   1431              break;
   1432              
   1433              case TIM_CHANNEL_4:
   1434              {
   1435                /* Enable the TIM Capture/Compare 4 interrupt */
   1436                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   1437              }
   1438              break;
   1439              
   1440              default:
   1441              break;
   1442            } 
   1443            
   1444            /* Enable the Capture compare channel */
   1445            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1446          
   1447            /* Enable the Peripheral */
   1448            __HAL_TIM_ENABLE(htim);
   1449            
   1450            /* Return function status */
   1451            return HAL_OK;
   1452          } 
   1453          
   1454          /**
   1455            * @brief  Stops the PWM signal generation in interrupt mode.
   1456            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1457            *                the configuration information for TIM module.
   1458            * @param  Channel: TIM Channels to be disabled.
   1459            *          This parameter can be one of the following values:
   1460            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1461            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1462            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1463            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1464            * @retval HAL status
   1465            */
   1466          HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1467          {
   1468            /* Check the parameters */
   1469            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1470            
   1471            switch (Channel)
   1472            {
   1473              case TIM_CHANNEL_1:
   1474              {       
   1475                /* Disable the TIM Capture/Compare 1 interrupt */
   1476                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   1477              }
   1478              break;
   1479              
   1480              case TIM_CHANNEL_2:
   1481              {
   1482                /* Disable the TIM Capture/Compare 2 interrupt */
   1483                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   1484              }
   1485              break;
   1486              
   1487              case TIM_CHANNEL_3:
   1488              {
   1489                /* Disable the TIM Capture/Compare 3 interrupt */
   1490                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   1491              }
   1492              break;
   1493              
   1494              case TIM_CHANNEL_4:
   1495              {
   1496                /* Disable the TIM Capture/Compare 4 interrupt */
   1497                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   1498              }
   1499              break;
   1500              
   1501              default:
   1502              break; 
   1503            }
   1504            
   1505            /* Disable the Capture compare channel */
   1506            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1507            
   1508            /* Disable the Peripheral */
   1509            __HAL_TIM_DISABLE(htim);
   1510            
   1511            /* Return function status */
   1512            return HAL_OK;
   1513          } 
   1514          
   1515          /**
   1516            * @brief  Starts the TIM PWM signal generation in DMA mode.
   1517            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1518            *                the configuration information for TIM module.
   1519            * @param  Channel: TIM Channels to be enabled.
   1520            *          This parameter can be one of the following values:
   1521            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1522            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1523            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1524            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1525            * @param  pData: The source Buffer address.
   1526            * @param  Length: The length of data to be transferred from memory to TIM peripheral
   1527            * @retval HAL status
   1528            */
   1529          HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1530          {
   1531            /* Check the parameters */
   1532            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1533            
   1534            if((htim->State == HAL_TIM_STATE_BUSY))
   1535            {
   1536               return HAL_BUSY;
   1537            }
   1538            else if((htim->State == HAL_TIM_STATE_READY))
   1539            {
   1540              if(((uint32_t)pData == 0 ) && (Length > 0)) 
   1541              {
   1542                return HAL_ERROR;                                    
   1543              }
   1544              else
   1545              {
   1546                htim->State = HAL_TIM_STATE_BUSY;
   1547              }
   1548            }    
   1549            switch (Channel)
   1550            {
   1551              case TIM_CHANNEL_1:
   1552              {      
   1553                /* Set the DMA Period elapsed callback */
   1554                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   1555               
   1556                /* Set the DMA error callback */
   1557                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   1558                
   1559                /* Enable the DMA Stream */
   1560                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   1561                
   1562                /* Enable the TIM Capture/Compare 1 DMA request */
   1563                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   1564              }
   1565              break;
   1566              
   1567              case TIM_CHANNEL_2:
   1568              {
   1569                /* Set the DMA Period elapsed callback */
   1570                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   1571               
   1572                /* Set the DMA error callback */
   1573                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   1574                
   1575                /* Enable the DMA Stream */
   1576                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   1577                
   1578                /* Enable the TIM Capture/Compare 2 DMA request */
   1579                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   1580              }
   1581              break;
   1582              
   1583              case TIM_CHANNEL_3:
   1584              {
   1585                /* Set the DMA Period elapsed callback */
   1586                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   1587               
   1588                /* Set the DMA error callback */
   1589                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   1590                
   1591                /* Enable the DMA Stream */
   1592                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   1593                
   1594                /* Enable the TIM Output Capture/Compare 3 request */
   1595                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   1596              }
   1597              break;
   1598              
   1599              case TIM_CHANNEL_4:
   1600              {
   1601               /* Set the DMA Period elapsed callback */
   1602                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   1603               
   1604                /* Set the DMA error callback */
   1605                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   1606                
   1607                /* Enable the DMA Stream */
   1608                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   1609                
   1610                /* Enable the TIM Capture/Compare 4 DMA request */
   1611                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   1612              }
   1613              break;
   1614              
   1615              default:
   1616              break;
   1617            }
   1618          
   1619            /* Enable the Capture compare channel */
   1620            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1621            
   1622            /* Enable the Peripheral */
   1623            __HAL_TIM_ENABLE(htim); 
   1624            
   1625            /* Return function status */
   1626            return HAL_OK;
   1627          }
   1628          
   1629          /**
   1630            * @brief  Stops the TIM PWM signal generation in DMA mode.
   1631            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1632            *                the configuration information for TIM module.
   1633            * @param  Channel: TIM Channels to be disabled.
   1634            *          This parameter can be one of the following values:
   1635            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1636            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1637            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1638            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1639            * @retval HAL status
   1640            */
   1641          HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1642          {
   1643            /* Check the parameters */
   1644            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1645            
   1646            switch (Channel)
   1647            {
   1648              case TIM_CHANNEL_1:
   1649              {       
   1650                /* Disable the TIM Capture/Compare 1 DMA request */
   1651                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   1652              }
   1653              break;
   1654              
   1655              case TIM_CHANNEL_2:
   1656              {
   1657                /* Disable the TIM Capture/Compare 2 DMA request */
   1658                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   1659              }
   1660              break;
   1661              
   1662              case TIM_CHANNEL_3:
   1663              {
   1664                /* Disable the TIM Capture/Compare 3 DMA request */
   1665                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   1666              }
   1667              break;
   1668              
   1669              case TIM_CHANNEL_4:
   1670              {
   1671                /* Disable the TIM Capture/Compare 4 interrupt */
   1672                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   1673              }
   1674              break;
   1675              
   1676              default:
   1677              break;
   1678            } 
   1679            
   1680            /* Disable the Capture compare channel */
   1681            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1682            
   1683            /* Disable the Peripheral */
   1684            __HAL_TIM_DISABLE(htim);
   1685            
   1686            /* Change the htim state */
   1687            htim->State = HAL_TIM_STATE_READY;
   1688            
   1689            /* Return function status */
   1690            return HAL_OK;
   1691          }
   1692          
   1693          /**
   1694            * @brief  Starts the TIM Input Capture measurement.
   1695            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1696            *                the configuration information for TIM module.
   1697            * @param  Channel: TIM Channels to be enabled.
   1698            *          This parameter can be one of the following values:
   1699            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1700            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1701            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1702            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1703            * @retval HAL status
   1704            */
   1705          HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
   1706          {
   1707            /* Check the parameters */
   1708            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1709            
   1710            /* Enable the Input Capture channel */
   1711            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1712              
   1713            /* Enable the Peripheral */
   1714            __HAL_TIM_ENABLE(htim);  
   1715          
   1716            /* Return function status */
   1717            return HAL_OK;  
   1718          } 
   1719          
   1720          /**
   1721            * @brief  Stops the TIM Input Capture measurement.
   1722            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1723            *                the configuration information for TIM module.
   1724            * @param  Channel: TIM Channels to be disabled.
   1725            *          This parameter can be one of the following values:
   1726            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1727            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1728            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1729            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1730            * @retval HAL status
   1731            */
   1732          HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1733          { 
   1734            /* Check the parameters */
   1735            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1736            
   1737            /* Disable the Input Capture channel */
   1738            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1739            
   1740            /* Disable the Peripheral */
   1741            __HAL_TIM_DISABLE(htim); 
   1742            
   1743            /* Return function status */
   1744            return HAL_OK;
   1745          }
   1746          
   1747          /**
   1748            * @brief  Starts the TIM Input Capture measurement in interrupt mode.
   1749            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1750            *                the configuration information for TIM module.
   1751            * @param  Channel: TIM Channels to be enabled.
   1752            *          This parameter can be one of the following values:
   1753            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1754            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1755            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1756            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1757            * @retval HAL status
   1758            */
   1759          HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1760          {
   1761            /* Check the parameters */
   1762            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1763            
   1764            switch (Channel)
   1765            {
   1766              case TIM_CHANNEL_1:
   1767              {       
   1768                /* Enable the TIM Capture/Compare 1 interrupt */
   1769                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   1770              }
   1771              break;
   1772              
   1773              case TIM_CHANNEL_2:
   1774              {
   1775                /* Enable the TIM Capture/Compare 2 interrupt */
   1776                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   1777              }
   1778              break;
   1779              
   1780              case TIM_CHANNEL_3:
   1781              {
   1782                /* Enable the TIM Capture/Compare 3 interrupt */
   1783                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   1784              }
   1785              break;
   1786              
   1787              case TIM_CHANNEL_4:
   1788              {
   1789                /* Enable the TIM Capture/Compare 4 interrupt */
   1790                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   1791              }
   1792              break;
   1793              
   1794              default:
   1795              break;
   1796            }  
   1797            /* Enable the Input Capture channel */
   1798            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1799              
   1800            /* Enable the Peripheral */
   1801            __HAL_TIM_ENABLE(htim);  
   1802          
   1803            /* Return function status */
   1804            return HAL_OK;  
   1805          } 
   1806          
   1807          /**
   1808            * @brief  Stops the TIM Input Capture measurement in interrupt mode.
   1809            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1810            *                the configuration information for TIM module.
   1811            * @param  Channel : TIM Channels to be disabled
   1812            *          This parameter can be one of the following values:
   1813            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1814            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1815            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1816            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1817            * @retval HAL status
   1818            */
   1819          HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1820          {
   1821            /* Check the parameters */
   1822            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1823            
   1824            switch (Channel)
   1825            {
   1826              case TIM_CHANNEL_1:
   1827              {       
   1828                /* Disable the TIM Capture/Compare 1 interrupt */
   1829                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   1830              }
   1831              break;
   1832              
   1833              case TIM_CHANNEL_2:
   1834              {
   1835                /* Disable the TIM Capture/Compare 2 interrupt */
   1836                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   1837              }
   1838              break;
   1839              
   1840              case TIM_CHANNEL_3:
   1841              {
   1842                /* Disable the TIM Capture/Compare 3 interrupt */
   1843                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   1844              }
   1845              break;
   1846              
   1847              case TIM_CHANNEL_4:
   1848              {
   1849                /* Disable the TIM Capture/Compare 4 interrupt */
   1850                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   1851              }
   1852              break;
   1853              
   1854              default:
   1855              break; 
   1856            } 
   1857            
   1858            /* Disable the Input Capture channel */
   1859            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
   1860            
   1861            /* Disable the Peripheral */
   1862            __HAL_TIM_DISABLE(htim); 
   1863            
   1864            /* Return function status */
   1865            return HAL_OK;
   1866          }
   1867          
   1868          /**
   1869            * @brief  Starts the TIM Input Capture measurement on in DMA mode.
   1870            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1871            *                the configuration information for TIM module.
   1872            * @param  Channel : TIM Channels to be enabled
   1873            *          This parameter can be one of the following values:
   1874            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1875            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1876            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1877            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1878            * @param  pData: The destination Buffer address.
   1879            * @param  Length: The length of data to be transferred from TIM peripheral to memory.
   1880            * @retval HAL status
   1881            */
   1882          HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1883          {
   1884            /* Check the parameters */
   1885            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1886            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1887            
   1888            if((htim->State == HAL_TIM_STATE_BUSY))
   1889            {
   1890               return HAL_BUSY;
   1891            }
   1892            else if((htim->State == HAL_TIM_STATE_READY))
   1893            {
   1894              if((pData == 0 ) && (Length > 0)) 
   1895              {
   1896                return HAL_ERROR;                                    
   1897              }
   1898              else
   1899              {
   1900                htim->State = HAL_TIM_STATE_BUSY;
   1901              }
   1902            }  
   1903             
   1904            switch (Channel)
   1905            {
   1906              case TIM_CHANNEL_1:
   1907              {
   1908                /* Set the DMA Period elapsed callback */
   1909                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   1910               
   1911                /* Set the DMA error callback */
   1912                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   1913                
   1914                /* Enable the DMA Stream */
   1915                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length); 
   1916                
   1917                /* Enable the TIM Capture/Compare 1 DMA request */      
   1918                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   1919              }
   1920              break;
   1921              
   1922              case TIM_CHANNEL_2:
   1923              {
   1924                /* Set the DMA Period elapsed callback */
   1925                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   1926               
   1927                /* Set the DMA error callback */
   1928                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   1929                
   1930                /* Enable the DMA Stream */
   1931                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
   1932                
   1933                /* Enable the TIM Capture/Compare 2  DMA request */
   1934                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   1935              }
   1936              break;
   1937              
   1938              case TIM_CHANNEL_3:
   1939              {
   1940                /* Set the DMA Period elapsed callback */
   1941                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   1942               
   1943                /* Set the DMA error callback */
   1944                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   1945                
   1946                /* Enable the DMA Stream */
   1947                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
   1948                
   1949                /* Enable the TIM Capture/Compare 3  DMA request */
   1950                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   1951              }
   1952              break;
   1953              
   1954              case TIM_CHANNEL_4:
   1955              {
   1956                /* Set the DMA Period elapsed callback */
   1957                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   1958               
   1959                /* Set the DMA error callback */
   1960                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   1961                
   1962                /* Enable the DMA Stream */
   1963                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
   1964                
   1965                /* Enable the TIM Capture/Compare 4  DMA request */
   1966                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   1967              }
   1968              break;
   1969              
   1970              default:
   1971              break;
   1972            }
   1973          
   1974            /* Enable the Input Capture channel */
   1975            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1976             
   1977            /* Enable the Peripheral */
   1978            __HAL_TIM_ENABLE(htim); 
   1979            
   1980            /* Return function status */
   1981            return HAL_OK;
   1982          }
   1983          
   1984          /**
   1985            * @brief  Stops the TIM Input Capture measurement on in DMA mode.
   1986            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1987            *                the configuration information for TIM module.
   1988            * @param  Channel : TIM Channels to be disabled
   1989            *          This parameter can be one of the following values:
   1990            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1991            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1992            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1993            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1994            * @retval HAL status
   1995            */
   1996          HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1997          {
   1998            /* Check the parameters */
   1999            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   2000            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2001            
   2002            switch (Channel)
   2003            {
   2004              case TIM_CHANNEL_1:
   2005              {       
   2006                /* Disable the TIM Capture/Compare 1 DMA request */
   2007                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   2008              }
   2009              break;
   2010              
   2011              case TIM_CHANNEL_2:
   2012              {
   2013                /* Disable the TIM Capture/Compare 2 DMA request */
   2014                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   2015              }
   2016              break;
   2017              
   2018              case TIM_CHANNEL_3:
   2019              {
   2020                /* Disable the TIM Capture/Compare 3  DMA request */
   2021                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   2022              }
   2023              break;
   2024              
   2025              case TIM_CHANNEL_4:
   2026              {
   2027                /* Disable the TIM Capture/Compare 4  DMA request */
   2028                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   2029              }
   2030              break;
   2031              
   2032              default:
   2033              break;
   2034            }
   2035          
   2036            /* Disable the Input Capture channel */
   2037            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   2038            
   2039            /* Disable the Peripheral */
   2040            __HAL_TIM_DISABLE(htim); 
   2041            
   2042            /* Change the htim state */
   2043            htim->State = HAL_TIM_STATE_READY;
   2044            
   2045            /* Return function status */
   2046            return HAL_OK;
   2047          }
   2048          
   2049          /**
   2050            * @brief  Starts the TIM One Pulse signal generation.
   2051            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2052            *                the configuration information for TIM module.
   2053            * @param  OutputChannel : TIM Channels to be enabled.
   2054            *          This parameter can be one of the following values:
   2055            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2056            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2057            * @retval HAL status
   2058            */
   2059          HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2060          {
   2061            /* Enable the Capture compare and the Input Capture channels 
   2062              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2063              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2064              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2065              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2066              
   2067              No need to enable the counter, it's enabled automatically by hardware 
   2068              (the counter starts in response to a stimulus and generate a pulse */
   2069            
   2070            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
   2071            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2072            
   2073            /* Return function status */
   2074            return HAL_OK;
   2075          }
   2076          
   2077          /**
   2078            * @brief  Stops the TIM One Pulse signal generation.
   2079            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2080            *                the configuration information for TIM module.
   2081            * @param  OutputChannel : TIM Channels to be disable.
   2082            *          This parameter can be one of the following values:
   2083            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2084            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2085            * @retval HAL status
   2086            */
   2087          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2088          {
   2089            /* Disable the Capture compare and the Input Capture channels 
   2090            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2091            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2092            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2093            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2094            
   2095            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   2096            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2097              
   2098            /* Disable the Peripheral */
   2099            __HAL_TIM_DISABLE(htim); 
   2100            
   2101            /* Return function status */
   2102            return HAL_OK;
   2103          }
   2104          
   2105          /**
   2106            * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
   2107            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2108            *                the configuration information for TIM module.
   2109            * @param  OutputChannel: TIM Channels to be enabled.
   2110            *          This parameter can be one of the following values:
   2111            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2112            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2113            * @retval HAL status
   2114            */
   2115          HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2116          {
   2117            /* Enable the Capture compare and the Input Capture channels 
   2118              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2119              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2120              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2121              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2122              
   2123              No need to enable the counter, it's enabled automatically by hardware 
   2124              (the counter starts in response to a stimulus and generate a pulse */
   2125           
   2126            /* Enable the TIM Capture/Compare 1 interrupt */
   2127            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2128            
   2129            /* Enable the TIM Capture/Compare 2 interrupt */
   2130            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   2131            
   2132            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
   2133            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   2134            
   2135            /* Return function status */
   2136            return HAL_OK;
   2137          }
   2138          
   2139          /**
   2140            * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
   2141            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2142            *                the configuration information for TIM module.
   2143            * @param  OutputChannel: TIM Channels to be enabled.
   2144            *          This parameter can be one of the following values:
   2145            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2146            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2147            * @retval HAL status
   2148            */
   2149          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2150          {
   2151            /* Disable the TIM Capture/Compare 1 interrupt */
   2152            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);  
   2153            
   2154            /* Disable the TIM Capture/Compare 2 interrupt */
   2155            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2156            
   2157            /* Disable the Capture compare and the Input Capture channels 
   2158            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2159            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2160            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2161            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */  
   2162            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   2163            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2164              
   2165            /* Disable the Peripheral */
   2166             __HAL_TIM_DISABLE(htim);  
   2167            
   2168            /* Return function status */
   2169            return HAL_OK;
   2170          }
   2171          
   2172          /**
   2173            * @brief  Starts the TIM Encoder Interface.
   2174            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2175            *                the configuration information for TIM module.
   2176            * @param  Channel: TIM Channels to be enabled.
   2177            *          This parameter can be one of the following values:
   2178            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2179            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2180            * @retval HAL status
   2181            */
   2182          HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   2183          {
   2184            /* Check the parameters */
   2185            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2186            
   2187            /* Enable the encoder interface channels */
   2188            switch (Channel)
   2189            {
   2190              case TIM_CHANNEL_1:
   2191              {
   2192                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2193                break; 
   2194              }
   2195              case TIM_CHANNEL_2:
   2196              { 
   2197                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   2198                break;
   2199              }  
   2200              default :
   2201              {
   2202               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2203               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2204               break; 
   2205              }
   2206            }  
   2207            /* Enable the Peripheral */
   2208            __HAL_TIM_ENABLE(htim);
   2209            
   2210            /* Return function status */
   2211            return HAL_OK;
   2212          }
   2213          
   2214          /**
   2215            * @brief  Stops the TIM Encoder Interface.
   2216            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2217            *                the configuration information for TIM module.
   2218            * @param  Channel: TIM Channels to be disabled.
   2219            *          This parameter can be one of the following values:
   2220            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2221            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2222            * @retval HAL status
   2223            */
   2224          HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   2225          {
   2226            /* Check the parameters */
   2227              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2228              
   2229             /* Disable the Input Capture channels 1 and 2
   2230              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2231            switch (Channel)
   2232            {
   2233              case TIM_CHANNEL_1:
   2234              {
   2235                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2236                break; 
   2237              }
   2238              case TIM_CHANNEL_2:
   2239              { 
   2240                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   2241                break;
   2242              }  
   2243              default :
   2244              {
   2245               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2246               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2247               break; 
   2248              }
   2249            }  
   2250            /* Disable the Peripheral */
   2251            __HAL_TIM_DISABLE(htim);
   2252            
   2253            /* Return function status */
   2254            return HAL_OK;
   2255          }
   2256          
   2257          /**
   2258            * @brief  Starts the TIM Encoder Interface in interrupt mode.
   2259            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2260            *                the configuration information for TIM module.
   2261            * @param  Channel: TIM Channels to be enabled.
   2262            *          This parameter can be one of the following values:
   2263            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2264            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2265            * @retval HAL status
   2266            */
   2267          HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2268          {
   2269            /* Check the parameters */
   2270            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2271            
   2272            /* Enable the encoder interface channels */
   2273            /* Enable the capture compare Interrupts 1 and/or 2 */
   2274            switch (Channel)
   2275            {
   2276              case TIM_CHANNEL_1:
   2277              {
   2278                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2279                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2280                break; 
   2281              }
   2282              case TIM_CHANNEL_2:
   2283              { 
   2284                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2285                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2); 
   2286                break;
   2287              }  
   2288              default :
   2289              {
   2290               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2291               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2292               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2293               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   2294               break; 
   2295              }
   2296            }
   2297            
   2298            /* Enable the Peripheral */
   2299            __HAL_TIM_ENABLE(htim);
   2300            
   2301            /* Return function status */
   2302            return HAL_OK;
   2303          }
   2304          
   2305          /**
   2306            * @brief  Stops the TIM Encoder Interface in interrupt mode.
   2307            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2308            *                the configuration information for TIM module.
   2309            * @param  Channel: TIM Channels to be disabled.
   2310            *          This parameter can be one of the following values:
   2311            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2312            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2313            * @retval HAL status
   2314            */
   2315          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2316          {
   2317            /* Check the parameters */
   2318            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2319              
   2320            /* Disable the Input Capture channels 1 and 2
   2321              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2322            if(Channel == TIM_CHANNEL_1)
   2323            {
   2324              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   2325              
   2326              /* Disable the capture compare Interrupts 1 */
   2327            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2328            }  
   2329            else if(Channel == TIM_CHANNEL_2)
   2330            {  
   2331              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   2332              
   2333              /* Disable the capture compare Interrupts 2 */
   2334            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2335            }  
   2336            else
   2337            {
   2338              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   2339              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   2340              
   2341              /* Disable the capture compare Interrupts 1 and 2 */
   2342              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2343              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2344            }
   2345              
   2346            /* Disable the Peripheral */
   2347            __HAL_TIM_DISABLE(htim);
   2348            
   2349            /* Change the htim state */
   2350            htim->State = HAL_TIM_STATE_READY;
   2351            
   2352            /* Return function status */
   2353            return HAL_OK;
   2354          }
   2355          
   2356          /**
   2357            * @brief  Starts the TIM Encoder Interface in DMA mode.
   2358            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2359            *                the configuration information for TIM module.
   2360            * @param  Channel: TIM Channels to be enabled.
   2361            *          This parameter can be one of the following values:
   2362            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2363            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2364            * @param  pData1: The destination Buffer address for IC1.
   2365            * @param  pData2: The destination Buffer address for IC2.
   2366            * @param  Length: The length of data to be transferred from TIM peripheral to memory.
   2367            * @retval HAL status
   2368            */
   2369          HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
   2370          {
   2371            /* Check the parameters */
   2372            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2373            
   2374            if((htim->State == HAL_TIM_STATE_BUSY))
   2375            {
   2376               return HAL_BUSY;
   2377            }
   2378            else if((htim->State == HAL_TIM_STATE_READY))
   2379            {
   2380              if((((pData1 == 0) || (pData2 == 0) )) && (Length > 0)) 
   2381              {
   2382                return HAL_ERROR;                                    
   2383              }
   2384              else
   2385              {
   2386                htim->State = HAL_TIM_STATE_BUSY;
   2387              }
   2388            }  
   2389             
   2390            switch (Channel)
   2391            {
   2392              case TIM_CHANNEL_1:
   2393              {
   2394                /* Set the DMA Period elapsed callback */
   2395                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   2396               
   2397                /* Set the DMA error callback */
   2398                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   2399                
   2400                /* Enable the DMA Stream */
   2401                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length); 
   2402                
   2403                /* Enable the TIM Input Capture DMA request */      
   2404                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   2405                      
   2406                /* Enable the Peripheral */
   2407                __HAL_TIM_ENABLE(htim);
   2408                
   2409                /* Enable the Capture compare channel */
   2410                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2411              }
   2412              break;
   2413              
   2414              case TIM_CHANNEL_2:
   2415              {
   2416                /* Set the DMA Period elapsed callback */
   2417                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   2418               
   2419                /* Set the DMA error callback */
   2420                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError;
   2421                /* Enable the DMA Stream */
   2422                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   2423                
   2424                /* Enable the TIM Input Capture  DMA request */
   2425                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   2426               
   2427                /* Enable the Peripheral */
   2428                __HAL_TIM_ENABLE(htim);
   2429                
   2430                /* Enable the Capture compare channel */
   2431                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2432              }
   2433              break;
   2434              
   2435              case TIM_CHANNEL_ALL:
   2436              {
   2437                /* Set the DMA Period elapsed callback */
   2438                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   2439               
   2440                /* Set the DMA error callback */
   2441                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   2442                
   2443                /* Enable the DMA Stream */
   2444                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
   2445                
   2446                /* Set the DMA Period elapsed callback */
   2447                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   2448               
   2449                /* Set the DMA error callback */
   2450                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   2451                
   2452                /* Enable the DMA Stream */
   2453                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   2454                    
   2455               /* Enable the Peripheral */
   2456                __HAL_TIM_ENABLE(htim);
   2457                
   2458                /* Enable the Capture compare channel */
   2459                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2460                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2461                
   2462                /* Enable the TIM Input Capture  DMA request */
   2463                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   2464                /* Enable the TIM Input Capture  DMA request */
   2465                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   2466              }
   2467              break;
   2468              
   2469              default:
   2470              break;
   2471            }  
   2472            /* Return function status */
   2473            return HAL_OK;
   2474          }
   2475          
   2476          /**
   2477            * @brief  Stops the TIM Encoder Interface in DMA mode.
   2478            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2479            *                the configuration information for TIM module.
   2480            * @param  Channel: TIM Channels to be enabled.
   2481            *          This parameter can be one of the following values:
   2482            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2483            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2484            * @retval HAL status
   2485            */
   2486          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   2487          {
   2488            /* Check the parameters */
   2489            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2490            
   2491            /* Disable the Input Capture channels 1 and 2
   2492              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2493            if(Channel == TIM_CHANNEL_1)
   2494            {
   2495              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   2496              
   2497              /* Disable the capture compare DMA Request 1 */
   2498              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   2499            }  
   2500            else if(Channel == TIM_CHANNEL_2)
   2501            {  
   2502              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   2503              
   2504              /* Disable the capture compare DMA Request 2 */
   2505              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   2506            }  
   2507            else
   2508            {
   2509              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   2510              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   2511              
   2512              /* Disable the capture compare DMA Request 1 and 2 */
   2513              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   2514              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   2515            }
   2516            
   2517            /* Disable the Peripheral */
   2518            __HAL_TIM_DISABLE(htim);
   2519            
   2520            /* Change the htim state */
   2521            htim->State = HAL_TIM_STATE_READY;
   2522            
   2523            /* Return function status */
   2524            return HAL_OK;
   2525          }
   2526          
   2527          /**
   2528            * @}
   2529            */
   2530          
   2531          /** @defgroup TIM_Group3 Peripheral Control functions
   2532           *  @brief    Peripheral Control functions 
   2533           *
   2534          @verbatim
   2535            ==============================================================================
   2536                       ##### Peripheral Control functions #####
   2537            ==============================================================================
   2538           [..]
   2539             This section provides functions allowing to:
   2540                (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode. 
   2541                (+) Configure External Clock source.
   2542                (+) Configure Master and the Slave synchronization.
   2543                (+) Configure the DMA Burst Mode.
   2544                
   2545          @endverbatim
   2546            * @{
   2547            */
   2548          /**
   2549            * @brief  Initializes the TIM Output Compare Channels according to the specified
   2550            *         parameters in the TIM_OC_InitTypeDef.
   2551            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2552            *                the configuration information for TIM module.
   2553            * @param  sConfig: TIM Output Compare configuration structure
   2554            * @param  Channel: TIM Channels to be enabled.
   2555            *          This parameter can be one of the following values:
   2556            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2557            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2558            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2559            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   2560            * @retval HAL status
   2561            */
   2562          HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   2563          {
   2564            /* Check the parameters */ 
   2565            assert_param(IS_TIM_CHANNELS(Channel)); 
   2566            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   2567            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   2568            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   2569            
   2570            /* Check input state */
   2571            __HAL_LOCK(htim); 
   2572            
   2573            htim->State = HAL_TIM_STATE_BUSY;
   2574            
   2575            switch (Channel)
   2576            {
   2577              case TIM_CHANNEL_1:
   2578              {
   2579                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   2580                /* Configure the TIM Channel 1 in Output Compare */
   2581                TIM_OC1_SetConfig(htim->Instance, sConfig);
   2582              }
   2583              break;
   2584              
   2585              case TIM_CHANNEL_2:
   2586              {
   2587                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2588                /* Configure the TIM Channel 2 in Output Compare */
   2589                TIM_OC2_SetConfig(htim->Instance, sConfig);
   2590              }
   2591              break;
   2592              
   2593              case TIM_CHANNEL_3:
   2594              {
   2595                 assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   2596                /* Configure the TIM Channel 3 in Output Compare */
   2597                TIM_OC3_SetConfig(htim->Instance, sConfig);
   2598              }
   2599              break;
   2600              
   2601              case TIM_CHANNEL_4:
   2602              {
   2603                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   2604                /* Configure the TIM Channel 4 in Output Compare */
   2605                TIM_OC4_SetConfig(htim->Instance, sConfig);
   2606              }
   2607              break;
   2608              
   2609              default:
   2610              break;    
   2611            }
   2612            htim->State = HAL_TIM_STATE_READY;
   2613            
   2614            __HAL_UNLOCK(htim); 
   2615            
   2616            return HAL_OK;
   2617          }
   2618          
   2619          /**
   2620            * @brief  Initializes the TIM Input Capture Channels according to the specified
   2621            *         parameters in the TIM_IC_InitTypeDef.
   2622            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2623            *                the configuration information for TIM module.
   2624            * @param  sConfig: TIM Input Capture configuration structure
   2625            * @param  Channel: TIM Channels to be enabled.
   2626            *          This parameter can be one of the following values:
   2627            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2628            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2629            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2630            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   2631            * @retval HAL status
   2632            */
   2633          HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
   2634          {
   2635            /* Check the parameters */
   2636            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   2637            assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
   2638            assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
   2639            assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
   2640            assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
   2641            
   2642            __HAL_LOCK(htim);
   2643            
   2644            htim->State = HAL_TIM_STATE_BUSY;
   2645            
   2646            if (Channel == TIM_CHANNEL_1)
   2647            {
   2648              /* TI1 Configuration */
   2649              TIM_TI1_SetConfig(htim->Instance,
   2650                         sConfig->ICPolarity,
   2651                         sConfig->ICSelection,
   2652                         sConfig->ICFilter);
   2653                         
   2654              /* Reset the IC1PSC Bits */
   2655              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   2656          
   2657              /* Set the IC1PSC value */
   2658              htim->Instance->CCMR1 |= sConfig->ICPrescaler;
   2659            }
   2660            else if (Channel == TIM_CHANNEL_2)
   2661            {
   2662              /* TI2 Configuration */
   2663              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2664              
   2665              TIM_TI2_SetConfig(htim->Instance, 
   2666                                sConfig->ICPolarity,
   2667                                sConfig->ICSelection,
   2668                                sConfig->ICFilter);
   2669                         
   2670              /* Reset the IC2PSC Bits */
   2671              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   2672          
   2673              /* Set the IC2PSC value */
   2674              htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8);
   2675            }
   2676            else if (Channel == TIM_CHANNEL_3)
   2677            {
   2678              /* TI3 Configuration */
   2679              assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   2680              
   2681              TIM_TI3_SetConfig(htim->Instance,  
   2682                         sConfig->ICPolarity,
   2683                         sConfig->ICSelection,
   2684                         sConfig->ICFilter);
   2685                         
   2686              /* Reset the IC3PSC Bits */
   2687              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   2688          
   2689              /* Set the IC3PSC value */
   2690              htim->Instance->CCMR2 |= sConfig->ICPrescaler;
   2691            }
   2692            else
   2693            {
   2694              /* TI4 Configuration */
   2695              assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   2696              
   2697              TIM_TI4_SetConfig(htim->Instance, 
   2698                         sConfig->ICPolarity,
   2699                         sConfig->ICSelection,
   2700                         sConfig->ICFilter);
   2701                         
   2702              /* Reset the IC4PSC Bits */
   2703              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   2704          
   2705              /* Set the IC4PSC value */
   2706              htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8);
   2707            }
   2708            
   2709            htim->State = HAL_TIM_STATE_READY;
   2710              
   2711            __HAL_UNLOCK(htim);
   2712            
   2713            return HAL_OK; 
   2714          }
   2715          
   2716          /**
   2717            * @brief  Initializes the TIM PWM  channels according to the specified
   2718            *         parameters in the TIM_OC_InitTypeDef.
   2719            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2720            *                the configuration information for TIM module.
   2721            * @param  sConfig: TIM PWM configuration structure
   2722            * @param  Channel: TIM Channels to be enabled.
   2723            *          This parameter can be one of the following values:
   2724            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2725            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2726            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2727            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2728            * @retval HAL status
   2729            */
   2730          HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   2731          {
   2732            __HAL_LOCK(htim);
   2733            
   2734            /* Check the parameters */ 
   2735            assert_param(IS_TIM_CHANNELS(Channel)); 
   2736            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   2737            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   2738            
   2739            htim->State = HAL_TIM_STATE_BUSY;
   2740              
   2741            switch (Channel)
   2742            {
   2743              case TIM_CHANNEL_1:
   2744              {
   2745                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   2746                /* Configure the Channel 1 in PWM mode */
   2747                TIM_OC1_SetConfig(htim->Instance, sConfig);
   2748                
   2749                /* Set the Preload enable bit for channel1 */
   2750                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   2751                
   2752                /* Configure the Output Fast mode */
   2753                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   2754                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   2755              }
   2756              break;
   2757              
   2758              case TIM_CHANNEL_2:
   2759              {
   2760                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2761                /* Configure the Channel 2 in PWM mode */
   2762                TIM_OC2_SetConfig(htim->Instance, sConfig);
   2763                
   2764                /* Set the Preload enable bit for channel2 */
   2765                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   2766                
   2767                /* Configure the Output Fast mode */
   2768                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   2769                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
   2770              }
   2771              break;
   2772              
   2773              case TIM_CHANNEL_3:
   2774              {
   2775                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   2776                /* Configure the Channel 3 in PWM mode */
   2777                TIM_OC3_SetConfig(htim->Instance, sConfig);
   2778                
   2779                /* Set the Preload enable bit for channel3 */
   2780                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   2781                
   2782               /* Configure the Output Fast mode */
   2783                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   2784                htim->Instance->CCMR2 |= sConfig->OCFastMode;  
   2785              }
   2786              break;
   2787              
   2788              case TIM_CHANNEL_4:
   2789              {
   2790                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   2791                /* Configure the Channel 4 in PWM mode */
   2792                TIM_OC4_SetConfig(htim->Instance, sConfig);
   2793                
   2794                /* Set the Preload enable bit for channel4 */
   2795                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   2796                
   2797               /* Configure the Output Fast mode */
   2798                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   2799                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
   2800              }
   2801              break;
   2802              
   2803              default:
   2804              break;    
   2805            }
   2806            
   2807            htim->State = HAL_TIM_STATE_READY;
   2808              
   2809            __HAL_UNLOCK(htim);
   2810            
   2811            return HAL_OK;
   2812          }
   2813          
   2814          /**
   2815            * @brief  Initializes the TIM One Pulse Channels according to the specified
   2816            *         parameters in the TIM_OnePulse_InitTypeDef.
   2817            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2818            *                the configuration information for TIM module.
   2819            * @param  sConfig: TIM One Pulse configuration structure
   2820            * @param  OutputChannel: TIM Channels to be enabled.
   2821            *          This parameter can be one of the following values:
   2822            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2823            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2824            * @param  InputChannel: TIM Channels to be enabled.
   2825            *          This parameter can be one of the following values:
   2826            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2827            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2828            * @retval HAL status
   2829            */
   2830          HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
   2831          {
   2832            TIM_OC_InitTypeDef temp1;
   2833            
   2834            /* Check the parameters */
   2835            assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
   2836            assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
   2837          
   2838            if(OutputChannel != InputChannel)  
   2839            {
   2840              __HAL_LOCK(htim);
   2841            
   2842              htim->State = HAL_TIM_STATE_BUSY;
   2843          
   2844              /* Extract the Ouput compare configuration from sConfig structure */  
   2845              temp1.OCMode = sConfig->OCMode;
   2846              temp1.Pulse = sConfig->Pulse;
   2847              temp1.OCPolarity = sConfig->OCPolarity; 
   2848              
   2849              switch (OutputChannel)
   2850              {
   2851                case TIM_CHANNEL_1:
   2852                {
   2853                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   2854                
   2855                  TIM_OC1_SetConfig(htim->Instance, &temp1); 
   2856                }
   2857                break;
   2858                case TIM_CHANNEL_2:
   2859                {
   2860                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2861                
   2862                  TIM_OC2_SetConfig(htim->Instance, &temp1);
   2863                }
   2864                break;
   2865                default:
   2866                break;  
   2867              } 
   2868              switch (InputChannel)
   2869              {
   2870                case TIM_CHANNEL_1:
   2871                {
   2872                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   2873                
   2874                  TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
   2875                                  sConfig->ICSelection, sConfig->ICFilter);
   2876                         
   2877                  /* Reset the IC1PSC Bits */
   2878                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   2879          
   2880                  /* Select the Trigger source */
   2881                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   2882                  htim->Instance->SMCR |= TIM_TS_TI1FP1;
   2883                
   2884                  /* Select the Slave Mode */      
   2885                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   2886                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   2887                }
   2888                break;
   2889                case TIM_CHANNEL_2:
   2890                {
   2891                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2892                
   2893                  TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
   2894                           sConfig->ICSelection, sConfig->ICFilter);
   2895                         
   2896                  /* Reset the IC2PSC Bits */
   2897                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   2898          
   2899                  /* Select the Trigger source */
   2900                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   2901                  htim->Instance->SMCR |= TIM_TS_TI2FP2;
   2902                
   2903                  /* Select the Slave Mode */      
   2904                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   2905                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   2906                }
   2907                break;
   2908              
   2909                default:
   2910                break;  
   2911              }
   2912            
   2913              htim->State = HAL_TIM_STATE_READY;
   2914              
   2915              __HAL_UNLOCK(htim);
   2916            
   2917              return HAL_OK;
   2918            }
   2919            else
   2920            {
   2921              return HAL_ERROR;
   2922            }
   2923          }
   2924          
   2925          /**
   2926            * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral  
   2927            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2928            *                the configuration information for TIM module.
   2929            * @param  BurstBaseAddress: TIM Base address from when the DMA will starts the Data write.
   2930            *         This parameters can be on of the following values:
   2931            *            @arg TIM_DMABase_CR1  
   2932            *            @arg TIM_DMABase_CR2
   2933            *            @arg TIM_DMABase_SMCR
   2934            *            @arg TIM_DMABase_DIER
   2935            *            @arg TIM_DMABase_SR
   2936            *            @arg TIM_DMABase_EGR
   2937            *            @arg TIM_DMABase_CCMR1
   2938            *            @arg TIM_DMABase_CCMR2
   2939            *            @arg TIM_DMABase_CCER
   2940            *            @arg TIM_DMABase_CNT   
   2941            *            @arg TIM_DMABase_PSC   
   2942            *            @arg TIM_DMABase_ARR
   2943            *            @arg TIM_DMABase_CCR1
   2944            *            @arg TIM_DMABase_CCR2
   2945            *            @arg TIM_DMABase_CCR3  
   2946            *            @arg TIM_DMABase_CCR4
   2947            *            @arg TIM_DMABase_DCR
   2948            * @param  BurstRequestSrc: TIM DMA Request sources.
   2949            *         This parameters can be on of the following values:
   2950            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   2951            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   2952            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   2953            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   2954            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   2955            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   2956            * @param  BurstBuffer: The Buffer address.
   2957            * @param  BurstLength: DMA Burst length. This parameter can be one value
   2958            *         between TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
   2959            * @retval HAL status
   2960            */
   2961          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   2962                                                        uint32_t* BurstBuffer, uint32_t  BurstLength)
   2963          {
   2964            /* Check the parameters */
   2965            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   2966            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   2967            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   2968            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   2969            
   2970            if((htim->State == HAL_TIM_STATE_BUSY))
   2971            {
   2972               return HAL_BUSY;
   2973            }
   2974            else if((htim->State == HAL_TIM_STATE_READY))
   2975            {
   2976              if((BurstBuffer == 0 ) && (BurstLength > 0)) 
   2977              {
   2978                return HAL_ERROR;                                    
   2979              }
   2980              else
   2981              {
   2982                htim->State = HAL_TIM_STATE_BUSY;
   2983              }
   2984            }
   2985            switch(BurstRequestSrc)
   2986            {
   2987              case TIM_DMA_UPDATE:
   2988              {  
   2989                /* Set the DMA Period elapsed callback */
   2990                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   2991               
   2992                /* Set the DMA error callback */
   2993                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
   2994            
   2995                /* Enable the DMA Stream */
   2996                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1); 
   2997              }
   2998              break;
   2999              case TIM_DMA_CC1:
   3000              {  
   3001                /* Set the DMA Period elapsed callback */
   3002                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   3003               
   3004                /* Set the DMA error callback */
   3005                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   3006            
   3007                /* Enable the DMA Stream */
   3008                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   3009              }
   3010              break;
   3011              case TIM_DMA_CC2:
   3012              {  
   3013                /* Set the DMA Period elapsed callback */
   3014                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   3015               
   3016                /* Set the DMA error callback */
   3017                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   3018            
   3019                /* Enable the DMA Stream */
   3020                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   3021              }
   3022              break;
   3023              case TIM_DMA_CC3:
   3024              {  
   3025                /* Set the DMA Period elapsed callback */
   3026                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   3027               
   3028                /* Set the DMA error callback */
   3029                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   3030            
   3031                /* Enable the DMA Stream */
   3032                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   3033              }
   3034              break;
   3035              case TIM_DMA_CC4:
   3036              {  
   3037                /* Set the DMA Period elapsed callback */
   3038                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   3039               
   3040                /* Set the DMA error callback */
   3041                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   3042            
   3043                /* Enable the DMA Stream */
   3044                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   3045              }
   3046              break;
   3047              case TIM_DMA_TRIGGER:
   3048              {  
   3049                /* Set the DMA Period elapsed callback */
   3050                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   3051               
   3052                /* Set the DMA error callback */
   3053                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
   3054            
   3055                /* Enable the DMA Stream */
   3056                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   3057              }
   3058              break;
   3059              default:
   3060              break;  
   3061            }
   3062             /* configure the DMA Burst Mode */
   3063             htim->Instance->DCR = BurstBaseAddress | BurstLength;  
   3064             
   3065             /* Enable the TIM DMA Request */
   3066             __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);  
   3067             
   3068             htim->State = HAL_TIM_STATE_READY;
   3069            
   3070            /* Return function status */
   3071            return HAL_OK;
   3072          }
   3073          
   3074          /**
   3075            * @brief  Stops the TIM DMA Burst mode 
   3076            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3077            *                the configuration information for TIM module.
   3078            * @param  BurstRequestSrc: TIM DMA Request sources to disable
   3079            * @retval HAL status
   3080            */
   3081          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3082          {
   3083            /* Check the parameters */
   3084            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3085            
   3086            /* Disable the TIM Update DMA request */
   3087            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   3088                
   3089            /* Return function status */
   3090            return HAL_OK;  
   3091          }
   3092          
   3093          /**
   3094            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory 
   3095            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3096            *                the configuration information for TIM module.
   3097            * @param  BurstBaseAddress: TIM Base address from when the DMA will starts the Data read.
   3098            *         This parameters can be on of the following values:
   3099            *            @arg TIM_DMABase_CR1  
   3100            *            @arg TIM_DMABase_CR2
   3101            *            @arg TIM_DMABase_SMCR
   3102            *            @arg TIM_DMABase_DIER
   3103            *            @arg TIM_DMABase_SR
   3104            *            @arg TIM_DMABase_EGR
   3105            *            @arg TIM_DMABase_CCMR1
   3106            *            @arg TIM_DMABase_CCMR2
   3107            *            @arg TIM_DMABase_CCER
   3108            *            @arg TIM_DMABase_CNT   
   3109            *            @arg TIM_DMABase_PSC   
   3110            *            @arg TIM_DMABase_ARR
   3111            *            @arg TIM_DMABase_CCR1
   3112            *            @arg TIM_DMABase_CCR2
   3113            *            @arg TIM_DMABase_CCR3  
   3114            *            @arg TIM_DMABase_CCR4
   3115            *            @arg TIM_DMABase_DCR
   3116            * @param  BurstRequestSrc: TIM DMA Request sources.
   3117            *         This parameters can be on of the following values:
   3118            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3119            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3120            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3121            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3122            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3123            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3124            * @param  BurstBuffer: The Buffer address.
   3125            * @param  BurstLength: DMA Burst length. This parameter can be one value
   3126            *         between TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
   3127            * @retval HAL status
   3128            */
   3129          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3130                                                       uint32_t  *BurstBuffer, uint32_t  BurstLength)
   3131          {
   3132            /* Check the parameters */
   3133            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3134            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3135            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3136            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3137            
   3138            if((htim->State == HAL_TIM_STATE_BUSY))
   3139            {
   3140               return HAL_BUSY;
   3141            }
   3142            else if((htim->State == HAL_TIM_STATE_READY))
   3143            {
   3144              if((BurstBuffer == 0 ) && (BurstLength > 0)) 
   3145              {
   3146                return HAL_ERROR;                                    
   3147              }
   3148              else
   3149              {
   3150                htim->State = HAL_TIM_STATE_BUSY;
   3151              }
   3152            }  
   3153            switch(BurstRequestSrc)
   3154            {
   3155              case TIM_DMA_UPDATE:
   3156              {  
   3157                /* Set the DMA Period elapsed callback */
   3158                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   3159               
   3160                /* Set the DMA error callback */
   3161                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
   3162            
   3163                /* Enable the DMA Stream */
   3164                 HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
   3165              }
   3166              break;
   3167              case TIM_DMA_CC1:
   3168              {  
   3169                /* Set the DMA Period elapsed callback */
   3170                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   3171               
   3172                /* Set the DMA error callback */
   3173                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   3174            
   3175                /* Enable the DMA Stream */
   3176                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   3177              }
   3178              break;
   3179              case TIM_DMA_CC2:
   3180              {  
   3181                /* Set the DMA Period elapsed callback */
   3182                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   3183               
   3184                /* Set the DMA error callback */
   3185                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   3186            
   3187                /* Enable the DMA Stream */
   3188                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
   3189              }
   3190              break;
   3191              case TIM_DMA_CC3:
   3192              {  
   3193                /* Set the DMA Period elapsed callback */
   3194                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   3195               
   3196                /* Set the DMA error callback */
   3197                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   3198            
   3199                /* Enable the DMA Stream */
   3200                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   3201              }
   3202              break;
   3203              case TIM_DMA_CC4:
   3204              {  
   3205                /* Set the DMA Period elapsed callback */
   3206                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   3207               
   3208                /* Set the DMA error callback */
   3209                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   3210            
   3211                /* Enable the DMA Stream */
   3212                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   3213              }
   3214              break;
   3215              case TIM_DMA_TRIGGER:
   3216              {  
   3217                /* Set the DMA Period elapsed callback */
   3218                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   3219               
   3220                /* Set the DMA error callback */
   3221                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
   3222            
   3223                /* Enable the DMA Stream */
   3224                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   3225              }
   3226              break;
   3227              default:
   3228              break;  
   3229            }
   3230          
   3231            /* configure the DMA Burst Mode */
   3232            htim->Instance->DCR = BurstBaseAddress | BurstLength;  
   3233            
   3234            /* Enable the TIM DMA Request */
   3235            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   3236            
   3237            htim->State = HAL_TIM_STATE_READY;
   3238            
   3239            /* Return function status */
   3240            return HAL_OK;
   3241          }
   3242          
   3243          /**
   3244            * @brief  Stop the DMA burst reading 
   3245            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3246            *                the configuration information for TIM module.
   3247            * @param  BurstRequestSrc: TIM DMA Request sources to disable.
   3248            * @retval HAL status
   3249            */
   3250          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3251          {
   3252            /* Check the parameters */
   3253            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3254            
   3255            /* Disable the TIM Update DMA request */
   3256            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   3257                
   3258            /* Return function status */
   3259            return HAL_OK;  
   3260          }
   3261          
   3262          /**
   3263            * @brief  Generate a software event
   3264            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3265            *                the configuration information for TIM module.
   3266            * @param  EventSource: specifies the event source.
   3267            *          This parameter can be one of the following values:
   3268            *            @arg TIM_EventSource_Update: Timer update Event source
   3269            *            @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source
   3270            *            @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source
   3271            *            @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source
   3272            *            @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source  
   3273            *            @arg TIM_EventSource_Trigger: Timer Trigger Event source
   3274            * @note   TIM6 can only generate an update event. 
   3275            * @retval HAL status
   3276            */ 
   3277          
   3278          HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
   3279          {
   3280            /* Check the parameters */
   3281            assert_param(IS_TIM_INSTANCE(htim->Instance));
   3282            assert_param(IS_TIM_EVENT_SOURCE(EventSource));
   3283            
   3284            /* Process Locked */
   3285            __HAL_LOCK(htim);
   3286            
   3287            /* Change the TIM state */
   3288            htim->State = HAL_TIM_STATE_BUSY;
   3289            
   3290            /* Set the event sources */
   3291            htim->Instance->EGR = EventSource;
   3292            
   3293            /* Change the TIM state */
   3294            htim->State = HAL_TIM_STATE_READY;
   3295            
   3296            __HAL_UNLOCK(htim);
   3297            
   3298            /* Return function status */
   3299            return HAL_OK;  
   3300          }
   3301          
   3302          /**
   3303            * @brief  Configures the OCRef clear feature
   3304            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3305            *                the configuration information for TIM module.
   3306            * @param  sClearInputConfig: pointer to a TIM_ClearInputConfigTypeDef structure that
   3307            *         contains the OCREF clear feature and parameters for the TIM peripheral. 
   3308            * @param  Channel: specifies the TIM Channel.
   3309            *          This parameter can be one of the following values:
   3310            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3311            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3312            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3313            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3314            * @retval HAL status
   3315            */ 
   3316          HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
   3317          { 
   3318            /* Check the parameters */
   3319            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3320            assert_param(IS_TIM_CHANNELS(Channel));
   3321            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   3322            assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   3323            assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   3324            assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   3325             
   3326            /* Process Locked */
   3327            __HAL_LOCK(htim);
   3328            
   3329            htim->State = HAL_TIM_STATE_BUSY;
   3330            
   3331            if(sClearInputConfig->ClearInputSource == TIM_CLEARINPUTSOURCE_ETR)
   3332            {
   3333              TIM_ETR_SetConfig(htim->Instance, 
   3334                                sClearInputConfig->ClearInputPrescaler,
   3335                                sClearInputConfig->ClearInputPolarity,
   3336                                sClearInputConfig->ClearInputFilter);
   3337            }
   3338            
   3339            switch (Channel)
   3340            {
   3341              case TIM_CHANNEL_1:
   3342              {        
   3343                if(sClearInputConfig->ClearInputState != RESET)  
   3344                {
   3345                  /* Enable the Ocref clear feature for Channel 1 */
   3346                  htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
   3347                }
   3348                else
   3349                {
   3350                  /* Disable the Ocref clear feature for Channel 1 */
   3351                  htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;      
   3352                }
   3353              }    
   3354              break;
   3355              case TIM_CHANNEL_2:    
   3356              { 
   3357                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
   3358                if(sClearInputConfig->ClearInputState != RESET)  
   3359                {
   3360                  /* Enable the Ocref clear feature for Channel 2 */
   3361                  htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
   3362                }
   3363                else
   3364                {
   3365                  /* Disable the Ocref clear feature for Channel 2 */
   3366                  htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;      
   3367                }
   3368              } 
   3369              break;
   3370              case TIM_CHANNEL_3:   
   3371              {  
   3372                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3373                if(sClearInputConfig->ClearInputState != RESET)  
   3374                {
   3375                  /* Enable the Ocref clear feature for Channel 3 */
   3376                  htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
   3377                }
   3378                else
   3379                {
   3380                  /* Disable the Ocref clear feature for Channel 3 */
   3381                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;      
   3382                }
   3383              } 
   3384              break;
   3385              case TIM_CHANNEL_4:    
   3386              {  
   3387                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3388                if(sClearInputConfig->ClearInputState != RESET)  
   3389                {
   3390                  /* Enable the Ocref clear feature for Channel 4 */
   3391                  htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
   3392                }
   3393                else
   3394                {
   3395                  /* Disable the Ocref clear feature for Channel 4 */
   3396                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;      
   3397                }
   3398              } 
   3399              break;
   3400              default:  
   3401              break;
   3402            } 
   3403          
   3404            htim->State = HAL_TIM_STATE_READY;
   3405            
   3406            __HAL_UNLOCK(htim);
   3407            
   3408            return HAL_OK;  
   3409          }  
   3410          
   3411          /**
   3412            * @brief   Configures the clock source to be used
   3413            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3414            *                the configuration information for TIM module.
   3415            * @param  sClockSourceConfig: pointer to a TIM_ClockConfigTypeDef structure that
   3416            *         contains the clock source information for the TIM peripheral. 
   3417            * @retval HAL status
   3418            */ 
   3419          HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)    
   3420          {
   3421            uint32_t tmpsmcr = 0;
   3422              
   3423            /* Process Locked */
   3424            __HAL_LOCK(htim);
   3425            
   3426            htim->State = HAL_TIM_STATE_BUSY;
   3427            
   3428            /* Check the parameters */
   3429            assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   3430            assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   3431            assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   3432            assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   3433            
   3434            /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
   3435            tmpsmcr = htim->Instance->SMCR;
   3436            tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   3437            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   3438            htim->Instance->SMCR = tmpsmcr;
   3439            
   3440            switch (sClockSourceConfig->ClockSource)
   3441            {
   3442              case TIM_CLOCKSOURCE_INTERNAL:
   3443              { 
   3444                assert_param(IS_TIM_INSTANCE(htim->Instance));      
   3445                /* Disable slave mode to clock the prescaler directly with the internal clock */
   3446                htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   3447              }
   3448              break;
   3449              
   3450              case TIM_CLOCKSOURCE_ETRMODE1:
   3451              {
   3452                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   3453                /* Configure the ETR Clock source */
   3454                TIM_ETR_SetConfig(htim->Instance, 
   3455                                  sClockSourceConfig->ClockPrescaler, 
   3456                                  sClockSourceConfig->ClockPolarity, 
   3457                                  sClockSourceConfig->ClockFilter);
   3458                /* Get the TIMx SMCR register value */
   3459                tmpsmcr = htim->Instance->SMCR;
   3460                /* Reset the SMS and TS Bits */
   3461                tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   3462                /* Select the External clock mode1 and the ETRF trigger */
   3463                tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   3464                /* Write to TIMx SMCR */
   3465                htim->Instance->SMCR = tmpsmcr;
   3466              }
   3467              break;
   3468              
   3469              case TIM_CLOCKSOURCE_ETRMODE2:
   3470              {
   3471                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   3472                /* Configure the ETR Clock source */
   3473                TIM_ETR_SetConfig(htim->Instance, 
   3474                                  sClockSourceConfig->ClockPrescaler, 
   3475                                  sClockSourceConfig->ClockPolarity,
   3476                                  sClockSourceConfig->ClockFilter);
   3477                /* Enable the External clock mode2 */
   3478                htim->Instance->SMCR |= TIM_SMCR_ECE;
   3479              }
   3480              break;
   3481              
   3482              case TIM_CLOCKSOURCE_TI1:
   3483              {
   3484                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3485                TIM_TI1_ConfigInputStage(htim->Instance, 
   3486                                  sClockSourceConfig->ClockPolarity, 
   3487                                  sClockSourceConfig->ClockFilter);
   3488                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   3489              }
   3490              break;
   3491              case TIM_CLOCKSOURCE_TI2:
   3492              {
   3493                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3494                TIM_TI2_ConfigInputStage(htim->Instance, 
   3495                                  sClockSourceConfig->ClockPolarity, 
   3496                                  sClockSourceConfig->ClockFilter);
   3497                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   3498              }
   3499              break;
   3500              case TIM_CLOCKSOURCE_TI1ED:
   3501              {
   3502                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3503                TIM_TI1_ConfigInputStage(htim->Instance, 
   3504                                  sClockSourceConfig->ClockPolarity,
   3505                                  sClockSourceConfig->ClockFilter);
   3506                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   3507              }
   3508              break;
   3509              case TIM_CLOCKSOURCE_ITR0:
   3510              {
   3511                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3512                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
   3513              }
   3514              break;
   3515              case TIM_CLOCKSOURCE_ITR1:
   3516              {
   3517                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3518                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
   3519              }
   3520              break;
   3521              case TIM_CLOCKSOURCE_ITR2:
   3522              {
   3523                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3524                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
   3525              }
   3526              break;
   3527              case TIM_CLOCKSOURCE_ITR3:
   3528              {
   3529                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3530                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
   3531              }
   3532              break;
   3533              
   3534              default:
   3535              break;    
   3536            }
   3537            htim->State = HAL_TIM_STATE_READY;
   3538            
   3539            __HAL_UNLOCK(htim);
   3540            
   3541            return HAL_OK;
   3542          }
   3543          
   3544          /**
   3545            * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
   3546            *         or a XOR combination between CH1_input, CH2_input & CH3_input
   3547            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3548            *                the configuration information for TIM module..
   3549            * @param  TI1_Selection: Indicate whether or not channel 1 is connected to the
   3550            *         output of a XOR gate.
   3551            *         This parameter can be one of the following values:
   3552            *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
   3553            *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
   3554            *            pins are connected to the TI1 input (XOR combination)
   3555            * @retval HAL status
   3556            */
   3557          HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
   3558          {
   3559            uint32_t tmpcr2 = 0;
   3560            
   3561            /* Check the parameters */
   3562            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance)); 
   3563            assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
   3564          
   3565            /* Get the TIMx CR2 register value */
   3566            tmpcr2 = htim->Instance->CR2;
   3567          
   3568            /* Reset the TI1 selection */
   3569            tmpcr2 &= ~TIM_CR2_TI1S;
   3570          
   3571            /* Set the the TI1 selection */
   3572            tmpcr2 |= TI1_Selection;
   3573            
   3574            /* Write to TIMxCR2 */
   3575            htim->Instance->CR2 = tmpcr2;
   3576          
   3577            return HAL_OK;
   3578          }
   3579                                                          
   3580          /**
   3581            * @brief  Configures the TIM in Slave mode
   3582            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3583            *                the configuration information for TIM module..
   3584            * @param  sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that
   3585            *         contains the selected trigger (internal trigger input, filtered
   3586            *         timer input or external trigger input) and the ) and the Slave 
   3587            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1). 
   3588            * @retval HAL status
   3589            */
   3590          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
   3591          {
   3592            uint32_t tmpsmcr = 0;
   3593            uint32_t tmpccmr1 = 0;
   3594            uint32_t tmpccer = 0;
   3595            
   3596            /* Check the parameters */
   3597            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   3598            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   3599            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   3600             
   3601            __HAL_LOCK(htim);
   3602            
   3603            htim->State = HAL_TIM_STATE_BUSY;
   3604          
   3605            /* Get the TIMx SMCR register value */
   3606            tmpsmcr = htim->Instance->SMCR;
   3607          
   3608            /* Reset the Trigger Selection Bits */
   3609            tmpsmcr &= ~TIM_SMCR_TS;
   3610            /* Set the Input Trigger source */
   3611            tmpsmcr |= sSlaveConfig->InputTrigger;
   3612          
   3613            /* Reset the slave mode Bits */
   3614            tmpsmcr &= ~TIM_SMCR_SMS;
   3615            /* Set the slave mode */
   3616            tmpsmcr |= sSlaveConfig->SlaveMode;
   3617          
   3618            /* Write to TIMx SMCR */
   3619            htim->Instance->SMCR = tmpsmcr;
   3620            
   3621            /* Configure the trigger prescaler, filter, and polarity */
   3622            switch (sSlaveConfig->InputTrigger)
   3623            {
   3624            case TIM_TS_ETRF:
   3625              {
   3626                /* Check the parameters */
   3627                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   3628                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   3629                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   3630                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   3631                /* Configure the ETR Trigger source */
   3632                TIM_ETR_SetConfig(htim->Instance, 
   3633                                  sSlaveConfig->TriggerPrescaler, 
   3634                                  sSlaveConfig->TriggerPolarity, 
   3635                                  sSlaveConfig->TriggerFilter);
   3636              }
   3637              break;
   3638              
   3639            case TIM_TS_TI1F_ED:
   3640              {
   3641                /* Check the parameters */
   3642                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3643                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   3644                
   3645                /* Disable the Channel 1: Reset the CC1E Bit */
   3646                tmpccer = htim->Instance->CCER;
   3647                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   3648                tmpccmr1 = htim->Instance->CCMR1;    
   3649                
   3650                /* Set the filter */
   3651                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   3652                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
   3653                
   3654                /* Write to TIMx CCMR1 and CCER registers */
   3655                htim->Instance->CCMR1 = tmpccmr1;
   3656                htim->Instance->CCER = tmpccer;                               
   3657                                         
   3658              }
   3659              break;
   3660              
   3661            case TIM_TS_TI1FP1:
   3662              {
   3663                /* Check the parameters */
   3664                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3665                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   3666                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   3667          
   3668                /* Configure TI1 Filter and Polarity */
   3669                TIM_TI1_ConfigInputStage(htim->Instance,
   3670                                         sSlaveConfig->TriggerPolarity,
   3671                                         sSlaveConfig->TriggerFilter);
   3672              }
   3673              break;
   3674              
   3675            case TIM_TS_TI2FP2:
   3676              {
   3677                /* Check the parameters */
   3678                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3679                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   3680                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   3681                
   3682                /* Configure TI2 Filter and Polarity */
   3683                TIM_TI2_ConfigInputStage(htim->Instance,
   3684                                          sSlaveConfig->TriggerPolarity,
   3685                                          sSlaveConfig->TriggerFilter);
   3686              }
   3687              break;
   3688              
   3689            case TIM_TS_ITR0:
   3690              {
   3691                /* Check the parameter */
   3692                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3693              }
   3694              break;
   3695              
   3696            case TIM_TS_ITR1:
   3697              {
   3698                /* Check the parameter */
   3699                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3700              }
   3701              break;
   3702              
   3703            case TIM_TS_ITR2:
   3704              {
   3705                /* Check the parameter */
   3706                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3707              }
   3708              break;
   3709              
   3710            case TIM_TS_ITR3:
   3711              {
   3712                /* Check the parameter */
   3713                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3714              }
   3715              break;
   3716                 
   3717            default:
   3718              break;
   3719            }
   3720            
   3721            htim->State = HAL_TIM_STATE_READY;
   3722               
   3723            __HAL_UNLOCK(htim);  
   3724            
   3725            return HAL_OK;
   3726          } 
   3727          
   3728          /**
   3729            * @brief  Read the captured value from Capture Compare unit
   3730            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3731            *                the configuration information for TIM module..
   3732            * @param  Channel: TIM Channels to be enabled.
   3733            *          This parameter can be one of the following values:
   3734            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3735            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3736            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3737            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3738            * @retval Captured value
   3739            */
   3740          uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
   3741          {
   3742            uint32_t tmpreg = 0;
   3743            
   3744            __HAL_LOCK(htim);
   3745            
   3746            switch (Channel)
   3747            {
   3748              case TIM_CHANNEL_1:
   3749              {
   3750                /* Check the parameters */
   3751                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3752                
   3753                /* Return the capture 1 value */
   3754                tmpreg = htim->Instance->CCR1;
   3755                
   3756                break;
   3757              }
   3758              case TIM_CHANNEL_2:
   3759              {
   3760                /* Check the parameters */
   3761                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3762                
   3763                /* Return the capture 2 value */
   3764                tmpreg = htim->Instance->CCR2;
   3765                
   3766                break;
   3767              }
   3768              
   3769              case TIM_CHANNEL_3:
   3770              {
   3771                /* Check the parameters */
   3772                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3773                
   3774                /* Return the capture 3 value */
   3775                tmpreg = htim->Instance->CCR3;
   3776                
   3777                break;
   3778              }
   3779              
   3780              case TIM_CHANNEL_4:
   3781              {
   3782                /* Check the parameters */
   3783                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3784                
   3785                /* Return the capture 4 value */
   3786                tmpreg = htim->Instance->CCR4;
   3787                
   3788                break;
   3789              }
   3790              
   3791              default:
   3792              break;  
   3793            }
   3794               
   3795            __HAL_UNLOCK(htim);  
   3796            return tmpreg;
   3797          }
   3798          
   3799          /**
   3800            * @}
   3801            */
   3802            
   3803          /** @defgroup TIM_Group4 TIM Callbacks functions
   3804           *  @brief    TIM Callbacks functions 
   3805           *
   3806          @verbatim
   3807            ==============================================================================
   3808                                  ##### TIM Callbacks functions #####
   3809            ==============================================================================  
   3810           [..]  
   3811             This section provides TIM callback functions:
   3812             (+) Timer Period elapsed callback
   3813             (+) Timer Output Compare callback
   3814             (+) Timer Input capture callback
   3815             (+) Timer Trigger callback
   3816             (+) Timer Error callback
   3817          
   3818          @endverbatim
   3819            * @{
   3820            */
   3821          
   3822          /**
   3823            * @brief  Period elapsed callback in non blocking mode 
   3824            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3825            *                the configuration information for TIM module.
   3826            * @retval None
   3827            */
   3828          __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   3829          {
   3830            /* NOTE : This function Should not be modified, when the callback is needed,
   3831                      the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   3832             */
   3833            
   3834          }
   3835          /**
   3836            * @brief  Output Compare callback in non blocking mode 
   3837            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3838            *                the configuration information for TIM module.
   3839            * @retval None
   3840            */
   3841          __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
   3842          {
   3843            /* NOTE : This function Should not be modified, when the callback is needed,
   3844                      the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   3845             */
   3846          }
   3847          /**
   3848            * @brief  Input Capture callback in non blocking mode 
   3849            * @param  htim: TIM IC handle
   3850            * @retval None
   3851            */
   3852          __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
   3853          {
   3854            /* NOTE : This function Should not be modified, when the callback is needed,
   3855                      the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
   3856             */
   3857          }
   3858          
   3859          /**
   3860            * @brief  PWM Pulse finished callback in non blocking mode 
   3861            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3862            *                the configuration information for TIM module.
   3863            * @retval None
   3864            */
   3865          __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
   3866          {
   3867            /* NOTE : This function Should not be modified, when the callback is needed,
   3868                      the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   3869             */
   3870          }
   3871          
   3872          /**
   3873            * @brief  Hall Trigger detection callback in non blocking mode 
   3874            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3875            *                the configuration information for TIM module.
   3876            * @retval None
   3877            */
   3878          __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
   3879          {
   3880            /* NOTE : This function Should not be modified, when the callback is needed,
   3881                      the HAL_TIM_TriggerCallback could be implemented in the user file
   3882             */
   3883          }
   3884          
   3885          /**
   3886            * @brief  Timer error callback in non blocking mode 
   3887            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3888            *                the configuration information for TIM module.
   3889            * @retval None
   3890            */
   3891          __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
   3892          {
   3893            /* NOTE : This function Should not be modified, when the callback is needed,
   3894                      the HAL_TIM_ErrorCallback could be implemented in the user file
   3895             */
   3896          }
   3897          
   3898          /**
   3899            * @}
   3900            */
   3901          
   3902          /** @defgroup TIM_Group5 Peripheral State functions 
   3903           *  @brief   Peripheral State functions 
   3904           *
   3905          @verbatim   
   3906            ==============================================================================
   3907                                ##### Peripheral State functions #####
   3908            ==============================================================================  
   3909            [..]
   3910              This subsection permits to get in run-time the status of the peripheral 
   3911              and the data flow.
   3912          
   3913          @endverbatim
   3914            * @{
   3915            */
   3916          
   3917          /**
   3918            * @brief  Return the TIM Base state
   3919            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3920            *                the configuration information for TIM module.
   3921            * @retval HAL state
   3922            */
   3923          HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
   3924          {
   3925            return htim->State;
   3926          }
   3927          
   3928          /**
   3929            * @brief  Return the TIM OC state
   3930            * @param  htim: TIM Ouput Compare handle
   3931            * @retval HAL state
   3932            */
   3933          HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
   3934          {
   3935            return htim->State;
   3936          }
   3937          
   3938          /**
   3939            * @brief  Return the TIM PWM state
   3940            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3941            *                the configuration information for TIM module.
   3942            * @retval HAL state
   3943            */
   3944          HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
   3945          {
   3946            return htim->State;
   3947          }
   3948          
   3949          /**
   3950            * @brief  Return the TIM Input Capture state
   3951            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3952            *                the configuration information for TIM module.
   3953            * @retval HAL state
   3954            */
   3955          HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
   3956          {
   3957            return htim->State;
   3958          }
   3959          
   3960          /**
   3961            * @brief  Return the TIM One Pulse Mode state
   3962            * @param  htim: TIM OPM handle
   3963            * @retval HAL state
   3964            */
   3965          HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
   3966          {
   3967            return htim->State;
   3968          }
   3969          
   3970          /**
   3971            * @brief  Return the TIM Encoder Mode state
   3972            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3973            *                the configuration information for TIM module.
   3974            * @retval HAL state
   3975            */
   3976          HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
   3977          {
   3978            return htim->State;
   3979          }
   3980          
   3981          /**
   3982            * @}
   3983            */
   3984          
   3985          /** @defgroup TIM_Group6 TIM IRQ handler management 
   3986           *  @brief    IRQ handler management 
   3987           *
   3988          @verbatim   
   3989            ==============================================================================
   3990                                  ##### IRQ handler management #####
   3991            ==============================================================================  
   3992            [..]
   3993              This section provides Timer IRQ handler function.
   3994          
   3995          @endverbatim
   3996            * @{
   3997            */
   3998          /**
   3999            * @brief  This function handles TIM interrupts requests.
   4000            * @param  htim: TIM  handle
   4001            * @retval None
   4002            */
   4003          void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
   4004          {
   4005            /* Capture compare 1 event */
   4006            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
   4007            {
   4008              if(__HAL_TIM_GET_ITSTATUS(htim, TIM_IT_CC1) !=RESET)
   4009              {
   4010                {
   4011                  __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
   4012                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   4013                  
   4014                  /* Input capture event */
   4015                  if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
   4016                  {
   4017                    HAL_TIM_IC_CaptureCallback(htim);
   4018                  }
   4019                  /* Output compare event */
   4020                  else
   4021                  {
   4022                    HAL_TIM_OC_DelayElapsedCallback(htim);
   4023                    HAL_TIM_PWM_PulseFinishedCallback(htim);
   4024                  }
   4025                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   4026                }
   4027              }
   4028            }
   4029            /* Capture compare 2 event */
   4030            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
   4031            {
   4032              if(__HAL_TIM_GET_ITSTATUS(htim, TIM_IT_CC2) !=RESET)
   4033              {
   4034                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
   4035                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   4036                /* Input capture event */
   4037                if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
   4038                {          
   4039                  HAL_TIM_IC_CaptureCallback(htim);
   4040                }
   4041                /* Output compare event */
   4042                else
   4043                {
   4044                  HAL_TIM_OC_DelayElapsedCallback(htim);
   4045                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   4046                }
   4047                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   4048              }
   4049            }
   4050            /* Capture compare 3 event */
   4051            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
   4052            {
   4053              if(__HAL_TIM_GET_ITSTATUS(htim, TIM_IT_CC3) !=RESET)
   4054              {
   4055                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
   4056                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   4057                /* Input capture event */
   4058                if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
   4059                {          
   4060                  HAL_TIM_IC_CaptureCallback(htim);
   4061                }
   4062                /* Output compare event */
   4063                else
   4064                {
   4065                  HAL_TIM_OC_DelayElapsedCallback(htim);
   4066                  HAL_TIM_PWM_PulseFinishedCallback(htim); 
   4067                }
   4068                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   4069              }
   4070            }
   4071            /* Capture compare 4 event */
   4072            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
   4073            {
   4074              if(__HAL_TIM_GET_ITSTATUS(htim, TIM_IT_CC4) !=RESET)
   4075              {
   4076                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
   4077                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   4078                /* Input capture event */
   4079                if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
   4080                {          
   4081                  HAL_TIM_IC_CaptureCallback(htim);
   4082                }
   4083                /* Output compare event */
   4084                else
   4085                {
   4086                  HAL_TIM_OC_DelayElapsedCallback(htim);
   4087                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   4088                }
   4089                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   4090              }
   4091            }
   4092            /* TIM Update event */
   4093            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
   4094            {
   4095              if(__HAL_TIM_GET_ITSTATUS(htim, TIM_IT_UPDATE) !=RESET)
   4096              {    
   4097                __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
   4098                HAL_TIM_PeriodElapsedCallback(htim); 
   4099              }
   4100            }
   4101            /* TIM Trigger detection event */
   4102            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
   4103            {
   4104              if(__HAL_TIM_GET_ITSTATUS(htim, TIM_IT_TRIGGER) !=RESET)
   4105              {
   4106                __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
   4107                HAL_TIM_TriggerCallback(htim);
   4108              }
   4109            }
   4110          }
   4111          
   4112          /**
   4113            * @brief  TIM DMA error callback 
   4114            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4115            *                the configuration information for the specified DMA module.
   4116            * @retval None
   4117            */
   4118          void HAL_TIM_DMAError(DMA_HandleTypeDef *hdma)
   4119          {
   4120            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   4121            
   4122            htim->State= HAL_TIM_STATE_READY;
   4123             
   4124            HAL_TIM_ErrorCallback(htim);
   4125          }
   4126          
   4127          /**
   4128            * @brief  TIM DMA Delay Pulse complete callback. 
   4129            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4130            *                the configuration information for the specified DMA module.
   4131            * @retval None
   4132            */
   4133          void HAL_TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
   4134          {
   4135            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   4136            
   4137            htim->State= HAL_TIM_STATE_READY; 
   4138            
   4139            HAL_TIM_PWM_PulseFinishedCallback(htim);
   4140          }
   4141          /**
   4142            * @brief  TIM DMA Capture complete callback. 
   4143            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4144            *                the configuration information for the specified DMA module.
   4145            * @retval None
   4146            */
   4147          void HAL_TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
   4148          {
   4149            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   4150              
   4151             htim->State= HAL_TIM_STATE_READY; 
   4152              
   4153            HAL_TIM_IC_CaptureCallback(htim);
   4154          
   4155          }
   4156          
   4157          /**
   4158            * @}
   4159            */
   4160            
   4161          
   4162          /**
   4163            * @brief  TIM DMA Period Elapse complete callback. 
   4164            * @param  hdma: pointer to DMA handle.
   4165            * @retval None
   4166            */
   4167          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
   4168          {
   4169            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   4170            
   4171            htim->State= HAL_TIM_STATE_READY;
   4172            
   4173            HAL_TIM_PeriodElapsedCallback(htim);
   4174          }
   4175          
   4176          
   4177          /**
   4178            * @brief  TIM DMA Trigger callback. 
   4179            * @param  hdma: pointer to DMA handle.
   4180            * @retval None
   4181            */
   4182          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
   4183          {
   4184            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
   4185            
   4186            htim->State= HAL_TIM_STATE_READY; 
   4187            
   4188            HAL_TIM_TriggerCallback(htim);
   4189          }
   4190          
   4191          /**
   4192            * @brief  Time Base configuration
   4193            * @param  TIMx: TIM periheral
   4194            * @retval None
   4195            */
   4196          static void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
   4197          {
   4198            uint32_t tmpcr1 = 0;
   4199            tmpcr1 = TIMx->CR1;
   4200            
   4201            /* Set TIM Time Base Unit parameters ---------------------------------------*/
   4202            if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
   4203            {
   4204              /* Select the Counter Mode */
   4205              tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   4206              tmpcr1 |= Structure->CounterMode;
   4207            }
   4208           
   4209            if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
   4210            {
   4211              /* Set the clock division */
   4212              tmpcr1 &= ~TIM_CR1_CKD;
   4213              tmpcr1 |= (uint32_t)Structure->ClockDivision;
   4214            }
   4215          
   4216            TIMx->CR1 = tmpcr1;
   4217          
   4218            /* Set the Autoreload value */
   4219            TIMx->ARR = (uint32_t)Structure->Period ;
   4220           
   4221            /* Set the Prescaler value */
   4222            TIMx->PSC = (uint32_t)Structure->Prescaler;
   4223          
   4224            /* Generate an update event to reload the Prescaler value immediatly */
   4225            TIMx->EGR = TIM_EGR_UG;
   4226          }
   4227          
   4228          /**
   4229            * @brief  Time Ouput Compare 1 configuration
   4230            * @param  TIMx to select the TIM peripheral
   4231            * @param  OC_Config: The ouput configuration structure
   4232            * @retval None
   4233            */
   4234          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4235          {
   4236            uint32_t tmpccmrx = 0;
   4237            uint32_t tmpccer = 0;
   4238            uint32_t tmpcr2 = 0;  
   4239          
   4240            /* Disable the Channel 1: Reset the CC1E Bit */
   4241            TIMx->CCER &= ~TIM_CCER_CC1E;
   4242            
   4243            /* Get the TIMx CCER register value */
   4244            tmpccer = TIMx->CCER;
   4245            /* Get the TIMx CR2 register value */
   4246            tmpcr2 = TIMx->CR2;
   4247            
   4248            /* Get the TIMx CCMR1 register value */
   4249            tmpccmrx = TIMx->CCMR1;
   4250              
   4251            /* Reset the Output Compare Mode Bits */
   4252            tmpccmrx &= ~TIM_CCMR1_OC1M;
   4253            tmpccmrx &= ~TIM_CCMR1_CC1S;
   4254            /* Select the Output Compare Mode */
   4255            tmpccmrx |= OC_Config->OCMode;
   4256            
   4257            /* Reset the Output Polarity level */
   4258            tmpccer &= ~TIM_CCER_CC1P;
   4259            /* Set the Output Compare Polarity */
   4260            tmpccer |= OC_Config->OCPolarity;
   4261          
   4262            /* Write to TIMx CR2 */
   4263            TIMx->CR2 = tmpcr2;
   4264            
   4265            /* Write to TIMx CCMR1 */
   4266            TIMx->CCMR1 = tmpccmrx;
   4267            
   4268            /* Set the Capture Compare Register value */
   4269            TIMx->CCR1 = OC_Config->Pulse;
   4270            
   4271            /* Write to TIMx CCER */
   4272            TIMx->CCER = tmpccer;  
   4273          } 
   4274          
   4275          /**
   4276            * @brief  Time Ouput Compare 2 configuration
   4277            * @param  TIMx to select the TIM peripheral
   4278            * @param  OC_Config: The ouput configuration structure
   4279            * @retval None
   4280            */
   4281          static void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4282          {
   4283            uint32_t tmpccmrx = 0;
   4284            uint32_t tmpccer = 0;
   4285            uint32_t tmpcr2 = 0;
   4286             
   4287            /* Disable the Channel 2: Reset the CC2E Bit */
   4288            TIMx->CCER &= ~TIM_CCER_CC2E;
   4289            
   4290            /* Get the TIMx CCER register value */  
   4291            tmpccer = TIMx->CCER;
   4292            /* Get the TIMx CR2 register value */
   4293            tmpcr2 = TIMx->CR2;
   4294            
   4295            /* Get the TIMx CCMR1 register value */
   4296            tmpccmrx = TIMx->CCMR1;
   4297              
   4298            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4299            tmpccmrx &= ~TIM_CCMR1_OC2M;
   4300            tmpccmrx &= ~TIM_CCMR1_CC2S;
   4301            
   4302            /* Select the Output Compare Mode */
   4303            tmpccmrx |= (OC_Config->OCMode << 8);
   4304            
   4305            /* Reset the Output Polarity level */
   4306            tmpccer &= ~TIM_CCER_CC2P;
   4307            /* Set the Output Compare Polarity */
   4308            tmpccer |= (OC_Config->OCPolarity << 4);
   4309              
   4310            /* Write to TIMx CR2 */
   4311            TIMx->CR2 = tmpcr2;
   4312            
   4313            /* Write to TIMx CCMR1 */
   4314            TIMx->CCMR1 = tmpccmrx;
   4315            
   4316            /* Set the Capture Compare Register value */
   4317            TIMx->CCR2 = OC_Config->Pulse;
   4318            
   4319            /* Write to TIMx CCER */
   4320            TIMx->CCER = tmpccer;
   4321          }
   4322          
   4323          /**
   4324            * @brief  Time Ouput Compare 3 configuration
   4325            * @param  TIMx to select the TIM peripheral
   4326            * @param  OC_Config: The ouput configuration structure
   4327            * @retval None
   4328            */
   4329          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4330          {
   4331            uint32_t tmpccmrx = 0;
   4332            uint32_t tmpccer = 0;
   4333            uint32_t tmpcr2 = 0;   
   4334          
   4335            /* Disable the Channel 3: Reset the CC2E Bit */
   4336            TIMx->CCER &= ~TIM_CCER_CC3E;
   4337            
   4338            /* Get the TIMx CCER register value */
   4339            tmpccer = TIMx->CCER;
   4340            /* Get the TIMx CR2 register value */
   4341            tmpcr2 = TIMx->CR2;
   4342            
   4343            /* Get the TIMx CCMR2 register value */
   4344            tmpccmrx = TIMx->CCMR2;
   4345              
   4346            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4347            tmpccmrx &= ~TIM_CCMR2_OC3M;
   4348            tmpccmrx &= ~TIM_CCMR2_CC3S;  
   4349            /* Select the Output Compare Mode */
   4350            tmpccmrx |= OC_Config->OCMode;
   4351            
   4352            /* Reset the Output Polarity level */
   4353            tmpccer &= ~TIM_CCER_CC3P;
   4354            /* Set the Output Compare Polarity */
   4355            tmpccer |= (OC_Config->OCPolarity << 8);
   4356              
   4357            /* Write to TIMx CR2 */
   4358            TIMx->CR2 = tmpcr2;
   4359            
   4360            /* Write to TIMx CCMR2 */
   4361            TIMx->CCMR2 = tmpccmrx;
   4362            
   4363            /* Set the Capture Compare Register value */
   4364            TIMx->CCR3 = OC_Config->Pulse;
   4365            
   4366            /* Write to TIMx CCER */
   4367            TIMx->CCER = tmpccer;
   4368          }
   4369          
   4370          /**
   4371            * @brief  Time Ouput Compare 4 configuration
   4372            * @param  TIMx to select the TIM peripheral
   4373            * @param  OC_Config: The ouput configuration structure
   4374            * @retval None
   4375            */
   4376          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4377          {
   4378            uint32_t tmpccmrx = 0;
   4379            uint32_t tmpccer = 0;
   4380            uint32_t tmpcr2 = 0;
   4381          
   4382            /* Disable the Channel 4: Reset the CC4E Bit */
   4383            TIMx->CCER &= ~TIM_CCER_CC4E;
   4384            
   4385            /* Get the TIMx CCER register value */
   4386            tmpccer = TIMx->CCER;
   4387            /* Get the TIMx CR2 register value */
   4388            tmpcr2 = TIMx->CR2;
   4389            
   4390            /* Get the TIMx CCMR2 register value */
   4391            tmpccmrx = TIMx->CCMR2;
   4392              
   4393            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4394            tmpccmrx &= ~TIM_CCMR2_OC4M;
   4395            tmpccmrx &= ~TIM_CCMR2_CC4S;
   4396            
   4397            /* Select the Output Compare Mode */
   4398            tmpccmrx |= (OC_Config->OCMode << 8);
   4399            
   4400            /* Reset the Output Polarity level */
   4401            tmpccer &= ~TIM_CCER_CC4P;
   4402            /* Set the Output Compare Polarity */
   4403            tmpccer |= (OC_Config->OCPolarity << 12);
   4404             
   4405            /* Write to TIMx CR2 */
   4406            TIMx->CR2 = tmpcr2;
   4407            
   4408            /* Write to TIMx CCMR2 */  
   4409            TIMx->CCMR2 = tmpccmrx;
   4410              
   4411            /* Set the Capture Compare Register value */
   4412            TIMx->CCR4 = OC_Config->Pulse;
   4413            
   4414            /* Write to TIMx CCER */
   4415            TIMx->CCER = tmpccer;
   4416          }
   4417          
   4418          /**
   4419            * @brief  Configure the TI1 as Input.
   4420            * @param  TIMx to select the TIM peripheral.
   4421            * @param  TIM_ICPolarity : The Input Polarity.
   4422            *          This parameter can be one of the following values:
   4423            *            @arg TIM_ICPolarity_Rising
   4424            *            @arg TIM_ICPolarity_Falling
   4425            *            @arg TIM_ICPolarity_BothEdge  
   4426            * @param  TIM_ICSelection: specifies the input to be used.
   4427            *          This parameter can be one of the following values:
   4428            *            @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   4429            *            @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   4430            *            @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
   4431            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   4432            *          This parameter must be a value between 0x00 and 0x0F.
   4433            * @retval None
   4434            */
   4435          static void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   4436                                 uint32_t TIM_ICFilter)
   4437          {
   4438            uint32_t tmpccmr1 = 0;
   4439            uint32_t tmpccer = 0;
   4440            
   4441            /* Disable the Channel 1: Reset the CC1E Bit */
   4442            TIMx->CCER &= ~TIM_CCER_CC1E;
   4443            tmpccmr1 = TIMx->CCMR1;
   4444            tmpccer = TIMx->CCER;
   4445          
   4446            /* Select the Input */
   4447            if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
   4448            {
   4449              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   4450              tmpccmr1 |= TIM_ICSelection;
   4451            } 
   4452            else
   4453            {
   4454              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   4455              tmpccmr1 |= TIM_CCMR1_CC1S_0;
   4456            }
   4457           
   4458            /* Set the filter */
   4459            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   4460            tmpccmr1 |= (TIM_ICFilter << 4);
   4461          
   4462            /* Select the Polarity and set the CC1E Bit */
   4463            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   4464            tmpccer |= TIM_ICPolarity;
   4465          
   4466            /* Write to TIMx CCMR1 and CCER registers */
   4467            TIMx->CCMR1 = tmpccmr1;
   4468            TIMx->CCER = tmpccer;
   4469          }
   4470          
   4471          /**
   4472            * @brief  Configure the Polarity and Filter for TI1.
   4473            * @param  TIMx to select the TIM peripheral.
   4474            * @param  TIM_ICPolarity : The Input Polarity.
   4475            *          This parameter can be one of the following values:
   4476            *            @arg TIM_ICPolarity_Rising
   4477            *            @arg TIM_ICPolarity_Falling
   4478            *            @arg TIM_ICPolarity_BothEdge
   4479            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   4480            *          This parameter must be a value between 0x00 and 0x0F.
   4481            * @retval None
   4482            */
   4483          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   4484          {
   4485            uint32_t tmpccmr1 = 0;
   4486            uint32_t tmpccer = 0;
   4487            
   4488            /* Disable the Channel 1: Reset the CC1E Bit */
   4489            tmpccer = TIMx->CCER;
   4490            TIMx->CCER &= ~TIM_CCER_CC1E;
   4491            tmpccmr1 = TIMx->CCMR1;    
   4492            
   4493            /* Set the filter */
   4494            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   4495            tmpccmr1 |= (TIM_ICFilter << 4);
   4496            
   4497            /* Select the Polarity and set the CC1E Bit */
   4498            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   4499            tmpccer |= TIM_ICPolarity;
   4500            
   4501            /* Write to TIMx CCMR1 and CCER registers */
   4502            TIMx->CCMR1 = tmpccmr1;
   4503            TIMx->CCER = tmpccer;
   4504          }
   4505          
   4506          /**
   4507            * @brief  Configure the TI2 as Input.
   4508            * @param  TIMx to select the TIM peripheral
   4509            * @param  TIM_ICPolarity : The Input Polarity.
   4510            *          This parameter can be one of the following values:
   4511            *            @arg TIM_ICPolarity_Rising
   4512            *            @arg TIM_ICPolarity_Falling
   4513            *            @arg TIM_ICPolarity_BothEdge   
   4514            * @param  TIM_ICSelection: specifies the input to be used.
   4515            *          This parameter can be one of the following values:
   4516            *            @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   4517            *            @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   4518            *            @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
   4519            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   4520            *          This parameter must be a value between 0x00 and 0x0F.
   4521            * @retval None
   4522            */
   4523          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   4524                                 uint32_t TIM_ICFilter)
   4525          {
   4526            uint32_t tmpccmr1 = 0;
   4527            uint32_t tmpccer = 0;
   4528          
   4529            /* Disable the Channel 2: Reset the CC2E Bit */
   4530            TIMx->CCER &= ~TIM_CCER_CC2E;
   4531            tmpccmr1 = TIMx->CCMR1;
   4532            tmpccer = TIMx->CCER;
   4533            
   4534            /* Select the Input */
   4535            tmpccmr1 &= ~TIM_CCMR1_CC2S;
   4536            tmpccmr1 |= (TIM_ICSelection << 8);
   4537            
   4538            /* Set the filter */
   4539            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   4540            tmpccmr1 |= (TIM_ICFilter << 12);
   4541          
   4542            /* Select the Polarity and set the CC2E Bit */
   4543            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   4544            tmpccer |= (TIM_ICPolarity << 4);
   4545          
   4546            /* Write to TIMx CCMR1 and CCER registers */
   4547            TIMx->CCMR1 = tmpccmr1 ;
   4548            TIMx->CCER = tmpccer;
   4549          }
   4550          
   4551          /**
   4552            * @brief  Configure the Polarity and Filter for TI2.
   4553            * @param  TIMx to select the TIM peripheral.
   4554            * @param  TIM_ICPolarity : The Input Polarity.
   4555            *          This parameter can be one of the following values:
   4556            *            @arg TIM_ICPolarity_Rising
   4557            *            @arg TIM_ICPolarity_Falling
   4558            *            @arg TIM_ICPolarity_BothEdge
   4559            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   4560            *          This parameter must be a value between 0x00 and 0x0F.
   4561            * @retval None
   4562            */
   4563          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   4564          {
   4565            uint32_t tmpccmr1 = 0;
   4566            uint32_t tmpccer = 0;
   4567            
   4568            /* Disable the Channel 2: Reset the CC2E Bit */
   4569            TIMx->CCER &= ~TIM_CCER_CC2E;
   4570            tmpccmr1 = TIMx->CCMR1;
   4571            tmpccer = TIMx->CCER;
   4572            
   4573            /* Set the filter */
   4574            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   4575            tmpccmr1 |= (TIM_ICFilter << 12);
   4576          
   4577            /* Select the Polarity and set the CC2E Bit */
   4578            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   4579            tmpccer |= (TIM_ICPolarity << 4);
   4580          
   4581            /* Write to TIMx CCMR1 and CCER registers */
   4582            TIMx->CCMR1 = tmpccmr1 ;
   4583            TIMx->CCER = tmpccer;
   4584          }
   4585          
   4586          /**
   4587            * @brief  Configure the TI3 as Input.
   4588            * @param  TIMx to select the TIM peripheral
   4589            * @param  TIM_ICPolarity : The Input Polarity.
   4590            *          This parameter can be one of the following values:
   4591            *            @arg TIM_ICPolarity_Rising
   4592            *            @arg TIM_ICPolarity_Falling
   4593            *            @arg TIM_ICPolarity_BothEdge         
   4594            * @param  TIM_ICSelection: specifies the input to be used.
   4595            *          This parameter can be one of the following values:
   4596            *            @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   4597            *            @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   4598            *            @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
   4599            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   4600            *          This parameter must be a value between 0x00 and 0x0F.
   4601            * @retval None
   4602            */
   4603          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   4604                                 uint32_t TIM_ICFilter)
   4605          {
   4606            uint32_t tmpccmr2 = 0;
   4607            uint32_t tmpccer = 0;
   4608          
   4609            /* Disable the Channel 3: Reset the CC3E Bit */
   4610            TIMx->CCER &= ~TIM_CCER_CC3E;
   4611            tmpccmr2 = TIMx->CCMR2;
   4612            tmpccer = TIMx->CCER;
   4613          
   4614            /* Select the Input */
   4615            tmpccmr2 &= ~TIM_CCMR2_CC3S;
   4616            tmpccmr2 |= TIM_ICSelection;
   4617          
   4618            /* Set the filter */
   4619            tmpccmr2 &= ~TIM_CCMR2_IC3F;
   4620            tmpccmr2 |= (TIM_ICFilter << 4);
   4621          
   4622            /* Select the Polarity and set the CC3E Bit */
   4623            tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   4624            tmpccer |= (TIM_ICPolarity << 8);
   4625          
   4626            /* Write to TIMx CCMR2 and CCER registers */
   4627            TIMx->CCMR2 = tmpccmr2;
   4628            TIMx->CCER = tmpccer;
   4629          }
   4630          
   4631          /**
   4632            * @brief  Configure the TI4 as Input.
   4633            * @param  TIMx to select the TIM peripheral
   4634            * @param  TIM_ICPolarity : The Input Polarity.
   4635            *          This parameter can be one of the following values:
   4636            *            @arg TIM_ICPolarity_Rising
   4637            *            @arg TIM_ICPolarity_Falling
   4638            *            @arg TIM_ICPolarity_BothEdge     
   4639            * @param  TIM_ICSelection: specifies the input to be used.
   4640            *          This parameter can be one of the following values:
   4641            *            @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   4642            *            @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   4643            *            @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
   4644            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   4645            *          This parameter must be a value between 0x00 and 0x0F.
   4646            * @retval None
   4647            */
   4648          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   4649                                 uint32_t TIM_ICFilter)
   4650          {
   4651            uint32_t tmpccmr2 = 0;
   4652            uint32_t tmpccer = 0;
   4653          
   4654            /* Disable the Channel 4: Reset the CC4E Bit */
   4655            TIMx->CCER &= ~TIM_CCER_CC4E;
   4656            tmpccmr2 = TIMx->CCMR2;
   4657            tmpccer = TIMx->CCER;
   4658          
   4659            /* Select the Input */
   4660            tmpccmr2 &= ~TIM_CCMR2_CC4S;
   4661            tmpccmr2 |= (TIM_ICSelection << 8);
   4662          
   4663            /* Set the filter */
   4664            tmpccmr2 &= ~TIM_CCMR2_IC4F;
   4665            tmpccmr2 |= (TIM_ICFilter << 12);
   4666          
   4667            /* Select the Polarity and set the CC4E Bit */
   4668            tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   4669            tmpccer |= (TIM_ICPolarity << 12);
   4670          
   4671            /* Write to TIMx CCMR2 and CCER registers */
   4672            TIMx->CCMR2 = tmpccmr2;
   4673            TIMx->CCER = tmpccer ;
   4674          }
   4675          
   4676          /**
   4677            * @brief  Selects the Input Trigger source
   4678            * @param  TIMx to select the TIM peripheral
   4679            * @param  InputTriggerSource: The Input Trigger source.
   4680            *          This parameter can be one of the following values:
   4681            *            @arg TIM_TS_ITR0: Internal Trigger 0
   4682            *            @arg TIM_TS_ITR1: Internal Trigger 1
   4683            *            @arg TIM_TS_ITR2: Internal Trigger 2
   4684            *            @arg TIM_TS_ITR3: Internal Trigger 3
   4685            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   4686            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   4687            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   4688            *            @arg TIM_TS_ETRF: External Trigger input
   4689            * @retval None
   4690            */
   4691          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t TIM_ITRx)
   4692          {
   4693            uint32_t tmpsmcr = 0;
   4694            
   4695             /* Get the TIMx SMCR register value */
   4696             tmpsmcr = TIMx->SMCR;
   4697             /* Reset the TS Bits */
   4698             tmpsmcr &= ~TIM_SMCR_TS;
   4699             /* Set the Input Trigger source and the slave mode*/
   4700             tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
   4701             /* Write to TIMx SMCR */
   4702             TIMx->SMCR = tmpsmcr;
   4703          }
   4704          /**
   4705            * @brief  Configures the TIMx External Trigger (ETR).
   4706            * @param  TIMx to select the TIM peripheral
   4707            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   4708            *          This parameter can be one of the following values:
   4709            *            @arg TIM_ExtTRGPSC_DIV1: ETRP Prescaler OFF.
   4710            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   4711            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   4712            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   4713            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   4714            *          This parameter can be one of the following values:
   4715            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   4716            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   4717            * @param  ExtTRGFilter: External Trigger Filter.
   4718            *          This parameter must be a value between 0x00 and 0x0F
   4719            * @retval None
   4720            */
   4721          static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
   4722                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   4723          {
   4724            uint32_t tmpsmcr = 0;
   4725          
   4726            tmpsmcr = TIMx->SMCR;
   4727          
   4728            /* Reset the ETR Bits */
   4729            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   4730          
   4731            /* Set the Prescaler, the Filter value and the Polarity */
   4732            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
   4733          
   4734            /* Write to TIMx SMCR */
   4735            TIMx->SMCR = tmpsmcr;
   4736          } 
   4737          
   4738          /**
   4739            * @brief  Enables or disables the TIM Capture Compare Channel x.
   4740            * @param  TIMx to select the TIM peripheral
   4741            * @param  Channel: specifies the TIM Channel
   4742            *          This parameter can be one of the following values:
   4743            *            @arg TIM_Channel_1: TIM Channel 1
   4744            *            @arg TIM_Channel_2: TIM Channel 2
   4745            *            @arg TIM_Channel_3: TIM Channel 3
   4746            *            @arg TIM_Channel_4: TIM Channel 4
   4747            * @param  ChannelState: specifies the TIM Channel CCxE bit new state.
   4748            *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable. 
   4749            * @retval None
   4750            */
   4751          static void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
   4752          {
   4753            uint32_t tmp = 0;
   4754          
   4755            /* Check the parameters */
   4756            assert_param(IS_TIM_CC1_INSTANCE(TIMx)); 
   4757            assert_param(IS_TIM_CHANNELS(Channel));
   4758          
   4759            tmp = TIM_CCER_CC1E << Channel;
   4760          
   4761            /* Reset the CCxE Bit */
   4762            TIMx->CCER &= ~tmp;
   4763          
   4764            /* Set or reset the CCxE Bit */ 
   4765            TIMx->CCER |= (uint32_t)(ChannelState << Channel);
   4766          }
   4767          
   4768          /**
   4769            * @}
   4770            */
   4771          
   4772          #endif /* HAL_TIM_MODULE_ENABLED */
   4773          /**
   4774            * @}
   4775            */ 
   4776          
   4777          /**
   4778            * @}
   4779            */ 
   4780          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_TIM_Base_DeInit
         8   -> HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_GetState
       8   HAL_TIM_Base_Init
         8   -> HAL_TIM_Base_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_MspInit
       0   HAL_TIM_Base_Start
       8   HAL_TIM_Base_Start_DMA
         8   -> HAL_DMA_Start_IT
       0   HAL_TIM_Base_Start_IT
       0   HAL_TIM_Base_Stop
       0   HAL_TIM_Base_Stop_DMA
       0   HAL_TIM_Base_Stop_IT
      16   HAL_TIM_ConfigClockSource
        16   -> TIM_ETR_SetConfig
        16   -> TIM_ITRx_SetConfig
        16   -> TIM_TI1_ConfigInputStage
        16   -> TIM_TI2_ConfigInputStage
      24   HAL_TIM_ConfigOCrefClear
        24   -> TIM_ETR_SetConfig
       0   HAL_TIM_ConfigTI1Input
      32   HAL_TIM_DMABurst_ReadStart
        32   -> HAL_DMA_Start_IT
       0   HAL_TIM_DMABurst_ReadStop
      32   HAL_TIM_DMABurst_WriteStart
        32   -> HAL_DMA_Start_IT
       0   HAL_TIM_DMABurst_WriteStop
       8   HAL_TIM_DMACaptureCplt
         8   -> HAL_TIM_IC_CaptureCallback
       8   HAL_TIM_DMADelayPulseCplt
         8   -> HAL_TIM_PWM_PulseFinishedCallback
       8   HAL_TIM_DMAError
         8   -> HAL_TIM_ErrorCallback
       8   HAL_TIM_Encoder_DeInit
         8   -> HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_GetState
      24   HAL_TIM_Encoder_Init
        24   -> HAL_TIM_Encoder_MspInit
        24   -> TIM_Base_SetConfig
       0   HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_MspInit
       8   HAL_TIM_Encoder_Start
         8   -> TIM_CCxChannelCmd
      24   HAL_TIM_Encoder_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Start_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_Encoder_Stop
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop_DMA
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop_IT
        16   -> TIM_CCxChannelCmd
       0   HAL_TIM_ErrorCallback
       8   HAL_TIM_GenerateEvent
       0   HAL_TIM_IC_CaptureCallback
      32   HAL_TIM_IC_ConfigChannel
        32   -> TIM_TI1_SetConfig
        32   -> TIM_TI2_SetConfig
       8   HAL_TIM_IC_DeInit
         8   -> HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_GetState
       8   HAL_TIM_IC_Init
         8   -> HAL_TIM_IC_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_MspInit
       8   HAL_TIM_IC_Start
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Stop_DMA
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_IC_Stop_IT
         8   -> TIM_CCxChannelCmd
      24   HAL_TIM_IRQHandler
        24   -> HAL_TIM_IC_CaptureCallback
        24   -> HAL_TIM_OC_DelayElapsedCallback
        24   -> HAL_TIM_PWM_PulseFinishedCallback
        24   -> HAL_TIM_PeriodElapsedCallback
        24   -> HAL_TIM_TriggerCallback
      16   HAL_TIM_OC_ConfigChannel
        16   -> TIM_OC1_SetConfig
        16   -> TIM_OC2_SetConfig
        16   -> TIM_OC3_SetConfig
        16   -> TIM_OC4_SetConfig
       8   HAL_TIM_OC_DeInit
         8   -> HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_DelayElapsedCallback
       0   HAL_TIM_OC_GetState
       8   HAL_TIM_OC_Init
         8   -> HAL_TIM_OC_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_MspInit
       8   HAL_TIM_OC_Start
         8   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Stop_DMA
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OC_Stop_IT
         8   -> TIM_CCxChannelCmd
      40   HAL_TIM_OnePulse_ConfigChannel
        40   -> TIM_OC1_SetConfig
        40   -> TIM_OC2_SetConfig
        40   -> TIM_TI1_SetConfig
        40   -> TIM_TI2_SetConfig
       8   HAL_TIM_OnePulse_DeInit
         8   -> HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_GetState
      16   HAL_TIM_OnePulse_Init
        16   -> HAL_TIM_OnePulse_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_MspInit
       8   HAL_TIM_OnePulse_Start
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OnePulse_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OnePulse_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_OnePulse_Stop_IT
         8   -> TIM_CCxChannelCmd
      24   HAL_TIM_PWM_ConfigChannel
        24   -> TIM_OC1_SetConfig
        24   -> TIM_OC2_SetConfig
        24   -> TIM_OC3_SetConfig
        24   -> TIM_OC4_SetConfig
       8   HAL_TIM_PWM_DeInit
         8   -> HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_GetState
       8   HAL_TIM_PWM_Init
         8   -> HAL_TIM_PWM_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_MspInit
       0   HAL_TIM_PWM_PulseFinishedCallback
       8   HAL_TIM_PWM_Start
         8   -> TIM_CCxChannelCmd
       0   HAL_TIM_PWM_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxChannelCmd
       0   HAL_TIM_PWM_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIM_PWM_Stop
         8   -> TIM_CCxChannelCmd
       0   HAL_TIM_PWM_Stop_DMA
         8   -> TIM_CCxChannelCmd
       0   HAL_TIM_PWM_Stop_IT
         8   -> TIM_CCxChannelCmd
       0   HAL_TIM_PeriodElapsedCallback
      12   HAL_TIM_ReadCapturedValue
      16   HAL_TIM_SlaveConfigSynchronization
        16   -> TIM_ETR_SetConfig
        16   -> TIM_TI1_ConfigInputStage
        16   -> TIM_TI2_ConfigInputStage
       0   HAL_TIM_TriggerCallback
       0   TIM_Base_SetConfig
       8   TIM_CCxChannelCmd
       8   TIM_DMAPeriodElapsedCplt
         8   -> HAL_TIM_PeriodElapsedCallback
       8   TIM_DMATriggerCplt
         8   -> HAL_TIM_TriggerCallback
      12   TIM_ETR_SetConfig
       0   TIM_ITRx_SetConfig
      12   TIM_OC1_SetConfig
      12   TIM_OC2_SetConfig
      12   TIM_OC3_SetConfig
      12   TIM_OC4_SetConfig
      12   TIM_TI1_ConfigInputStage
      16   TIM_TI1_SetConfig
      12   TIM_TI2_ConfigInputStage
      16   TIM_TI2_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable13
       4  ??DataTable15
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable27_4
       4  ??DataTable27_5
       4  ??DataTable27_6
       4  ??DataTable27_7
       4  ??DataTable27_8
       4  ??DataTable27_9
       4  ??DataTable8
       4  ??DataTable9
       4  ??DataTable9_1
      20  ??Subroutine11_0
      90  ?Subroutine0
      84  ?Subroutine1
      28  ?Subroutine10
      56  ?Subroutine2
      18  ?Subroutine3
      12  ?Subroutine4
      12  ?Subroutine5
       8  ?Subroutine6
      28  ?Subroutine7
      12  ?Subroutine8
     196  ?Subroutine9
      36  HAL_TIM_Base_DeInit
       6  HAL_TIM_Base_GetState
      40  HAL_TIM_Base_Init
       2  HAL_TIM_Base_MspDeInit
       2  HAL_TIM_Base_MspInit
      24  HAL_TIM_Base_Start
      84  HAL_TIM_Base_Start_DMA
      20  HAL_TIM_Base_Start_IT
       8  HAL_TIM_Base_Stop
      10  HAL_TIM_Base_Stop_DMA
      30  HAL_TIM_Base_Stop_IT
     210  HAL_TIM_ConfigClockSource
     178  HAL_TIM_ConfigOCrefClear
      16  HAL_TIM_ConfigTI1Input
     218  HAL_TIM_DMABurst_ReadStart
       2  HAL_TIM_DMABurst_ReadStop
     218  HAL_TIM_DMABurst_WriteStart
       2  HAL_TIM_DMABurst_WriteStop
      16  HAL_TIM_DMACaptureCplt
      16  HAL_TIM_DMADelayPulseCplt
      16  HAL_TIM_DMAError
      36  HAL_TIM_Encoder_DeInit
       6  HAL_TIM_Encoder_GetState
     138  HAL_TIM_Encoder_Init
       2  HAL_TIM_Encoder_MspDeInit
       2  HAL_TIM_Encoder_MspInit
      32  HAL_TIM_Encoder_Start
     272  HAL_TIM_Encoder_Start_DMA
      96  HAL_TIM_Encoder_Start_IT
      32  HAL_TIM_Encoder_Stop
      76  HAL_TIM_Encoder_Stop_DMA
      82  HAL_TIM_Encoder_Stop_IT
       2  HAL_TIM_ErrorCallback
      42  HAL_TIM_GenerateEvent
       2  HAL_TIM_IC_CaptureCallback
     278  HAL_TIM_IC_ConfigChannel
      36  HAL_TIM_IC_DeInit
       6  HAL_TIM_IC_GetState
      40  HAL_TIM_IC_Init
       2  HAL_TIM_IC_MspDeInit
       2  HAL_TIM_IC_MspInit
       6  HAL_TIM_IC_Start
     196  HAL_TIM_IC_Start_DMA
       4  HAL_TIM_IC_Start_IT
       6  HAL_TIM_IC_Stop
       4  HAL_TIM_IC_Stop_DMA
       4  HAL_TIM_IC_Stop_IT
     280  HAL_TIM_IRQHandler
      78  HAL_TIM_OC_ConfigChannel
      34  HAL_TIM_OC_DeInit
       2  HAL_TIM_OC_DelayElapsedCallback
       6  HAL_TIM_OC_GetState
      40  HAL_TIM_OC_Init
       2  HAL_TIM_OC_MspDeInit
       2  HAL_TIM_OC_MspInit
       6  HAL_TIM_OC_Start
       4  HAL_TIM_OC_Start_DMA
       4  HAL_TIM_OC_Start_IT
       6  HAL_TIM_OC_Stop
       4  HAL_TIM_OC_Stop_DMA
       4  HAL_TIM_OC_Stop_IT
     212  HAL_TIM_OnePulse_ConfigChannel
      36  HAL_TIM_OnePulse_DeInit
       6  HAL_TIM_OnePulse_GetState
      70  HAL_TIM_OnePulse_Init
       2  HAL_TIM_OnePulse_MspDeInit
       2  HAL_TIM_OnePulse_MspInit
      12  HAL_TIM_OnePulse_Start
      26  HAL_TIM_OnePulse_Start_IT
      20  HAL_TIM_OnePulse_Stop
      36  HAL_TIM_OnePulse_Stop_IT
     206  HAL_TIM_PWM_ConfigChannel
      36  HAL_TIM_PWM_DeInit
       6  HAL_TIM_PWM_GetState
      40  HAL_TIM_PWM_Init
       2  HAL_TIM_PWM_MspDeInit
       2  HAL_TIM_PWM_MspInit
       2  HAL_TIM_PWM_PulseFinishedCallback
       6  HAL_TIM_PWM_Start
       2  HAL_TIM_PWM_Start_DMA
       2  HAL_TIM_PWM_Start_IT
       6  HAL_TIM_PWM_Stop
       2  HAL_TIM_PWM_Stop_DMA
       2  HAL_TIM_PWM_Stop_IT
       2  HAL_TIM_PeriodElapsedCallback
      72  HAL_TIM_ReadCapturedValue
     148  HAL_TIM_SlaveConfigSynchronization
       2  HAL_TIM_TriggerCallback
      58  TIM_Base_SetConfig
      22  TIM_CCxChannelCmd
      16  TIM_DMAPeriodElapsedCplt
      16  TIM_DMATriggerCplt
      20  TIM_ETR_SetConfig
      16  TIM_ITRx_SetConfig
      44  TIM_OC1_SetConfig
      48  TIM_OC2_SetConfig
      46  TIM_OC3_SetConfig
      48  TIM_OC4_SetConfig
      34  TIM_TI1_ConfigInputStage
      62  TIM_TI1_SetConfig
      36  TIM_TI2_ConfigInputStage
      44  TIM_TI2_SetConfig

 
 5 224 bytes in section .text
 
 5 224 bytes of CODE memory

Errors: none
Warnings: none

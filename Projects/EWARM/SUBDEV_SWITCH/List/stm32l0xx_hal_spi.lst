###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        13/Jul/2017  14:23:20
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\demo\SUBDEV_SWITCH\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_spi.c
#    Command line =  
#        F:\demo\SUBDEV_SWITCH\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_spi.c
#        -D STM32L053xx -D USE_HAL_DRIVER -lc
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\List\ -o
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\Obj\ --debug
#        --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\..\Drivers\STM32L0xx_HAL_Driver\Inc\
#        -I F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\Inc\ -I
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\..\Drivers\CMSIS\Device\ST\STM32L0xx\Include\
#        -I F:\demo\SUBDEV_SWITCH\Projects\EWARM\..\..\Drivers\CMSIS\Include\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\List\stm32l0xx_hal_spi.lst
#    Object file  =  
#        F:\demo\SUBDEV_SWITCH\Projects\EWARM\SUBDEV_SWITCH\Obj\stm32l0xx_hal_spi.o
#
###############################################################################

F:\demo\SUBDEV_SWITCH\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l0xx_hal_spi.c
      4            * @author  MCD Application Team
      5            * @version V1.1.0
      6            * @date    18-June-2014
      7            * @brief   SPI HAL module driver.
      8            *
      9            *          This file provides firmware functions to manage the following 
     10            *          functionalities of the Serial Peripheral Interface (SPI) peripheral:
     11            *           + Initialization and de-initialization functions
     12            *           + IO operation functions
     13            *           + Peripheral Control functions 
     14            *           + Peripheral State functions
     15            @verbatim
     16            ==============================================================================
     17                                  ##### How to use this driver #####
     18            ==============================================================================
     19              [..]
     20                The SPI HAL driver can be used as follows:
     21          
     22                (#) Declare a SPI_HandleTypeDef handle structure, for example:
     23                    SPI_HandleTypeDef  hspi; 
     24          
     25                (#)Initialize the SPI low level resources by implement the HAL_SPI_MspInit ()API:
     26                    (##) Enable the SPIx interface clock 
     27                    (##) SPI pins configuration
     28                        (+++) Enable the clock for the SPI GPIOs 
     29                        (+++) Configure these SPI pins as alternate function push-pull
     30                    (##) NVIC configuration if you need to use interrupt process
     31                        (+++) Configure the SPIx interrupt priority
     32                        (+++) Enable the NVIC SPI IRQ handle
     33                    (##) DMA Configuration if you need to use DMA process
     34                        (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive stream
     35                        (+++) Enable the DMAx interface clock using 
     36                        (+++) Configure the DMA handle parameters 
     37                        (+++) Configure the DMA Tx or Rx Stream
     38                        (+++) Associate the initilalized hdma_tx handle to the hspi DMA Tx or Rx handle
     39                        (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx Stream
     40          
     41                (#) Program the Mode, Direction , Data size, Baudrate Prescaler, NSS 
     42                    management, Clock polarity and phase, FirstBit and CRC configuration in the hspi Init structure.
     43          
     44                (#) Initialize the SPI registers by calling the HAL_SPI_Init() API:
     45                    (++) This API configures also the low level Hardware GPIO, CLOCK, CORTEX...etc)
     46                        by calling the customed HAL_SPI_MspInit(&hspi) API.
     47              [..]
     48                 Circular mode restriction:
     49                (#) The DMA circular mode cannot be used when the SPI is configured in these modes:
     50                    (##) Master 2Lines RxOnly
     51                    (##) Master 1Line Rx
     52                (#) The CRC feature is not managed when the DMA circular mode is enabled
     53                (#) When the SPI DMA Pause/Stop features are used, we must use the following APIs 
     54                    the HAL_SPI_DMAPause()/ HAL_SPI_DMAStop() only under the SPI callbacks
     55          
     56              [..]
     57              Using the HAL it is not possible to reach all supported SPI frequency with the differents SPI Modes,
     58              the following table resume the max SPI frequency reached with data size 8bits/16bits:
     59             +-----------------------------------------------------------------------------------------+
     60             |         |                | 2Lines Fullduplex  |     2Lines RxOnly  |        1Line       |
     61             | Process | Tranfert mode  |--------------------|--------------------|--------------------|
     62             |         |                |  Master  |  Slave  |  Master  |  Slave  |  Master  |  Slave  |
     63             |=========================================================================================|
     64             |    T    |     Polling    |  Fcpu/2  |  Fcpu/2 |    NA    |    NA   |    NA    |   NA    |
     65             |    X    |----------------|----------|---------|----------|---------|----------|---------|
     66             |    /    |     Interrupt  |  Fcpu/4  | Fcpu/16 |    NA    |    NA   |    NA    |   NA    |
     67             |    R    |----------------|----------|---------|----------|---------|----------|---------|
     68             |    X    |       DMA      |  Fcpu/2  |  Fcpu/2 |    NA    |    NA   |    NA    |   NA    |
     69             |=========|================|==========|=========|==========|=========|==========|=========|
     70             |         |     Polling    |  Fcpu/2  |  Fcpu/4 |  Fcpu/16 |  Fcpu/8 |  Fcpu/8  |  Fcpu/8 |
     71             |         |----------------|----------|---------|----------|---------|----------|---------|
     72             |    R    |     Interrupt  |  Fcpu/8  | Fcpu/16 |  Fcpu/8  |  Fcpu/8 |  Fcpu/8  |  Fcpu/4 |
     73             |    X    |----------------|----------|---------|----------|---------|----------|---------|
     74             |         |       DMA      |  Fcpu/4  |  Fcpu/2 |  Fcpu/4  | Fcpu/16 |  Fcpu/2  | Fcpu/16 |
     75             |=========|================|==========|=========|==========|=========|==========|=========|
     76             |         |     Polling    |  Fcpu/2  |  Fcpu/2 |    NA    |    NA   |  Fcpu/8  |  Fcpu/8 |
     77             |         |----------------|----------|---------|----------|---------|----------|---------|
     78             |    T    |     Interrupt  |  Fcpu/2  |  Fcpu/4 |    NA    |    NA   |  Fcpu/16 |  Fcpu/8 |
     79             |    X    |----------------|----------|---------|----------|---------|----------|---------|
     80             |         |       DMA      |  Fcpu/2  |  Fcpu/2 |    NA    |    NA   |  Fcpu/8  | Fcpu/16 |
     81             +-----------------------------------------------------------------------------------------+
     82            @note The max SPI frequency depend on SPI data size (4bits, 5bits,..., 8bits,...15bits, 16bits),
     83                  SPI mode(2 Lines fullduplex, 2 lines RxOnly, 1 line TX/RX) and Process mode (Polling, IT, DMA).
     84            @note
     85             (#) TX/RX processes are HAL_SPI_TransmitReceive(), HAL_SPI_TransmitReceive_IT() and HAL_SPI_TransmitReceive_DMA()
     86             (#) RX processes are HAL_SPI_Receive(), HAL_SPI_Receive_IT() and HAL_SPI_Receive_DMA()
     87             (#) TX processes are HAL_SPI_Transmit(), HAL_SPI_Transmit_IT() and HAL_SPI_Transmit_DMA()
     88          
     89            @endverbatim
     90            ******************************************************************************
     91            * @attention
     92            *
     93            * <h2><center>&copy; COPYRIGHT(c) 2014 STMicroelectronics</center></h2>
     94            *
     95            * Redistribution and use in source and binary forms, with or without modification,
     96            * are permitted provided that the following conditions are met:
     97            *   1. Redistributions of source code must retain the above copyright notice,
     98            *      this list of conditions and the following disclaimer.
     99            *   2. Redistributions in binary form must reproduce the above copyright notice,
    100            *      this list of conditions and the following disclaimer in the documentation
    101            *      and/or other materials provided with the distribution.
    102            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    103            *      may be used to endorse or promote products derived from this software
    104            *      without specific prior written permission.
    105            *
    106            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    107            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    108            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    109            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    110            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    111            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    112            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    113            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    114            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    115            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    116            *
    117            ******************************************************************************
    118            */
    119          
    120          /* Includes ------------------------------------------------------------------*/
    121          #include "stm32l0xx_hal.h"
    122          
    123          /** @addtogroup STM32L0xx_HAL_Driver
    124            * @{
    125            */
    126          
    127          /** @defgroup SPI 
    128            * @brief SPI HAL module driver
    129            * @{
    130            */
    131          
    132          #ifdef HAL_SPI_MODULE_ENABLED
    133          
    134          /* Private typedef -----------------------------------------------------------*/
    135          /* Private define ------------------------------------------------------------*/
    136          #define SPI_TIMEOUT_VALUE  100
    137          /* Private macro -------------------------------------------------------------*/
    138          /* Private variables ---------------------------------------------------------*/
    139          /* Private function prototypes -----------------------------------------------*/
    140          static void SPI_TxCloseIRQHandler(SPI_HandleTypeDef *hspi);
    141          static void SPI_TxISR(SPI_HandleTypeDef *hspi);
    142          static void SPI_RxCloseIRQHandler(SPI_HandleTypeDef *hspi);
    143          static void SPI_2LinesRxISR(SPI_HandleTypeDef *hspi);
    144          static void SPI_RxISR(SPI_HandleTypeDef *hspi);
    145          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    146          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    147          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    148          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma);
    149          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma);
    150          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    151          static void SPI_DMAError(DMA_HandleTypeDef *hdma);
    152          static HAL_StatusTypeDef SPI_WaitOnFlagUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus Status, uint32_t Timeout);
    153          
    154          /* Private functions ---------------------------------------------------------*/
    155          
    156          /** @defgroup SPI_Private_Functions
    157            * @{
    158            */
    159          
    160          /** @defgroup SPI_Group1 Initialization and de-initialization functions 
    161           *  @brief    Initialization and Configuration functions 
    162           *
    163          @verbatim
    164           ===============================================================================
    165                        ##### Initialization and de-initialization functions #####
    166           ===============================================================================
    167              [..]  This subsection provides a set of functions allowing to initialize and 
    168                    de-initialiaze the SPIx peripheral:
    169          
    170                (+) User must Implement HAL_SPI_MspInit() function in which he configures 
    171                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    172          
    173                (+) Call the function HAL_SPI_Init() to configure the selected device with 
    174                    the selected configuration:
    175                  (++) Mode
    176                  (++) Direction 
    177                  (++) Data Size
    178                  (++) Clock Polarity and Phase
    179                  (++) NSS Management
    180                  (++) BaudRate Prescaler
    181                  (++) FirstBit
    182                  (++) TIMode
    183                  (++) CRC Calculation
    184                  (++) CRC Polynomial if CRC enabled
    185          
    186                (+) Call the function HAL_SPI_DeInit() to restore the default configuration 
    187                    of the selected SPIx periperal.       
    188          
    189          @endverbatim
    190            * @{
    191            */
    192          
    193          /**
    194            * @brief  Initializes the SPI according to the specified parameters 
    195            *         in the SPI_InitTypeDef and create the associated handle.
    196            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    197            *                the configuration information for SPI module.
    198            * @retval HAL status
    199            */
    200          HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
    201          {
    202            /* Check the SPI handle allocation */
    203            if(hspi == NULL)
    204            {
    205              return HAL_ERROR;
    206            }
    207          
    208            /* Check the parameters */
    209            assert_param(IS_SPI_MODE(hspi->Init.Mode));
    210            assert_param(IS_SPI_DIRECTION_MODE(hspi->Init.Direction));
    211            assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
    212            assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    213            assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
    214            assert_param(IS_SPI_NSS(hspi->Init.NSS));
    215            assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    216            assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
    217            assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
    218            assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
    219            assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    220          
    221            if(hspi->State == HAL_SPI_STATE_RESET)
    222            {
    223              /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    224              HAL_SPI_MspInit(hspi);
    225            }
    226            
    227            hspi->State = HAL_SPI_STATE_BUSY;
    228          
    229            /* Disble the selected SPI peripheral */
    230            __HAL_SPI_DISABLE(hspi);
    231          
    232            /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
    233            /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
    234            Communication speed, First bit and CRC calculation state */
    235            hspi->Instance->CR1 = (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
    236                                   hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
    237                                   hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation);
    238          
    239            /* Configure : NSS management */
    240            hspi->Instance->CR2 = (((hspi->Init.NSS >> 16) & SPI_CR2_SSOE) | hspi->Init.TIMode);
    241          
    242            /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
    243            /* Configure : CRC Polynomial */
    244            hspi->Instance->CRCPR = hspi->Init.CRCPolynomial;
    245          
    246            /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
    247            hspi->Instance->I2SCFGR &= (uint32_t)~((uint32_t)SPI_I2SCFGR_I2SMOD);
    248          
    249            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
    250            hspi->State = HAL_SPI_STATE_READY;
    251            
    252            return HAL_OK;
    253          }
    254          
    255          
    256          /**
    257            * @brief  DeInitializes the SPI peripheral 
    258            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    259            *                the configuration information for SPI module.
    260            * @retval HAL status
    261            */
    262          HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
    263          {
    264            /* Check the SPI handle allocation */
    265            if(hspi == NULL)
    266            {
    267              return HAL_ERROR;
    268            }
    269          
    270            hspi->State = HAL_SPI_STATE_BUSY;
    271          
    272            /* Disable the SPI Peripheral Clock */
    273            __HAL_SPI_DISABLE(hspi);
    274          
    275            /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
    276            HAL_SPI_MspDeInit(hspi);
    277          
    278            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
    279            hspi->State = HAL_SPI_STATE_RESET;
    280          
    281            /* Release Lock */
    282            __HAL_UNLOCK(hspi);
    283          
    284            return HAL_OK;
    285          }
    286          
    287          /**
    288            * @brief SPI MSP Init
    289            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    290            *                the configuration information for SPI module.
    291            * @retval None
    292            */
    293           __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
    294           {
    295             /* NOTE : This function Should not be modified, when the callback is needed,
    296                      the HAL_SPI_MspInit could be implenetd in the user file
    297             */
    298          }
    299          
    300          /**
    301            * @brief SPI MSP DeInit
    302            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    303            *                the configuration information for SPI module.
    304            * @retval None
    305            */
    306           __weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
    307          {
    308            /* NOTE : This function Should not be modified, when the callback is needed,
    309                      the HAL_SPI_MspDeInit could be implenetd in the user file
    310             */
    311          }
    312          
    313          /**
    314            * @}
    315            */
    316          
    317          /** @defgroup SPI_Group2 IO operation functions
    318           *  @brief   Data transfers functions
    319           *
    320          @verbatim
    321            ==============================================================================
    322                                ##### IO operation functions #####
    323           ===============================================================================
    324              This subsection provides a set of functions allowing to manage the SPI
    325              data transfers.
    326          
    327              [..] The SPI supports master and slave mode :
    328          
    329              (#) There are two mode of transfer:
    330                 (++) Blocking mode: The communication is performed in polling mode.
    331                      The HAL status of all data processing is returned by the same function
    332                      after finishing transfer.
    333                 (++) No-Blocking mode: The communication is performed using Interrupts
    334                     or DMA, These API's return the HAL status.
    335                     The end of the data processing will be indicated through the 
    336                     dedicated SPI IRQ when using Interrupt mode or the DMA IRQ when 
    337                     using DMA mode.
    338                     The HAL_SPI_TxCpltCallback(), HAL_SPI_RxCpltCallback() and HAL_SPI_TxRxCpltCallback() user callbacks 
    339                     will be executed respectivelly at the end of the transmit or Receive process
    340                     The HAL_SPI_ErrorCallback()user callback will be executed when a communication error is detected
    341          
    342              (#) Blocking mode API's are :
    343                  (++) HAL_SPI_Transmit()in 1Line (simplex) and 2Lines (full duplex) mode
    344                  (++) HAL_SPI_Receive() in 1Line (simplex) and 2Lines (full duplex) mode
    345                  (++) HAL_SPI_TransmitReceive() in full duplex mode
    346          
    347              (#) Non-Blocking mode API's with Interrupt are :
    348                  (++) HAL_SPI_Transmit_IT()in 1Line (simplex) and 2Lines (full duplex) mode
    349                  (++) HAL_SPI_Receive_IT() in 1Line (simplex) and 2Lines (full duplex) mode
    350                  (++) HAL_SPI_TransmitReceive_IT()in full duplex mode
    351                  (++) HAL_SPI_IRQHandler()
    352          
    353              (#) No-Blocking mode functions with DMA are :
    354                  (++) HAL_SPI_Transmit_DMA()in 1Line (simplex) and 2Lines (full duplex) mode
    355                  (++) HAL_SPI_Receive_DMA() in 1Line (simplex) and 2Lines (full duplex) mode
    356                  (++) HAL_SPI_TransmitReceie_DMA() in full duplex mode
    357          
    358              (#) A set of Transfer Complete Callbacks are provided in No_Blocking mode:
    359                  (++) HAL_SPI_TxCpltCallback()
    360                  (++) HAL_SPI_RxCpltCallback()
    361                  (++) HAL_SPI_ErrorCallback()
    362                  (++) HAL_SPI_TxRxCpltCallback()
    363          
    364          @endverbatim
    365            * @{
    366            */
    367          
    368          /**
    369            * @brief  Transmit an amount of data in blocking mode
    370            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    371            *                the configuration information for SPI module.
    372            * @param  pData: pointer to data buffer
    373            * @param  Size: amount of data to be sent
    374            * @param  Timeout: Timeout duration
    375            * @retval HAL status
    376            */
    377          HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    378          {
    379          
    380            if(hspi->State == HAL_SPI_STATE_READY)
    381            {
    382              if((pData == NULL ) || (Size == 0)) 
    383              {
    384                return  HAL_ERROR;
    385              }
    386          
    387              /* Check the parameters */
    388              assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
    389          
    390              /* Process Locked */
    391              __HAL_LOCK(hspi);
    392          
    393              /* Configure communication */
    394              hspi->State = HAL_SPI_STATE_BUSY_TX;
    395              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
    396          
    397              hspi->pTxBuffPtr = pData;
    398              hspi->TxXferSize = Size;
    399              hspi->TxXferCount = Size;
    400          
    401              /*Init field not used in handle to zero */
    402              hspi->TxISR = 0;
    403              hspi->RxISR = 0;
    404              hspi->RxXferSize   = 0;
    405              hspi->RxXferCount  = 0;
    406          
    407              /* Reset CRC Calculation */
    408              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
    409              {
    410                __HAL_SPI_RESET_CRC(hspi);
    411              }
    412          
    413              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
    414              {
    415                /* Configure communication direction : 1Line */
    416                __HAL_SPI_1LINE_TX(hspi);
    417              }
    418          
    419              /* Check if the SPI is already enabled */ 
    420              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
    421              {
    422                /* Enable SPI peripheral */
    423                __HAL_SPI_ENABLE(hspi);
    424              }
    425          
    426              /* Transmit data in 8 Bit mode */
    427              if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
    428              {
    429          
    430                if((hspi->Init.Mode == SPI_MODE_SLAVE)|| (hspi->TxXferCount == 0x01))
    431                {
    432                  hspi->Instance->DR = (*hspi->pTxBuffPtr++);
    433                  hspi->TxXferCount--;
    434                }
    435          
    436                while(hspi->TxXferCount > 0)
    437                {
    438                  /* Wait until TXE flag is set to send data */
    439                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
    440                  { 
    441                    return HAL_TIMEOUT;
    442                  }
    443                  hspi->Instance->DR = (*hspi->pTxBuffPtr++);
    444                  hspi->TxXferCount--;
    445                }
    446                /* Enable CRC Transmission */
    447                if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED) 
    448                {
    449                  hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
    450                }
    451              }
    452              /* Transmit data in 16 Bit mode */
    453              else
    454              {
    455                if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01))
    456                {
    457                  hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
    458                  hspi->pTxBuffPtr+=2;
    459                  hspi->TxXferCount--;
    460                }
    461          
    462                while(hspi->TxXferCount > 0)
    463                {
    464                  /* Wait until TXE flag is set to send data */
    465                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
    466                  { 
    467                    return HAL_TIMEOUT;
    468                  }
    469                  hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
    470                  hspi->pTxBuffPtr+=2;
    471                  hspi->TxXferCount--;
    472                }
    473                /* Enable CRC Transmission */
    474                if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED) 
    475                {
    476                  hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
    477                }
    478              }
    479          
    480              /* Wait until TXE flag is set to send data */
    481              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
    482              {
    483                hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
    484                return HAL_TIMEOUT;
    485              }
    486          
    487              /* Wait until Busy flag is reset before disabling SPI */
    488              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, Timeout) != HAL_OK)
    489              { 
    490                hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
    491                return HAL_TIMEOUT;
    492              }
    493           
    494              /* Clear OVERUN flag in 2 Lines communication mode because received is not read */
    495              if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
    496              {
    497                __HAL_SPI_CLEAR_OVRFLAG(hspi);
    498              }
    499          
    500              hspi->State = HAL_SPI_STATE_READY; 
    501          
    502              /* Process Unlocked */
    503              __HAL_UNLOCK(hspi);
    504          
    505              return HAL_OK;
    506            }
    507            else
    508            {
    509              return HAL_BUSY;
    510            }
    511          }
    512          
    513          /**
    514            * @brief  Receive an amount of data in blocking mode 
    515            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    516            *                the configuration information for SPI module.
    517            * @param  pData: pointer to data buffer
    518            * @param  Size: amount of data to be sent
    519            * @param  Timeout: Timeout duration
    520            * @retval HAL status
    521            */
    522          HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    523          {
    524            __IO uint16_t tmpreg;
    525            uint32_t tmp = 0;
    526          
    527            if(hspi->State == HAL_SPI_STATE_READY)
    528            {
    529              if((pData == NULL ) || (Size == 0)) 
    530              {
    531                return  HAL_ERROR;
    532              }
    533          
    534              /* Process Locked */
    535              __HAL_LOCK(hspi);
    536          
    537              /* Configure communication */
    538              hspi->State       = HAL_SPI_STATE_BUSY_RX;
    539              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
    540          
    541              hspi->pRxBuffPtr  = pData;
    542              hspi->RxXferSize  = Size;
    543              hspi->RxXferCount = Size;
    544          
    545              /*Init field not used in handle to zero */
    546              hspi->RxISR = 0;
    547              hspi->TxISR = 0;
    548              hspi->TxXferSize   = 0;
    549              hspi->TxXferCount  = 0;
    550          
    551              /* Configure communication direction : 1Line */
    552              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
    553              {
    554                __HAL_SPI_1LINE_RX(hspi);
    555              }
    556          
    557              /* Reset CRC Calculation */
    558              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
    559              {
    560                __HAL_SPI_RESET_CRC(hspi);
    561              }
    562              
    563              if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
    564              {
    565                /* Process Unlocked */
    566                __HAL_UNLOCK(hspi);
    567          
    568                /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
    569                return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
    570              }
    571          
    572              /* Check if the SPI is already enabled */ 
    573              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
    574              {
    575                /* Enable SPI peripheral */
    576                __HAL_SPI_ENABLE(hspi);
    577              }
    578          
    579              /* Receive data in 8 Bit mode */
    580              if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
    581              {
    582                while(hspi->RxXferCount > 1)
    583                {
    584                  /* Wait until RXNE flag is set */
    585                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
    586                  { 
    587                    return HAL_TIMEOUT;
    588                  }
    589          
    590                  (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
    591                  hspi->RxXferCount--;
    592                }
    593                /* Enable CRC Transmission */
    594                if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED) 
    595                {
    596                  hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
    597                }
    598              }
    599              /* Receive data in 16 Bit mode */
    600              else
    601              {
    602                while(hspi->RxXferCount > 1)
    603                {
    604                  /* Wait until RXNE flag is set to read data */
    605                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
    606                  { 
    607                    return HAL_TIMEOUT;
    608                  }
    609          
    610                  *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
    611                  hspi->pRxBuffPtr+=2;
    612                  hspi->RxXferCount--;
    613                }
    614                /* Enable CRC Transmission */
    615                if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED) 
    616                {
    617                  hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
    618                }
    619              }
    620          
    621              /* Wait until RXNE flag is set */
    622              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
    623              { 
    624                return HAL_TIMEOUT;
    625              }
    626          
    627              /* Receive last data in 8 Bit mode */
    628              if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
    629              {
    630                (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
    631              }
    632              /* Receive last data in 16 Bit mode */
    633              else
    634              {
    635                *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
    636                hspi->pRxBuffPtr+=2;
    637              }
    638              hspi->RxXferCount--;
    639          
    640              /* Wait until RXNE flag is set: CRC Received */
    641              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
    642              {
    643                if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
    644                {
    645                  hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
    646                  return HAL_TIMEOUT;
    647                }
    648          
    649                /* Read CRC to Flush RXNE flag */
    650                tmpreg = hspi->Instance->DR;
    651              }
    652              
    653              if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
    654              {
    655                /* Disable SPI peripheral */
    656                __HAL_SPI_DISABLE(hspi);
    657              }
    658          
    659              hspi->State = HAL_SPI_STATE_READY;
    660          
    661              tmp = __HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR);
    662              /* Check if CRC error occurred */
    663              if((hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED) && (tmp != RESET))
    664              {  
    665                hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
    666          
    667                /* Reset CRC Calculation */
    668                __HAL_SPI_RESET_CRC(hspi);
    669          
    670                /* Process Unlocked */
    671                __HAL_UNLOCK(hspi);
    672          
    673                return HAL_ERROR; 
    674              }
    675          
    676              /* Process Unlocked */
    677              __HAL_UNLOCK(hspi);
    678          
    679              return HAL_OK;
    680            }
    681            else
    682            {
    683              return HAL_BUSY;
    684            }
    685          }
    686          
    687          /**
    688            * @brief  Transmit and Receive an amount of data in blocking mode 
    689            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    690            *                the configuration information for SPI module.
    691            * @param  pTxData: pointer to transmission data buffer
    692            * @param  pRxData: pointer to reception data buffer to be
    693            * @param  Size: amount of data to be sent
    694            * @param  Timeout: Timeout duration
    695            * @retval HAL status
    696            */
    697          HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
    698          {
    699            __IO uint16_t tmpreg;
    700            uint32_t tmpstate = 0, tmp = 0;
    701            
    702            tmpstate = hspi->State; 
    703            if((tmpstate == HAL_SPI_STATE_READY) || (tmpstate == HAL_SPI_STATE_BUSY_RX))
    704            {
    705              if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
    706              {
    707                return  HAL_ERROR;
    708              }
    709          
    710              /* Check the parameters */
    711              assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
    712          
    713              /* Process Locked */
    714              __HAL_LOCK(hspi);
    715           
    716              /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
    717              if(hspi->State == HAL_SPI_STATE_READY)
    718              {
    719                hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
    720              }
    721          
    722               /* Configure communication */   
    723              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
    724          
    725              hspi->pRxBuffPtr  = pRxData;
    726              hspi->RxXferSize  = Size;
    727              hspi->RxXferCount = Size;  
    728              
    729              hspi->pTxBuffPtr  = pTxData;
    730              hspi->TxXferSize  = Size; 
    731              hspi->TxXferCount = Size;
    732          
    733              /*Init field not used in handle to zero */
    734              hspi->RxISR = 0;
    735              hspi->TxISR = 0;
    736          
    737              /* Reset CRC Calculation */
    738              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
    739              {
    740                __HAL_SPI_RESET_CRC(hspi);
    741              }
    742          
    743              /* Check if the SPI is already enabled */ 
    744              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
    745              {
    746                /* Enable SPI peripheral */
    747                __HAL_SPI_ENABLE(hspi);
    748              }
    749          
    750              /* Transmit and Receive data in 16 Bit mode */
    751              if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
    752              {
    753                if((hspi->Init.Mode == SPI_MODE_SLAVE) || ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->TxXferCount == 0x01)))
    754                {
    755                  hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
    756                  hspi->pTxBuffPtr+=2;
    757                  hspi->TxXferCount--;
    758                }
    759                if(hspi->TxXferCount == 0)
    760                {
    761                  /* Enable CRC Transmission */
    762                  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
    763                  {
    764                    hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
    765                  }
    766          
    767                  /* Wait until RXNE flag is set */
    768                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
    769                  { 
    770                    return HAL_TIMEOUT;
    771                  }
    772          
    773                  *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
    774                  hspi->pRxBuffPtr+=2;
    775                  hspi->RxXferCount--;
    776                }
    777                else
    778                {
    779                  while(hspi->TxXferCount > 0)
    780                  {
    781                    /* Wait until TXE flag is set to send data */
    782                    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
    783                    { 
    784                      return HAL_TIMEOUT;
    785                    }
    786          
    787                    hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
    788                    hspi->pTxBuffPtr+=2;
    789                    hspi->TxXferCount--;
    790          
    791                    /* Enable CRC Transmission */
    792                    if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED))
    793                    {
    794                      hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
    795                    }
    796          
    797                    /* Wait until RXNE flag is set */
    798                    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
    799                    { 
    800                      return HAL_TIMEOUT;
    801                    }
    802                    
    803                    *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
    804                    hspi->pRxBuffPtr+=2;
    805                    hspi->RxXferCount--;
    806                  }
    807                  /* Receive the last byte */
    808                  if(hspi->Init.Mode == SPI_MODE_SLAVE)
    809                  {
    810                    /* Wait until RXNE flag is set */
    811                    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
    812                    {
    813                      return HAL_TIMEOUT;
    814                    }
    815                    
    816                    *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
    817                    hspi->pRxBuffPtr+=2;
    818                    hspi->RxXferCount--;
    819                  }
    820                }
    821              }
    822              /* Transmit and Receive data in 8 Bit mode */
    823              else
    824              {
    825                if((hspi->Init.Mode == SPI_MODE_SLAVE) || ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->TxXferCount == 0x01)))
    826                {
    827                  hspi->Instance->DR = (*hspi->pTxBuffPtr++);
    828                  hspi->TxXferCount--;
    829                }
    830                if(hspi->TxXferCount == 0)
    831                {
    832                  /* Enable CRC Transmission */
    833                  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
    834                  {
    835                    hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
    836                  }
    837          
    838                  /* Wait until RXNE flag is set */
    839                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
    840                  {
    841                    return HAL_TIMEOUT;
    842                  }
    843          
    844                  (*hspi->pRxBuffPtr) = hspi->Instance->DR;
    845                  hspi->RxXferCount--;
    846                }
    847                else
    848                {
    849                  while(hspi->TxXferCount > 0)
    850                  {
    851                    /* Wait until TXE flag is set to send data */
    852                    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, Timeout) != HAL_OK)
    853                    {
    854                      return HAL_TIMEOUT;
    855                    }
    856          
    857                    hspi->Instance->DR = (*hspi->pTxBuffPtr++);
    858                    hspi->TxXferCount--;
    859          
    860                    /* Enable CRC Transmission */
    861                    if((hspi->TxXferCount == 0) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED))
    862                    {
    863                      hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
    864                    }
    865          
    866                      /* Wait until RXNE flag is set */
    867                      if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
    868                      {
    869                        return HAL_TIMEOUT;
    870                      }
    871                      
    872                      (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
    873                      hspi->RxXferCount--;
    874                  }
    875                  if(hspi->Init.Mode == SPI_MODE_SLAVE)
    876                  {
    877                    /* Wait until RXNE flag is set */
    878                    if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
    879                    {
    880                      return HAL_TIMEOUT;
    881                    }
    882                    
    883                    (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
    884                    hspi->RxXferCount--;
    885                  }
    886                }
    887              }
    888          
    889              /* Read CRC from DR to close CRC calculation process */
    890              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
    891              {
    892                /* Wait until RXNE flag is set */
    893                if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout) != HAL_OK)
    894                {
    895                  hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
    896                  return HAL_TIMEOUT;
    897                }
    898                /* Read CRC */
    899                tmpreg = hspi->Instance->DR;
    900              }
    901          
    902              /* Wait until Busy flag is reset before disabling SPI */
    903              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, Timeout) != HAL_OK)
    904              {
    905                hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
    906                return HAL_TIMEOUT;
    907              }
    908              
    909              hspi->State = HAL_SPI_STATE_READY;
    910          
    911              tmp = __HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR);
    912              /* Check if CRC error occurred */
    913              if((hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED) && (tmp != RESET))
    914              {
    915                hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
    916          
    917                /* Reset CRC Calculation */
    918                if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
    919                {
    920                  __HAL_SPI_RESET_CRC(hspi);
    921                }
    922          
    923                /* Process Unlocked */
    924                __HAL_UNLOCK(hspi);
    925                
    926                return HAL_ERROR; 
    927              }
    928          
    929              /* Process Unlocked */
    930              __HAL_UNLOCK(hspi);
    931          
    932              return HAL_OK;
    933            }
    934            else
    935            {
    936              return HAL_BUSY;
    937            }
    938          }
    939          
    940          /**
    941            * @brief  Transmit an amount of data in no-blocking mode with Interrupt
    942            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
    943            *                the configuration information for SPI module.
    944            * @param  pData: pointer to data buffer
    945            * @param  Size: amount of data to be sent
    946            * @retval HAL status
    947            */
    948          HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
    949          {
    950            if(hspi->State == HAL_SPI_STATE_READY)
    951            {
    952              if((pData == NULL) || (Size == 0))
    953              {
    954                return  HAL_ERROR;
    955              }
    956          
    957              /* Check the parameters */
    958              assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
    959          
    960              /* Process Locked */
    961              __HAL_LOCK(hspi);
    962          
    963              /* Configure communication */
    964              hspi->State        = HAL_SPI_STATE_BUSY_TX;
    965              hspi->ErrorCode    = HAL_SPI_ERROR_NONE;
    966          
    967              hspi->TxISR = &SPI_TxISR;
    968              hspi->pTxBuffPtr   = pData;
    969              hspi->TxXferSize   = Size;
    970              hspi->TxXferCount  = Size;
    971          
    972              /*Init field not used in handle to zero */
    973              hspi->RxISR = 0;
    974              hspi->RxXferSize   = 0;
    975              hspi->RxXferCount  = 0;
    976          
    977              /* Configure communication direction : 1Line */
    978              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
    979              {
    980                __HAL_SPI_1LINE_TX(hspi);
    981              }
    982          
    983              /* Reset CRC Calculation */
    984              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
    985              {
    986                __HAL_SPI_RESET_CRC(hspi);
    987              }
    988          
    989              if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
    990              {
    991                __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE));
    992              }else
    993              {
    994                /* Enable TXE and ERR interrupt */
    995                __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
    996              }
    997              /* Process Unlocked */
    998              __HAL_UNLOCK(hspi);
    999          
   1000              /* Check if the SPI is already enabled */ 
   1001              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   1002              {
   1003                /* Enable SPI peripheral */
   1004                __HAL_SPI_ENABLE(hspi);
   1005              }
   1006          
   1007              return HAL_OK;
   1008            }
   1009            else
   1010            {
   1011              return HAL_BUSY;
   1012            }
   1013          }
   1014          
   1015          
   1016          /**
   1017            * @brief  Receive an amount of data in no-blocking mode with Interrupt
   1018            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1019            *                the configuration information for SPI module.
   1020            * @param  pData: pointer to data buffer
   1021            * @param  Size: amount of data to be sent
   1022            * @retval HAL status
   1023            */
   1024          HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1025          {
   1026            if(hspi->State == HAL_SPI_STATE_READY)
   1027            {
   1028              if((pData == NULL) || (Size == 0)) 
   1029              {
   1030                return  HAL_ERROR;
   1031              }
   1032          
   1033              /* Process Locked */
   1034              __HAL_LOCK(hspi);
   1035          
   1036              /* Configure communication */
   1037              hspi->State        = HAL_SPI_STATE_BUSY_RX;
   1038              hspi->ErrorCode    = HAL_SPI_ERROR_NONE;
   1039          
   1040              hspi->RxISR = &SPI_RxISR;
   1041              hspi->pRxBuffPtr   = pData;
   1042              hspi->RxXferSize   = Size;
   1043              hspi->RxXferCount  = Size ; 
   1044          
   1045             /*Init field not used in handle to zero */
   1046              hspi->TxISR = 0;
   1047              hspi->TxXferSize   = 0;
   1048              hspi->TxXferCount  = 0;
   1049          
   1050              /* Configure communication direction : 1Line */
   1051              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   1052              {
   1053                 __HAL_SPI_1LINE_RX(hspi);
   1054              }
   1055              else if((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
   1056              {
   1057                 /* Process Unlocked */
   1058                 __HAL_UNLOCK(hspi);
   1059          
   1060                 /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
   1061                 return HAL_SPI_TransmitReceive_IT(hspi, pData, pData, Size);
   1062              }
   1063          
   1064              /* Reset CRC Calculation */
   1065              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
   1066              {
   1067                __HAL_SPI_RESET_CRC(hspi);
   1068              }
   1069          
   1070              /* Enable TXE and ERR interrupt */
   1071              __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   1072          
   1073              /* Process Unlocked */
   1074              __HAL_UNLOCK(hspi);
   1075          
   1076              /* Note : The SPI must be enabled after unlocking current process 
   1077                        to avoid the risk of SPI interrupt handle execution before current
   1078                        process unlock */
   1079          
   1080                  /* Check if the SPI is already enabled */ 
   1081              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   1082              {
   1083                /* Enable SPI peripheral */
   1084                __HAL_SPI_ENABLE(hspi);
   1085              }
   1086          
   1087              return HAL_OK;
   1088            }
   1089            else
   1090            {
   1091              return HAL_BUSY; 
   1092            }
   1093          }
   1094          
   1095          
   1096          /**
   1097            * @brief  Transmit and Receive an amount of data in no-blocking mode with Interrupt 
   1098            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1099            *                the configuration information for SPI module.
   1100            * @param  pTxData: pointer to transmission data buffer
   1101            * @param  pRxData: pointer to reception data buffer to be
   1102            * @param  Size: amount of data to be sent
   1103            * @retval HAL status
   1104            */
   1105          HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1106          {
   1107           uint32_t tmpstate = 0;
   1108          
   1109           tmpstate = hspi->State;
   1110            if((tmpstate == HAL_SPI_STATE_READY) || \
   1111               ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmpstate == HAL_SPI_STATE_BUSY_RX)))
   1112            {
   1113              if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0)) 
   1114              {
   1115                return  HAL_ERROR;
   1116              }
   1117          
   1118              /* Check the parameters */
   1119              assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1120          
   1121              /* Process locked */
   1122              __HAL_LOCK(hspi);
   1123          
   1124              /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
   1125              if(hspi->State != HAL_SPI_STATE_BUSY_RX)
   1126              {
   1127                hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   1128              }
   1129          
   1130              /* Configure communication */
   1131              hspi->ErrorCode    = HAL_SPI_ERROR_NONE;
   1132          
   1133              hspi->TxISR = &SPI_TxISR;
   1134              hspi->pTxBuffPtr   = pTxData;
   1135              hspi->TxXferSize   = Size;
   1136              hspi->TxXferCount  = Size;
   1137          
   1138              hspi->RxISR = &SPI_2LinesRxISR;
   1139              hspi->pRxBuffPtr   = pRxData;
   1140              hspi->RxXferSize   = Size;
   1141              hspi->RxXferCount  = Size;
   1142          
   1143              /* Reset CRC Calculation */
   1144              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
   1145              {
   1146                __HAL_SPI_RESET_CRC(hspi);
   1147              }
   1148          
   1149              /* Enable TXE, RXNE and ERR interrupt */
   1150              __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   1151          
   1152              /* Process Unlocked */
   1153              __HAL_UNLOCK(hspi);
   1154          
   1155              /* Check if the SPI is already enabled */ 
   1156              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   1157              {
   1158                /* Enable SPI peripheral */
   1159                __HAL_SPI_ENABLE(hspi);
   1160              }
   1161          
   1162              return HAL_OK;
   1163            }
   1164            else
   1165            {
   1166              return HAL_BUSY; 
   1167            }
   1168          }
   1169          
   1170          /**
   1171            * @brief  Transmit an amount of data in no-blocking mode with DMA
   1172            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1173            *                the configuration information for SPI module.
   1174            * @param  pData: pointer to data buffer
   1175            * @param  Size: amount of data to be sent
   1176            * @retval HAL status
   1177            */
   1178          HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1179          {
   1180            if(hspi->State == HAL_SPI_STATE_READY)
   1181            {
   1182              if((pData == NULL) || (Size == 0))
   1183              {
   1184                return  HAL_ERROR;
   1185              }
   1186          
   1187              /* Check the parameters */
   1188              assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
   1189          
   1190              /* Process Locked */
   1191              __HAL_LOCK(hspi);
   1192          
   1193              /* Configure communication */
   1194              hspi->State       = HAL_SPI_STATE_BUSY_TX;
   1195              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   1196          
   1197              hspi->pTxBuffPtr  = pData;
   1198              hspi->TxXferSize  = Size;
   1199              hspi->TxXferCount = Size;
   1200          
   1201              /*Init field not used in handle to zero */
   1202              hspi->TxISR = 0;
   1203              hspi->RxISR = 0;
   1204              hspi->RxXferSize   = 0;
   1205              hspi->RxXferCount  = 0;
   1206          
   1207              /* Configure communication direction : 1Line */
   1208              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   1209              {
   1210                __HAL_SPI_1LINE_TX(hspi);
   1211              }
   1212          
   1213              /* Reset CRC Calculation */
   1214              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
   1215              {
   1216                __HAL_SPI_RESET_CRC(hspi);
   1217              }
   1218              
   1219              /* Set the SPI TxDMA Half transfer complete callback */
   1220              hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
   1221              
   1222              /* Set the SPI TxDMA transfer complete callback */
   1223              hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
   1224          
   1225              /* Set the DMA error callback */
   1226              hspi->hdmatx->XferErrorCallback = SPI_DMAError;
   1227          
   1228              /* Enable the Tx DMA Stream */
   1229              HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
   1230          
   1231              /* Enable Tx DMA Request */
   1232              hspi->Instance->CR2 |= SPI_CR2_TXDMAEN;
   1233          
   1234              /* Process Unlocked */
   1235              __HAL_UNLOCK(hspi);
   1236          
   1237              /* Check if the SPI is already enabled */ 
   1238              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   1239              {
   1240                /* Enable SPI peripheral */
   1241                __HAL_SPI_ENABLE(hspi);
   1242              }
   1243          
   1244              return HAL_OK;
   1245            }
   1246            else
   1247            {
   1248              return HAL_BUSY;
   1249            }
   1250          }
   1251          
   1252          /**
   1253            * @brief  Receive an amount of data in no-blocking mode with DMA 
   1254            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1255            *                the configuration information for SPI module.
   1256            * @param  pData: pointer to data buffer
   1257            * @note  When the CRC feature is enabled the pData Length must be Size + 1. 
   1258            * @param  Size: amount of data to be sent
   1259            * @retval HAL status
   1260            */
   1261          HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1262          {
   1263            if(hspi->State == HAL_SPI_STATE_READY)
   1264            {
   1265              if((pData == NULL) || (Size == 0))
   1266              {
   1267                return  HAL_ERROR;
   1268              }
   1269          
   1270              /* Process Locked */
   1271              __HAL_LOCK(hspi);
   1272          
   1273              /* Configure communication */
   1274              hspi->State       = HAL_SPI_STATE_BUSY_RX;
   1275              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   1276          
   1277              hspi->pRxBuffPtr  = pData;
   1278              hspi->RxXferSize  = Size;
   1279              hspi->RxXferCount = Size;
   1280          
   1281              /*Init field not used in handle to zero */
   1282              hspi->RxISR = 0;
   1283              hspi->TxISR = 0;
   1284              hspi->TxXferSize   = 0;
   1285              hspi->TxXferCount  = 0;
   1286          
   1287              /* Configure communication direction : 1Line */
   1288              if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   1289              {
   1290                 __HAL_SPI_1LINE_RX(hspi);
   1291              }
   1292              else if((hspi->Init.Direction == SPI_DIRECTION_2LINES)&&(hspi->Init.Mode == SPI_MODE_MASTER))
   1293              {
   1294                 /* Process Unlocked */
   1295                 __HAL_UNLOCK(hspi);
   1296          
   1297                 /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
   1298                 return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
   1299              }
   1300          
   1301              /* Reset CRC Calculation */
   1302              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
   1303              {
   1304                __HAL_SPI_RESET_CRC(hspi);
   1305              }
   1306              
   1307              /* Set the SPI RxDMA Half transfer complete callback */
   1308              hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   1309              
   1310              /* Set the SPI Rx DMA transfer complete callback */
   1311              hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
   1312          
   1313              /* Set the DMA error callback */
   1314              hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   1315          
   1316              /* Enable the Rx DMA Stream */
   1317              HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
   1318          
   1319              /* Enable Rx DMA Request */  
   1320              hspi->Instance->CR2 |= SPI_CR2_RXDMAEN;  
   1321          
   1322              /* Process Unlocked */
   1323              __HAL_UNLOCK(hspi);
   1324          
   1325              /* Check if the SPI is already enabled */ 
   1326              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   1327              {
   1328                /* Enable SPI peripheral */
   1329                __HAL_SPI_ENABLE(hspi);
   1330              }
   1331          
   1332              return HAL_OK;
   1333            }
   1334            else
   1335            {
   1336              return HAL_BUSY;
   1337            }
   1338          }
   1339          
   1340          /**
   1341            * @brief  Transmit and Receive an amount of data in no-blocking mode with DMA 
   1342            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1343            *                the configuration information for SPI module.
   1344            * @param  pTxData: pointer to transmission data buffer
   1345            * @param  pRxData: pointer to reception data buffer
   1346            * @note  When the CRC feature is enabled the pRxData Length must be Size + 1 
   1347            * @param  Size: amount of data to be sent
   1348            * @retval HAL status
   1349            */
   1350          HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1351          {
   1352            uint32_t tmpstate = 0;
   1353            tmpstate = hspi->State;
   1354            if((tmpstate == HAL_SPI_STATE_READY) || ((hspi->Init.Mode == SPI_MODE_MASTER) && \
   1355               (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmpstate == HAL_SPI_STATE_BUSY_RX)))
   1356            {
   1357              if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
   1358              {
   1359                return  HAL_ERROR;
   1360              }
   1361          
   1362              /* Check the parameters */
   1363              assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1364              
   1365              /* Process locked */
   1366              __HAL_LOCK(hspi);
   1367          
   1368              /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
   1369              if(hspi->State != HAL_SPI_STATE_BUSY_RX)
   1370              {
   1371                hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   1372              }
   1373          
   1374              /* Configure communication */
   1375              hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   1376          
   1377              hspi->pTxBuffPtr  = (uint8_t*)pTxData;
   1378              hspi->TxXferSize  = Size;
   1379              hspi->TxXferCount = Size;
   1380          
   1381              hspi->pRxBuffPtr  = (uint8_t*)pRxData;
   1382              hspi->RxXferSize  = Size;
   1383              hspi->RxXferCount = Size;
   1384          
   1385              /*Init field not used in handle to zero */
   1386              hspi->RxISR = 0;
   1387              hspi->TxISR = 0;
   1388          
   1389              /* Reset CRC Calculation */
   1390              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
   1391              {
   1392                __HAL_SPI_RESET_CRC(hspi);
   1393              }
   1394          
   1395              /* Check if we are in Rx only or in Rx/Tx Mode and configure the DMA transfer complete callback */
   1396              if(hspi->State == HAL_SPI_STATE_BUSY_RX)
   1397              {
   1398                /* Set the SPI Rx DMA Half transfer complete callback */
   1399                hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   1400                
   1401                hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
   1402              }
   1403              else
   1404              {
   1405                /* Set the SPI Tx/Rx DMA Half transfer complete callback */
   1406                hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
   1407                
   1408                hspi->hdmarx->XferCpltCallback = SPI_DMATransmitReceiveCplt;
   1409              }
   1410          
   1411              /* Set the DMA error callback */
   1412              hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   1413          
   1414              /* Enable the Rx DMA Stream */
   1415              HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
   1416          
   1417              /* Enable Rx DMA Request */  
   1418              hspi->Instance->CR2 |= SPI_CR2_RXDMAEN;
   1419          
   1420              /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
   1421              is performed in DMA reception complete callback  */
   1422              hspi->hdmatx->XferCpltCallback = NULL;
   1423          
   1424              /* Set the DMA error callback */
   1425              hspi->hdmatx->XferErrorCallback = SPI_DMAError;
   1426          
   1427              /* Enable the Tx DMA Stream */
   1428              HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
   1429          
   1430              /* Check if the SPI is already enabled */ 
   1431              if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   1432              {
   1433                /* Enable SPI peripheral */
   1434                __HAL_SPI_ENABLE(hspi);
   1435              }
   1436          
   1437              /* Enable Tx DMA Request */  
   1438              hspi->Instance->CR2 |= SPI_CR2_TXDMAEN;
   1439          
   1440              /* Process Unlocked */
   1441              __HAL_UNLOCK(hspi);
   1442          
   1443              return HAL_OK;
   1444            }
   1445            else
   1446            {
   1447              return HAL_BUSY;
   1448            }
   1449          }
   1450          
   1451          /**
   1452            * @brief Pauses the DMA Transfer.
   1453            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1454            *                the configuration information for the specified SPI module.
   1455            * @retval HAL status
   1456            */
   1457          HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
   1458          {
   1459            /* Process Locked */
   1460            __HAL_LOCK(hspi);
   1461            
   1462            /* Disable the SPI DMA Tx & Rx requests */
   1463            hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
   1464            hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
   1465            
   1466            /* Process Unlocked */
   1467            __HAL_UNLOCK(hspi);
   1468            
   1469            return HAL_OK; 
   1470          }
   1471          
   1472          /**
   1473            * @brief Resumes the DMA Transfer.
   1474            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1475            *                the configuration information for the specified SPI module.
   1476            * @retval HAL status
   1477            */
   1478          HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
   1479          {
   1480            /* Process Locked */
   1481            __HAL_LOCK(hspi);
   1482            
   1483            /* Enable the SPI DMA Tx & Rx requests */
   1484            hspi->Instance->CR2 |= SPI_CR2_TXDMAEN;
   1485            hspi->Instance->CR2 |= SPI_CR2_RXDMAEN;
   1486            
   1487            /* Process Unlocked */
   1488            __HAL_UNLOCK(hspi);
   1489            
   1490            return HAL_OK;
   1491          }
   1492          
   1493          /**
   1494            * @brief Stops the DMA Transfer.
   1495            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1496            *                the configuration information for the specified UART module.
   1497            * @retval HAL status
   1498            */
   1499          HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
   1500          {
   1501            /* The Lock is not implemented on this API to allow the user application
   1502               to call the HAL SPI API under callbacks HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback():
   1503               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   1504               and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
   1505               */
   1506            
   1507            /* Abort the SPI DMA tx Stream */
   1508            if(hspi->hdmatx != NULL)
   1509            {
   1510              HAL_DMA_Abort(hspi->hdmatx);
   1511            }
   1512            /* Abort the SPI DMA rx Stream */
   1513            if(hspi->hdmarx != NULL)
   1514            {
   1515              HAL_DMA_Abort(hspi->hdmarx);
   1516            }
   1517            
   1518            /* Disable the SPI DMA Tx & Rx requests */
   1519            hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_TXDMAEN);
   1520            hspi->Instance->CR2 &= (uint32_t)(~SPI_CR2_RXDMAEN);
   1521            
   1522            hspi->State = HAL_SPI_STATE_READY;
   1523            
   1524            return HAL_OK;
   1525          }
   1526          
   1527          /**
   1528            * @brief  This function handles SPI interrupt request.
   1529            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1530            *                the configuration information for SPI module.
   1531            * @retval HAL status
   1532            */
   1533          void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
   1534          {
   1535            uint32_t tmp1 = 0, tmp2 = 0, tmp3 = 0;
   1536          
   1537            tmp1 = __HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE);
   1538            tmp2 = __HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_RXNE);
   1539            tmp3 = __HAL_SPI_GET_FLAG(hspi, SPI_FLAG_OVR);
   1540            /* SPI in mode Receiver and Overrun not occurred ---------------------------*/
   1541            if((tmp1 != RESET) && (tmp2 != RESET) && (tmp3 == RESET))
   1542            {
   1543              hspi->RxISR(hspi);
   1544              return;
   1545            } 
   1546          
   1547            tmp1 = __HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE);
   1548            tmp2 = __HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_TXE);
   1549            /* SPI in mode Tramitter ---------------------------------------------------*/
   1550            if((tmp1 != RESET) && (tmp2 != RESET))
   1551            {
   1552              hspi->TxISR(hspi);
   1553              return;
   1554            }
   1555          
   1556            if(__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_ERR) != RESET)
   1557            {
   1558              /* SPI CRC error interrupt occured ---------------------------------------*/
   1559              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   1560              {
   1561                hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
   1562                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   1563              }
   1564              /* SPI Mode Fault error interrupt occured --------------------------------*/
   1565              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_MODF) != RESET)
   1566              {
   1567                hspi->ErrorCode |= HAL_SPI_ERROR_MODF;
   1568                __HAL_SPI_CLEAR_MODFFLAG(hspi);
   1569              }
   1570              
   1571              /* SPI Overrun error interrupt occured -----------------------------------*/
   1572              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_OVR) != RESET)
   1573              {
   1574                if(hspi->State != HAL_SPI_STATE_BUSY_TX)
   1575                {
   1576                  hspi->ErrorCode |= HAL_SPI_ERROR_OVR;
   1577                  __HAL_SPI_CLEAR_OVRFLAG(hspi);      
   1578                }
   1579              }
   1580          
   1581              /* SPI Frame error interrupt occured -------------------------------------*/
   1582              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_FRE) != RESET)
   1583              {
   1584                hspi->ErrorCode |= HAL_SPI_ERROR_FRE;
   1585                __HAL_SPI_CLEAR_FREFLAG(hspi);
   1586              }
   1587          
   1588              /* Call the Error call Back in case of Errors */
   1589              if(hspi->ErrorCode!=HAL_SPI_ERROR_NONE)
   1590              {
   1591                hspi->State = HAL_SPI_STATE_READY;
   1592                HAL_SPI_ErrorCallback(hspi);
   1593              }
   1594            }
   1595          }
   1596          
   1597          
   1598          /**
   1599            * @brief Tx Transfer completed callbacks
   1600            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1601            *                the configuration information for SPI module.
   1602            * @retval None
   1603            */
   1604          __weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
   1605          {
   1606            /* NOTE : This function Should not be modified, when the callback is needed,
   1607                      the HAL_SPI_TxCpltCallback could be implenetd in the user file
   1608             */
   1609          }
   1610          
   1611          /**
   1612            * @brief Rx Transfer completed callbacks
   1613            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1614            *                the configuration information for SPI module.
   1615            * @retval None
   1616            */
   1617          __weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
   1618          {
   1619            /* NOTE : This function Should not be modified, when the callback is needed,
   1620                      the HAL_SPI_RxCpltCallback() could be implenetd in the user file
   1621             */
   1622          }
   1623          
   1624          /**
   1625            * @brief Tx and Rx Transfer completed callbacks
   1626            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1627            *                the configuration information for SPI module.
   1628            * @retval None
   1629            */
   1630          __weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
   1631          {
   1632            /* NOTE : This function Should not be modified, when the callback is needed,
   1633                      the HAL_SPI_TxRxCpltCallback() could be implenetd in the user file
   1634             */
   1635          }
   1636          
   1637          /**
   1638            * @brief Tx Half Transfer completed callbacks
   1639            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1640            *                the configuration information for SPI module.
   1641            * @retval None
   1642            */
   1643          __weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1644          {
   1645            /* NOTE : This function Should not be modified, when the callback is needed,
   1646                      the HAL_SPI_TxHalfCpltCallback could be implenetd in the user file
   1647             */
   1648          }
   1649          
   1650          /**
   1651            * @brief Rx Half Transfer completed callbacks
   1652            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1653            *                the configuration information for SPI module.
   1654            * @retval None
   1655            */
   1656          __weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1657          {
   1658            /* NOTE : This function Should not be modified, when the callback is needed,
   1659                      the HAL_SPI_RxHalfCpltCallback() could be implenetd in the user file
   1660             */
   1661          }
   1662          
   1663          /**
   1664            * @brief Tx and Rx Transfer completed callbacks
   1665            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1666            *                the configuration information for SPI module.
   1667            * @retval None
   1668            */
   1669          __weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   1670          {
   1671            /* NOTE : This function Should not be modified, when the callback is needed,
   1672                      the HAL_SPI_TxRxHalfCpltCallback() could be implenetd in the user file
   1673             */
   1674          }
   1675          
   1676          /**
   1677            * @brief SPI error callbacks
   1678            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1679            *                the configuration information for SPI module.
   1680            * @retval None
   1681            */
   1682           __weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
   1683          {
   1684            /* NOTE : - This function Should not be modified, when the callback is needed,
   1685                      the HAL_SPI_ErrorCallback() could be implenetd in the user file.
   1686                      - The ErrorCode parameter in the hspi handle is updated by the SPI processes
   1687                      and user can use HAL_SPI_GetError() API to check the latest error occured.
   1688             */
   1689          }
   1690          
   1691          /**
   1692            * @}
   1693            */
   1694          
   1695          /** @defgroup SPI_Group3 Peripheral State and Errors functions 
   1696            *  @brief   SPI control functions 
   1697            *
   1698          @verbatim
   1699           ===============================================================================
   1700                                ##### Peripheral State and Errors functions #####
   1701           ===============================================================================  
   1702              [..]
   1703              This subsection provides a set of functions allowing to control the SPI.
   1704               (+) HAL_SPI_GetState() API can be helpful to check in run-time the state of the SPI peripheral
   1705               (+) HAL_SPI_GetError() check in run-time Errors occurring during communication
   1706          @endverbatim
   1707            * @{
   1708            */
   1709          
   1710          /**
   1711            * @brief  Return the SPI state
   1712            * @param  hspi : SPI handle
   1713            * @retval SPI state
   1714            */
   1715          HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
   1716          {
   1717            return hspi->State;
   1718          }
   1719          
   1720          /**
   1721            * @brief  Return the SPI error code
   1722            * @param  hspi : SPI handle
   1723            * @retval SPI Error Code
   1724            */
   1725          HAL_SPI_ErrorTypeDef HAL_SPI_GetError(SPI_HandleTypeDef *hspi)
   1726          {
   1727            return hspi->ErrorCode;
   1728          }
   1729          
   1730          /**
   1731            * @}
   1732            */
   1733          
   1734            /**
   1735            * @brief  Interrupt Handler to close Tx transfer 
   1736            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1737            *                the configuration information for SPI module.
   1738            * @retval void
   1739            */
   1740          static void SPI_TxCloseIRQHandler(SPI_HandleTypeDef *hspi)
   1741          {
   1742            /* Wait until TXE flag is set to send data */
   1743            if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
   1744            {
   1745              hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   1746            }
   1747          
   1748            /* Disable TXE interrupt */
   1749            __HAL_SPI_DISABLE_IT(hspi, (uint32_t)SPI_IT_TXE);
   1750          
   1751            /* Disable ERR interrupt if Receive process is finished */
   1752            if(__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_RXNE) == RESET)
   1753            {
   1754              __HAL_SPI_DISABLE_IT(hspi, (uint32_t)SPI_IT_ERR);
   1755          
   1756              /* Wait until Busy flag is reset before disabling SPI */
   1757              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
   1758              {
   1759                hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   1760              }
   1761          
   1762              /* Clear OVERUN flag in 2 Lines communication mode because received is not read */
   1763              if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   1764              {
   1765                __HAL_SPI_CLEAR_OVRFLAG(hspi);
   1766              }
   1767              
   1768              /* Check if Errors has been detected during transfer */
   1769              if(hspi->ErrorCode ==  HAL_SPI_ERROR_NONE)
   1770              {
   1771                /* Check if we are in Tx or in Rx/Tx Mode */
   1772                if(hspi->State == HAL_SPI_STATE_BUSY_TX_RX)
   1773                {
   1774                  /* Set state to READY before run the Callback Complete */
   1775                  hspi->State = HAL_SPI_STATE_READY;
   1776                  HAL_SPI_TxRxCpltCallback(hspi);
   1777                }
   1778                else
   1779                {
   1780                  /* Set state to READY before run the Callback Complete */
   1781                  hspi->State = HAL_SPI_STATE_READY;
   1782                  HAL_SPI_TxCpltCallback(hspi);
   1783                }
   1784              }
   1785              else
   1786              {
   1787                /* Set state to READY before run the Callback Complete */
   1788                hspi->State = HAL_SPI_STATE_READY;
   1789                /* Call Error call back in case of Error */
   1790                HAL_SPI_ErrorCallback(hspi);
   1791              }
   1792            }
   1793          }
   1794          
   1795          /**
   1796            * @brief  Interrupt Handler to transmit amount of data in no-blocking mode 
   1797            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1798            *                the configuration information for SPI module.
   1799            * @retval void
   1800            */
   1801          static void SPI_TxISR(SPI_HandleTypeDef *hspi)
   1802          {
   1803            /* Transmit data in 8 Bit mode */
   1804            if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
   1805            {
   1806              hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   1807            }
   1808            /* Transmit data in 16 Bit mode */
   1809            else
   1810            {
   1811              hspi->Instance->DR = *((uint16_t*)hspi->pTxBuffPtr);
   1812              hspi->pTxBuffPtr+=2;
   1813            }
   1814            hspi->TxXferCount--;
   1815          
   1816            if(hspi->TxXferCount == 0)
   1817            {
   1818              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
   1819              {
   1820                /* calculate and transfer CRC on Tx line */
   1821                hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;
   1822              }
   1823              SPI_TxCloseIRQHandler(hspi);
   1824            }
   1825          }
   1826          
   1827          /**
   1828            * @brief  Interrupt Handler to close Rx transfer 
   1829            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1830            *                the configuration information for SPI module.
   1831            * @retval void
   1832            */
   1833          static void SPI_RxCloseIRQHandler(SPI_HandleTypeDef *hspi)
   1834          {
   1835            __IO uint16_t tmpreg;
   1836          
   1837            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
   1838            {
   1839              /* Wait until RXNE flag is set to send data */
   1840              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
   1841              {
   1842                hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   1843              }
   1844          
   1845              /* Read CRC to reset RXNE flag */
   1846              tmpreg = hspi->Instance->DR;
   1847          
   1848              /* Wait until RXNE flag is set to send data */
   1849              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
   1850              {
   1851                hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   1852              }
   1853          
   1854              /* Check if CRC error occurred */
   1855              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   1856              {
   1857                hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
   1858          
   1859                /* Reset CRC Calculation */
   1860                __HAL_SPI_RESET_CRC(hspi);
   1861              }
   1862            }
   1863          
   1864            /* Disable RXNE and ERR interrupt */
   1865            __HAL_SPI_DISABLE_IT(hspi, (uint32_t)(SPI_IT_RXNE));
   1866          
   1867            /* if Transmit process is finished */
   1868            if(__HAL_SPI_GET_IT_SOURCE(hspi, SPI_IT_TXE) == RESET)
   1869            {
   1870              /* Disable ERR interrupt */
   1871              __HAL_SPI_DISABLE_IT(hspi, (uint32_t)(SPI_IT_ERR));
   1872          
   1873              if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   1874              {
   1875                /* Disable SPI peripheral */
   1876                __HAL_SPI_DISABLE(hspi);
   1877              }
   1878              
   1879              /* Check if Errors has been detected during transfer */
   1880              if(hspi->ErrorCode ==  HAL_SPI_ERROR_NONE)
   1881              {
   1882                /* Check if we are in Rx or in Rx/Tx Mode */
   1883                if(hspi->State == HAL_SPI_STATE_BUSY_TX_RX)
   1884                {
   1885                  /* Set state to READY before run the Callback Complete */
   1886                  hspi->State = HAL_SPI_STATE_READY;
   1887                  HAL_SPI_TxRxCpltCallback(hspi);
   1888                }
   1889                else
   1890                {
   1891                  /* Set state to READY before run the Callback Complete */
   1892                  hspi->State = HAL_SPI_STATE_READY;
   1893                  HAL_SPI_RxCpltCallback(hspi);
   1894                }
   1895              }
   1896              else
   1897              {
   1898                /* Set state to READY before run the Callback Complete */
   1899                hspi->State = HAL_SPI_STATE_READY;
   1900                /* Call Error call back in case of Error */
   1901                HAL_SPI_ErrorCallback(hspi);
   1902              }
   1903            }
   1904          }
   1905          
   1906          /**
   1907            * @brief  Interrupt Handler to receive amount of data in 2Lines mode 
   1908            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1909            *                the configuration information for SPI module.
   1910            * @retval void
   1911            */
   1912          static void SPI_2LinesRxISR(SPI_HandleTypeDef *hspi)
   1913          {
   1914            /* Receive data in 8 Bit mode */
   1915            if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
   1916            {
   1917              (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
   1918            }
   1919            /* Receive data in 16 Bit mode */
   1920            else
   1921            {
   1922              *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   1923              hspi->pRxBuffPtr+=2;
   1924            }
   1925            hspi->RxXferCount--;
   1926          
   1927            if(hspi->RxXferCount==0)
   1928            {
   1929              SPI_RxCloseIRQHandler(hspi);
   1930            }
   1931          }
   1932          
   1933          /**
   1934            * @brief  Interrupt Handler to receive amount of data in no-blocking mode 
   1935            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   1936            *                the configuration information for SPI module.
   1937            * @retval void
   1938            */
   1939          static void SPI_RxISR(SPI_HandleTypeDef *hspi)
   1940          {
   1941            /* Receive data in 8 Bit mode */
   1942            if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
   1943            {
   1944              (*hspi->pRxBuffPtr++) = hspi->Instance->DR;
   1945            }
   1946            /* Receive data in 16 Bit mode */
   1947            else
   1948            {
   1949              *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   1950              hspi->pRxBuffPtr+=2;
   1951            }
   1952              hspi->RxXferCount--;
   1953          
   1954            /* Enable CRC Transmission */
   1955            if((hspi->RxXferCount == 1) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED))
   1956            {
   1957              /* Set CRC Next to calculate CRC on Rx side */
   1958              hspi->Instance->CR1 |= SPI_CR1_CRCNEXT;  
   1959            }
   1960          
   1961            if(hspi->RxXferCount == 0)
   1962            {
   1963              SPI_RxCloseIRQHandler(hspi);
   1964            }
   1965          }
   1966          
   1967          /**
   1968            * @brief DMA SPI transmit process complete callback 
   1969            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1970            *                the configuration information for the specified DMA module.
   1971            * @retval None
   1972            */
   1973          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
   1974          {
   1975            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   1976          
   1977          
   1978            /* DMA Normal Mode */
   1979            if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
   1980            {
   1981              /* Wait until TXE flag is set to send data */
   1982              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
   1983              {
   1984                hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   1985              }
   1986              
   1987              /* Disable Tx DMA Request */
   1988              hspi->Instance->CR2 &= (uint32_t)~((uint32_t)SPI_CR2_TXDMAEN);
   1989          
   1990              /* Wait until Busy flag is reset before disabling SPI */
   1991              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
   1992              {
   1993                hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   1994              }
   1995          
   1996              hspi->TxXferCount = 0;
   1997          
   1998              hspi->State = HAL_SPI_STATE_READY;
   1999            }
   2000          
   2001            /* Clear OVERUN flag in 2 Lines communication mode because received is not read */
   2002            if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   2003            {
   2004             __HAL_SPI_CLEAR_OVRFLAG(hspi);
   2005            }
   2006          
   2007            /* Check if Errors has been detected during transfer */
   2008            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   2009            {
   2010              HAL_SPI_ErrorCallback(hspi);
   2011            }
   2012            else
   2013            {
   2014              HAL_SPI_TxCpltCallback(hspi);
   2015            }
   2016          }
   2017          
   2018          /**
   2019            * @brief DMA SPI receive process complete callback 
   2020            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2021            *                the configuration information for the specified DMA module.
   2022            * @retval None
   2023            */
   2024          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
   2025          {
   2026            __IO uint16_t tmpreg;
   2027          
   2028            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2029            /* DMA Normal mode */
   2030            if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
   2031            {
   2032              if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   2033              {
   2034                /* Disable SPI peripheral */
   2035                __HAL_SPI_DISABLE(hspi);
   2036              }
   2037          
   2038              /* Disable Rx DMA Request */
   2039              hspi->Instance->CR2 &= (uint32_t)~((uint32_t)SPI_CR2_RXDMAEN);
   2040              /* Disable Tx DMA Request (done by default to handle the case Master RX direction 2 lines) */
   2041              hspi->Instance->CR2 &= (uint32_t)~((uint32_t)SPI_CR2_TXDMAEN);
   2042          
   2043              hspi->RxXferCount = 0;
   2044              hspi->State = HAL_SPI_STATE_READY;
   2045          
   2046              /* Reset CRC Calculation */
   2047              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
   2048              {
   2049                /* Wait until RXNE flag is set to send data */
   2050                if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
   2051                {
   2052                  hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2053                }
   2054          
   2055                /* Read CRC */
   2056                tmpreg = hspi->Instance->DR;
   2057          
   2058                /* Wait until RXNE flag is set */
   2059                if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
   2060                {
   2061                  hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2062                }
   2063          
   2064                /* Check if CRC error occurred */
   2065                if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   2066                {
   2067                  hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
   2068                  __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   2069                }
   2070              }
   2071          
   2072              /* Check if Errors has been detected during transfer */
   2073              if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   2074              {
   2075                HAL_SPI_ErrorCallback(hspi);
   2076              }
   2077              else
   2078              {
   2079                HAL_SPI_RxCpltCallback(hspi);
   2080              }
   2081            }
   2082            else
   2083            {
   2084              HAL_SPI_RxCpltCallback(hspi);
   2085            }  
   2086          }
   2087          
   2088          /**
   2089            * @brief DMA SPI transmit receive process complete callback 
   2090            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2091            *                the configuration information for the specified DMA module.
   2092            * @retval None
   2093            */
   2094          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)   
   2095          {
   2096            __IO uint16_t tmpreg;
   2097          
   2098            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2099            if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0)
   2100            {
   2101              /* Reset CRC Calculation */
   2102              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
   2103              {
   2104                /* Check if CRC is done on going (RXNE flag set) */
   2105                if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_TIMEOUT_VALUE) == HAL_OK)
   2106                {
   2107                  /* Wait until RXNE flag is set to send data */
   2108                  if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
   2109                  {
   2110                    hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2111                  }
   2112                }
   2113                /* Read CRC */
   2114                tmpreg = hspi->Instance->DR;
   2115          
   2116                /* Check if CRC error occurred */
   2117                if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   2118                {
   2119                  hspi->ErrorCode |= HAL_SPI_ERROR_CRC;
   2120                  __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   2121                }
   2122              }
   2123              /* Wait until TXE flag is set to send data */
   2124              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_TXE, RESET, SPI_TIMEOUT_VALUE) != HAL_OK)
   2125              {
   2126                hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2127              }
   2128            
   2129              /* Disable Tx DMA Request */
   2130              hspi->Instance->CR2 &= (uint32_t)~((uint32_t)SPI_CR2_TXDMAEN);
   2131          
   2132              /* Wait until Busy flag is reset before disabling SPI */
   2133              if(SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_BSY, SET, SPI_TIMEOUT_VALUE) != HAL_OK)
   2134              {
   2135                hspi->ErrorCode |= HAL_SPI_ERROR_FLAG;
   2136              }
   2137          
   2138              /* Disable Rx DMA Request */
   2139              hspi->Instance->CR2 &= (uint32_t)~((uint32_t)SPI_CR2_RXDMAEN);
   2140          
   2141              hspi->TxXferCount = 0;
   2142              hspi->RxXferCount = 0;
   2143          
   2144              hspi->State = HAL_SPI_STATE_READY;
   2145          
   2146              /* Check if Errors has been detected during transfer */
   2147              if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   2148              {
   2149                HAL_SPI_ErrorCallback(hspi);
   2150              }
   2151              else
   2152              {
   2153                HAL_SPI_TxRxCpltCallback(hspi);
   2154              }
   2155            }
   2156            else
   2157            {
   2158              HAL_SPI_TxRxCpltCallback(hspi);
   2159            }
   2160          }
   2161          
   2162          /**
   2163            * @brief DMA SPI half transmit process complete callback 
   2164            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2165            *                the configuration information for the specified DMA module.
   2166            * @retval None
   2167            */
   2168          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)
   2169          {
   2170            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2171          
   2172            HAL_SPI_TxHalfCpltCallback(hspi);
   2173          }
   2174          
   2175          /**
   2176            * @brief DMA SPI half receive process complete callback 
   2177            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2178            *                the configuration information for the specified DMA module.
   2179            * @retval None
   2180            */
   2181          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
   2182          {
   2183            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2184          
   2185            HAL_SPI_RxHalfCpltCallback(hspi);
   2186          }
   2187          
   2188          /**
   2189            * @brief DMA SPI Half transmit receive process complete callback 
   2190            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2191            *                the configuration information for the specified DMA module.
   2192            * @retval None
   2193            */
   2194          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)   
   2195          {
   2196            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2197          
   2198            HAL_SPI_TxRxHalfCpltCallback(hspi);
   2199          }
   2200          
   2201          
   2202          /**
   2203            * @brief DMA SPI communication error callback 
   2204            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   2205            *                the configuration information for the specified DMA module.
   2206            * @retval None
   2207            */
   2208          static void SPI_DMAError(DMA_HandleTypeDef *hdma)
   2209          {
   2210            SPI_HandleTypeDef* hspi = (SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2211            hspi->TxXferCount = 0;
   2212            hspi->RxXferCount = 0;
   2213            hspi->State= HAL_SPI_STATE_READY;
   2214            hspi->ErrorCode |= HAL_SPI_ERROR_DMA;
   2215            HAL_SPI_ErrorCallback(hspi);
   2216          }
   2217          
   2218          /**
   2219            * @brief This function handles SPI Communication Timeout.
   2220            * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
   2221            *                the configuration information for SPI module.
   2222            * @retval HAL status
   2223            */
   2224          static HAL_StatusTypeDef SPI_WaitOnFlagUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus Status, uint32_t Timeout)  
   2225          {
   2226            uint32_t tickstart = 0x00;
   2227            tickstart = HAL_GetTick();
   2228          
   2229            /* Wait until flag is set */
   2230            if(Status == RESET)
   2231            {
   2232              while(__HAL_SPI_GET_FLAG(hspi, Flag) == RESET)
   2233              {
   2234                /* Check for the Timeout */
   2235                if(Timeout != HAL_MAX_DELAY)
   2236                {
   2237                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   2238                  {
   2239                    /* Disable the SPI and reset the CRC: the CRC value should be cleared
   2240                       on both master and slave sides in order to resynchronize the master
   2241                       and slave for their respective CRC calculation */
   2242          
   2243                    /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   2244                    __HAL_SPI_DISABLE_IT(hspi, (uint32_t)(SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   2245          
   2246                    /* Disable SPI peripheral */
   2247                    __HAL_SPI_DISABLE(hspi);
   2248          
   2249                    /* Reset CRC Calculation */
   2250                    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
   2251                    {
   2252                      __HAL_SPI_RESET_CRC(hspi);
   2253                    }
   2254          
   2255                    hspi->State= HAL_SPI_STATE_READY;
   2256          
   2257                    /* Process Unlocked */
   2258                    __HAL_UNLOCK(hspi);
   2259          
   2260                    return HAL_TIMEOUT;
   2261                  }
   2262                }
   2263              }
   2264            }
   2265            else
   2266            {
   2267              while(__HAL_SPI_GET_FLAG(hspi, Flag) != RESET)
   2268              {
   2269                if(Timeout != HAL_MAX_DELAY)
   2270                {
   2271                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   2272                  {
   2273                    /* Disable the SPI and reset the CRC: the CRC value should be cleared
   2274                       on both master and slave sides in order to resynchronize the master
   2275                       and slave for their respective CRC calculation */
   2276          
   2277                    /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   2278                    __HAL_SPI_DISABLE_IT(hspi, (uint32_t)(SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   2279          
   2280                    /* Disable SPI peripheral */
   2281                    __HAL_SPI_DISABLE(hspi);
   2282          
   2283                    /* Reset CRC Calculation */
   2284                    if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLED)
   2285                    {
   2286                      __HAL_SPI_RESET_CRC(hspi);
   2287                    }
   2288          
   2289                    hspi->State= HAL_SPI_STATE_READY;
   2290          
   2291                    /* Process Unlocked */
   2292                    __HAL_UNLOCK(hspi);
   2293          
   2294                    return HAL_TIMEOUT;
   2295                  }
   2296                }
   2297              }
   2298            }
   2299            return HAL_OK;
   2300          }
   2301          
   2302          
   2303          /**
   2304            * @}
   2305            */
   2306          
   2307          #endif /* HAL_SPI_MODULE_ENABLED */
   2308          /**
   2309            * @}
   2310            */
   2311          
   2312          /**
   2313            * @}
   2314            */
   2315          
   2316          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_SPI_DMAPause
       8   HAL_SPI_DMAResume
       8   HAL_SPI_DMAStop
         8   -> HAL_DMA_Abort
       8   HAL_SPI_DeInit
         8   -> HAL_SPI_MspDeInit
       0   HAL_SPI_ErrorCallback
       0   HAL_SPI_GetError
       0   HAL_SPI_GetState
       8   HAL_SPI_IRQHandler
         8   -- Indirect call
         8   -> HAL_SPI_ErrorCallback
       8   HAL_SPI_Init
         8   -> HAL_SPI_MspInit
       0   HAL_SPI_MspDeInit
       0   HAL_SPI_MspInit
      32   HAL_SPI_Receive
        32   -> HAL_SPI_TransmitReceive
        32   -> SPI_WaitOnFlagUntilTimeout
      16   HAL_SPI_Receive_DMA
        16   -> HAL_DMA_Start_IT
        16   -> HAL_SPI_TransmitReceive_DMA
      16   HAL_SPI_Receive_IT
        16   -> HAL_SPI_TransmitReceive_IT
       0   HAL_SPI_RxCpltCallback
       0   HAL_SPI_RxHalfCpltCallback
      24   HAL_SPI_Transmit
        24   -> SPI_WaitOnFlagUntilTimeout
      24   HAL_SPI_TransmitReceive
        24   -> SPI_WaitOnFlagUntilTimeout
      24   HAL_SPI_TransmitReceive_DMA
        24   -> HAL_DMA_Start_IT
      16   HAL_SPI_TransmitReceive_IT
      16   HAL_SPI_Transmit_DMA
        16   -> HAL_DMA_Start_IT
      12   HAL_SPI_Transmit_IT
       0   HAL_SPI_TxCpltCallback
       0   HAL_SPI_TxHalfCpltCallback
       0   HAL_SPI_TxRxCpltCallback
       0   HAL_SPI_TxRxHalfCpltCallback
       8   SPI_2LinesRxISR
         8   -> SPI_RxCloseIRQHandler
       8   SPI_DMAError
         8   -> HAL_SPI_ErrorCallback
       8   SPI_DMAHalfReceiveCplt
         8   -> HAL_SPI_RxHalfCpltCallback
       8   SPI_DMAHalfTransmitCplt
         8   -> HAL_SPI_TxHalfCpltCallback
       8   SPI_DMAHalfTransmitReceiveCplt
         8   -> HAL_SPI_TxRxHalfCpltCallback
      16   SPI_DMAReceiveCplt
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_RxCpltCallback
        16   -> SPI_WaitOnFlagUntilTimeout
      16   SPI_DMATransmitCplt
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxCpltCallback
        16   -> SPI_WaitOnFlagUntilTimeout
      16   SPI_DMATransmitReceiveCplt
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxRxCpltCallback
        16   -> SPI_WaitOnFlagUntilTimeout
      24   SPI_RxCloseIRQHandler
        24   -> HAL_SPI_ErrorCallback
        24   -> HAL_SPI_RxCpltCallback
        24   -> HAL_SPI_TxRxCpltCallback
        24   -> SPI_WaitOnFlagUntilTimeout
       8   SPI_RxISR
         8   -> SPI_RxCloseIRQHandler
      16   SPI_TxCloseIRQHandler
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxCpltCallback
        16   -> HAL_SPI_TxRxCpltCallback
        16   -> SPI_WaitOnFlagUntilTimeout
       8   SPI_TxISR
         8   -> SPI_TxCloseIRQHandler
      40   SPI_WaitOnFlagUntilTimeout
        40   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable10
       4  ??DataTable11
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable4
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
      18  ?Subroutine0
      18  ?Subroutine1
       8  ?Subroutine2
       8  ?Subroutine3
       8  ?Subroutine4
      46  HAL_SPI_DMAPause
      46  HAL_SPI_DMAResume
      52  HAL_SPI_DMAStop
      48  HAL_SPI_DeInit
       2  HAL_SPI_ErrorCallback
       6  HAL_SPI_GetError
       6  HAL_SPI_GetState
     180  HAL_SPI_IRQHandler
     130  HAL_SPI_Init
       2  HAL_SPI_MspDeInit
       2  HAL_SPI_MspInit
     480  HAL_SPI_Receive
     186  HAL_SPI_Receive_DMA
     162  HAL_SPI_Receive_IT
       2  HAL_SPI_RxCpltCallback
       2  HAL_SPI_RxHalfCpltCallback
     336  HAL_SPI_Transmit
     704  HAL_SPI_TransmitReceive
     240  HAL_SPI_TransmitReceive_DMA
     150  HAL_SPI_TransmitReceive_IT
     164  HAL_SPI_Transmit_DMA
     162  HAL_SPI_Transmit_IT
       2  HAL_SPI_TxCpltCallback
       2  HAL_SPI_TxHalfCpltCallback
       2  HAL_SPI_TxRxCpltCallback
       2  HAL_SPI_TxRxHalfCpltCallback
      42  SPI_2LinesRxISR
      32  SPI_DMAError
      10  SPI_DMAHalfReceiveCplt
      10  SPI_DMAHalfTransmitCplt
      10  SPI_DMAHalfTransmitReceiveCplt
     194  SPI_DMAReceiveCplt
     110  SPI_DMATransmitCplt
     194  SPI_DMATransmitReceiveCplt
     228  SPI_RxCloseIRQHandler
      68  SPI_RxISR
     134  SPI_TxCloseIRQHandler
      64  SPI_TxISR
     194  SPI_WaitOnFlagUntilTimeout

 
 4 542 bytes in section .text
 
 4 542 bytes of CODE memory

Errors: none
Warnings: none
